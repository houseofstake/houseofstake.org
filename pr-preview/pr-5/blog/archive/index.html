<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0529c83a23c643eb81141001df44c61e1afa6a1191092cf20bdcbb298529a4112c700a987594cc4571ea47f1a8b3d820053b9a2985a38c63fdff061f2ddfc200cfea3698fe998bf715d7f7a8739e5f808e7017de4cbc2f09ce99e561916dbd628fbe0116ca3e7a73ce50f65cb919ea9bfa7fd8bfc968e7bac809bed0bdbe8b5a60e2deac528b0bba26250c8a99a1ad4537ceed7401f5fff2470e24b297c715966bede249778e1596c04c438cdc91e4fef418117e018561d1abdc84580f41054b663e13e8498809437bfc6ce0129256e5df22457c9959aa18762824c2eb9e7da881806ec585164e24f1e3de0a591cfe1df07643830658b07855e9c2be091961419543c77476c42665c221140dce1189cf3e8832a15f874d113a41ec9af80954fd6016bec2db86d83ec42ca5ce2c315e0af0e979badc69a00dfe5d617b3a66ea8fda733e46567dcb86cbc8a5abb3b2b2b0e33c114322022bd125e9254aa25e3c79b863abcba53823e66c7e191851f37b69ac33e2e99feab9f260938e3bde013d2a591b8c3a4d3052570ed9aa8ae048f41d1d95d8691bfae24621225ca99028c77a6c452303dccbe7797f3ee6aaee69b46af2fbc916fe3760ecf27065b0a0ffcdbbd0d7a3b9796e2dfec73f55d39ebbf2c9539e681db4d28a5e2f1d2ef31433e836c2c8e6b793e9d4c66c73fb1dbd868816d8c098de458c43c00cc6dcd23c37c4b3d74b3ade1a375075844232ba84d8c5c2274f6057476b350abb02a7e21bac1cfb4780c7ebbfda0fca1fbab360b0978c0c699e7312ab22334b6da2566f5285b76086fb9403e71e86590c63e47fd33b9b0c824d4fff1da0cb0563a38af02ce93ea5ec85c5920071b0cfa666aaa2cb9cfe56edfbc38dea40fa3cb20f5816b7261637df14d61af513500fcfe66fe832a2da47fed8cef12b90f38a990e89b359d1ee58563ef6bd663bc5bd7d8d7c3853372e470248cba17fc095c9cd80134f9b5080a5d0ae59993d4651ba3c6ce3b48d5a62d8502515f7dcc5893c3b1d8a8fc4d8bd5c35e4a9564fe52d761259f66eefbe00da378f70c009de504cdd3f767ea2ab76d1b6ebdd277641cf1bd6a217bc202ab33b22747a4db4fc49f712d96112423d7bd700cb136559236e857f45b359edd7c657a21be67e891d8597892c1c4722c2bae5af7056d1eb8236fa269c52b5f2fae1aa67da4fe31c112ad1c89efaac9c9890083716037d84539adcb180e432c81f79e3b38e63f2df48129e36c910aee3e1d1c5230910c68d21b6e41beb92d45a7758696122d39037c874ee35d0752edb77992232785d6f9218f6109db10e5908668a739fb87d614841f43db220541ada89624c9807228d73cfabc5e54983c5b840262bbdc523e93045f502e8c6987cf08d4a287b1871c2c94549f5b1b32cc63e9016362a7c7196139b3c93e651d94127e777925dedfcebd5a445df3f6a92424c2d918e244702edf2ad48cb4aa08c015cb7b19a4a397cd654459078a11712a86d455ecc3ab151c01a3563274e94e9663c1c0f78f3204ef78ee9234767b2cb11add88a756e5b99860fb6101d094cc75d3d47d3b63a02cae6a1b44064d59fd218eaa4057f623aa65d52f334de432a0c906f9d3b0c75e816635590842c472879e8e7602df48bde280a2876df28c57ece3354a568eb03b7341caa1ffe2d66e9104899e68539e0822bb4ac46b12cfa3d1aba68dc314bb4ff85b337b3833d355dba8c3cb95de8aefc4799b556db8cc6d6573399dd3cf5ecd5f2b052000cda44e6a3c9c2d97fed3df3f02ec7a3c777603d767311f9421b29cc27a2bb35791d3595584a4d6b3e2b18a5f8e2ec21eeb532124e51179155b65dbc8e374649a223acd699dc215556808ea71b82e58c5c79ad8e050794615c3834309e5bacc90b584834dac58f9a5b838d1551b2a01fa54ab3980a0f6d918f07f960317eecfe4d3d1e8967606f7ccab50a79bf9435f3102d7d33c67bdf0a10d41ddb5d17746a4d8e8d47011d3dc2598e786d07f364777acc3c680338fac002679dbbef9e81ac7942d8f47e06a504e04e8ddc49ba1a61cca760c799f9cb47ee5fe295095a3bce3ee9ef36d698c4fdf4265df6a98c0762bd5cd2bb716960305ea38fd1a9203544f8609fc4680842c3d02a9345dce6abd53988ae48bc1125ad3a2f61e04995b8e8315da9269b87c64b98736fb6aa110e0ebc7cb14c5c9c0dc44b08a38237b82c034320c4c9a432436e43ac188eeaa18d2b65b0c5278be4025222cb4a5fda5aa33767aaefa0da8dd7176e10368bf33bc006d8ce4c18ff339ddcbf47ce10afbbcf749de74925fadcfc4f2af3757c67c896c0b59c22e9cb8d506922c93dbc2eddfa5346d5c191d64f73dcfa90d6e96bc2b75b145ae180032eb4c24d497bce81589c9e1dc478cc71ab777bd3578e538037b7f09c0cc8b802b38c224e26894c43823236c0d40e0a054fd229221a925b57dded3f6244a8a81da115f07c851836b9145fa31e99a04bd4d98581c619bd753255ece7a1cb8eee3d56455c161799650453016139a623c92cd835bfce4a54007f1ec6c90de2329c08da89d17710399e4b0f504213451173c71106a5b05d371eac5aeb9b51cd7424732c5767ef8a1353e9491b689a5601fdeeb302b521b0883b6b68edc84f2e4a053ccb9c487964bb3eff4909371802d9a6b0edca65dafe39c1cd0732d30167a28b17324800b9f5e93c37841841ac42fe73b1396652595de46f6986d784e6573bf221a1be7b6bba374550afe325f725b4b077a953b6ab8154178912eec8958737f9013a98f687da5bad4b1dec6a6670b58ef2b99f244d4bcc2ce795a672d85aca287835bfb59ee40c6b1ee44a7cf0df7480fb15efc54428f12df561079f236a7f7e0ca9c83fe3fa1a77ef84b8ae0deeeb6b3f211012d4b72ac8ae9f38e97f7cc52571401830f12120dde8d8ab6cecffd492ab2e569b61bd715ecf454bdbf288d9d905c141ea764888081e6e0ccd047f7dce2241227e9f87c15568e60cc253af56d05444ec376f0ce440ab3591411ce779e1c521276583bca8c4e72754f99192fad5f69e0ae361cb0c56c4c1dc476c9938f5ce68354eecea4fc1703a3fe21fb856cfd59cd4bc3f56137fc396525bffabca87601876fc89597858e5f2b109335785f849455801b02e6479c3d6ddabfa95cd6d74e15e2596abbbcddd89527e433c19c993841564dc8de4ba29f297738f67bbf16991dad77ca649590d0179ebe8e5e3acf6d054ddd9d14da1a36b51f5c094fd588c48e3b7ac64dd146682e00db9b43dc64ee5e1a2aaa250a39c8cfbb5cbedbb8c8a3cf775b4c36d15db4404af0b4e9d41d9ecd777a0f869196f84a1cd242c374b426d4cc61867bc699dbdb9ad83110a7231b959b22133ea79039645df24e1e58b46521c2af9ce0358a15233d694e0bcfed942258439d777b516537a4d524be565a1cee5455ce59f7e5af58ecc3561cc0277cb8b55ac33ad6ca8b54320d0db8cad2f776e997ba00c0a2a5711c4726b2b9154c81b76bffe2fae41e5e19c9521a42c911d39bff27199487aa787e2e1eead4976927cc213c35e2817645e7d2214e89a064680364a5c61e9f5360ba79359999ff7f54481a729ce4d2863b553aa90c5ae900623cefb5d93c99a15b06525405bd86310ae5b9f5a13398a4eb70a8b6d742758bacab707626dd5b5dc18feca3e136932843020d130aae530199f88fa3f67b415d85609023acaab0de12099beac8a0fe93238ca81cde34047012d8ce3979996ba8849d67b9bac98da984d70d5d09afdb2036293dc579210dbcea048fa10084883a952226010c1a705bc62a20132b3f4397941fa534a3acba09e229d2af85c11e4f463e4e4c06209e3e28b68b89d0915d23397e514ec460c119dd1770870b319a739f9d25d0b774d84f5a22377eef98dde288f2bac75017aa894e3319a58322488ad3423126783cf9f35b26bdb0d5c1d090e6f1311a5bc6d24ba94e16eda40e3d61251d78d114f507472d89f582d9f95a4d1375d8e0f44822a14c6c67bbb65fd0520fadb5b3668e95e5a46a9c7d932c002520e42ff90de0f382037c001f618e733209a9cffc682a1cc7292eb0b71275e606c67f1d7b2ebf67e80f6a336e31e08f850095a2f8cd6a5033a978900e59657d146701b38fd9e991893c2fb98727c5ff7b34a2deae459063e05dd55a31f0da3e7f064a49c6dad56d417611322636a1e25e7b38917a0d7c4ed1e993d93aaa31c421bfdf035a090fd6061c6d1bdccda34cdde583ea02bf310fadb05d5f6b91c37039e6aa01cb5af99e2605b2c42ca05c15b6194b8e0097192ef99f0559d7c8baafbc5ee5e1b1ca92d524df8924b3bb8cd37ecbb99aab8ce3fe70fd5931bbbd040b84ed0b59c173991613c03e60edffe7be9239bc5bc509e28766124450d4926829fb169278639512edc0d461d214a71a68272dab4ccad524b746a7a52fcc6529f69eff79d83369f26c56b2d6f6e8670d8c2077a74d26c4025697ca1c576f309b56a8fa674b1beee4f4e52e48ba7023bf6e74c24f7bb67a2ce235fae7e846620a30b9baf0c5c27de8e7fd50eaf353341bd177d248aa2c1e14195469b43972f6588050726b4f09a2347bf4d7be4f80df9d884ffcca0f4825906bb491513d3da21db71339cbd931404e51e406ac7760e4dbda5e990f3fb8baa0213647bd6ea93058f49457a09159fc2ad35c0c42ee95bf31f0b92b10ff0f4d12bf64a90ed5cd045d0a2204d5accb29ea8be998c356dcb90f11587e99c99535e61d25184c6123e6c11ddc6c7a14a1d49af37c2e98c4ea14d0ce6405fc5cce7ab9312af6326aee12cc09e5615b4eaec4613f8a815c92c534d5ff49a1badff4583c50776e7688384dc1c0e5005a4d0ec76ac4d0d34f6517d1defce3f947e1cf4c720e7445bef3f60966f5dbef5d9c3977de78908703866968e37c26711ef649f6e5407d8d26095925347217e1c2fd7a7f24128a0d62885439efab90ec1fe89a0702bee3cd6d8f7c86f586b5f736cbeb08a3b520c5905592f61f7cb118c3445d5897d9257e68096ce1339f96a863a1ffb661a0d5b7f9237e2a228086744d038911436b5c9abb143a16ffea6d35ef7eaf279887518566a7fd292091264cdeae4979fa1720bf24c9580b679365e549e501ebdf8c2bfadf8f528aea0cc1c9940d4aba85d7ce6fd82020068c9e3dcae792668a388cb69f1c555b680fd38fcc91cd49bb0b91082307a9d59ed136b864bc0977c43141fc6f8a2ada3335a50a66a67d64f802c04e7fbc1022cec89bf4a7f2abe447ce342974d926a3067989a63c3610512c599a03fb6fcf947f9b9867eb39920888265a26115afbd862ff1a2f8c72648c64c2ce4159ca62532ccf5c5d0b9d998b1407dab7fcf3925509c7e850afc07663f2fef469657fa759a549ecf5f440b4d070064d29c5c807793b74fe89e52e2d30f39a0c45fc31a6282b2cf17111712cd7dba9788c1a8e517b90405bfa9dc8ddbe32b9b12994eed7775a4988c8b79a2dd1eb771531f706dbd31539d59a737928a498a3c1f332ec8e5f25855c4533af1d2bdd793e62425ce424b9368b8e295ab8eeae86855ba528000297b0c8cbbfa96637e6575319d4929e30e0389333c69e001a0dc5e7d1a0e65f126f54fc13995973054b388112182e0e13696e88a82094a545a22d663f259ec1d940aa7e6d5636bbac36b6dba05cee0601647d65460e854346218558023e19ea789058cf5c35fa1378532a816c2e1b3e0dc48eff81a294ecfd27169d3841f0c0e0bd595b44d1b22cb0704417591fb46797d898df565f0a247f5672602b0f0a753b4d1232da009b1acd41a14d778371d22df242519f38a87833f9a7a2186f3eafb41b2d3c48cf646e8774e4fe890927a41ebe66ea978638e8c910fe2a68011ca256aefe54c6e17258f783e7fc0d6299c569fda6e33d34267c96cf7187d53fbeff8debb536c8ace88cc6350f372776eff4d3864bb8c76a7e4a8dee4ba9d3204b706f11dfb55f5f4ebd8483f407ad266ede740e78b1fda2bcec577d6e129ac9f06415e92810d9689f748c5cf1c440870971bf183bb77071ff756668b7692d59882cf822c5327f077defecc67b9005c62df3496cbdc5b15306fe285d8ba9a2eb314bac2cf2773960e544216f01d433d2c6b1dd973be011aafe3a79f2f16c57c400877416851a90bd7136b49c3e9ffa974ee749ca46f5a4b90642c49f1d3b45a321cd243033c7af6bc49156c0a1e67f96007e17efb3c525cb16f353a55e3ba5205facefd41649e62e57954dc2d62867e4934e7f3f3105c879fe9374f086edb526f2a1f834432d9220ca01977164e7c1c06c0947bf5a103ae4f8bb09368b81dde526b209b066a77daf00543a75dec865fd227c52c2dc6ca49a5768e86d0245681f8c6afa31b44939ae0cefa0bd452a38314816264f9d20ceb63a9dcd544ff87fb199d5ee946a30bfffed2da1dce823b876fe0e8b1eecab1941b937576bd2b42ff11506abce23d8a2d10dd48401e6308001b797527903424b9005253d0fbe9b04797bd7c685a3b8103fbbd3aae9a6c2aa5dcdd387fbece43376b1688b715ff90476d44be465aaf9849376383ad4ce31f1ea793d6e7b7c4d34efc084d3c7b5f42a54fd8537bff19fa7782485394163edf92f8d1b25a92d72f129b56f8494f52f655ddaa18149b3f5a4cbe461bdcb04ab3bf0a95dfafe8baf7875ebdafd30c21e83074d2e9e957b46c3f5adfb5c610bfde56482bc56b48b29bb879cf74c2b0bec0631c884da1c7db91b59a2cdb7bae73ad6d8428234c1a0793a3e35fa477fb7417b95020b4a4705d44fd2ed773619f535b4ffd61c1fab5b1f06be6b98d0c5a0f387eaf8fba4dfbeffcc8d23d0bb68b14d3455be97da4737986b541c3f764cd6ccb9c0edcac877486d845682e484ceece60ddf9812dd5907aaa1859bc08e013104efa7c4aace4833bc44f181c2e67e317b029444cbcf4d3b6d5f531695643bdbfa222f46a2102a9b2da0d652152eef54152857a9a8ef13f4bce10b4afa5c14504c2b694aa7e654cda21132b1754a2be4e56ff72e869d4a1c39b50b152310e3b3d30782b8d1746bad45031dda967a2bd5336c5ab26bba1f98a08a26ae38fb13cb8294819162c4635b458a5ceb49b64459cc1d2f9d68442405ba2c39f4402ef74859352043e28e999b9749493305e52409097e1c63fa872515d24c5d187dfab5e51ede8ae8181999c549c183a0e8dce507338b9587c7217efd5a9a49334f6147080727798c6209f88b98b830fe9e7243b6990c4f619496c0ea63b7f10462377cc000611e28513b766a7b53d1628e45c9ba8978d5fde0fe702cd0932c3643eb259533402b207ff4c7d4de5b72e8253b09a7a1ee616cca1c7b8919dea28a6bf41dca4e40dc4c3ce7cc2288cd8bc4b8cf2e187a52cb0df3bc262ae54906999bbe316b21c8f51345c9db82a0977f74d64cc4e4a437a7f3af22001bba38d24f5d465c6c992066c17358b0ed9320ad54d8c199129cfd6b488550e932f893c970f12791fd5079bfd287ada052d1950b40f0ac3b3248149e5385e1ccad8fd600df4a770fc43ccfe7897a16f08dfafaa92b45d4324c75d5ab63ee301790a7a8f4ce094e31b697d106547c986b715c8b730f515537901b13516efa3e3c56e9a61c4ce55b17742af00f8b256e169df451d14eff438df879ed067bc21b0f0962a95a7579c75dbde54fdd5ccc112631e06501746768120150abda71030537f484f1722d4c37fb9a40c4cde7cfe98319dc766652810fca77aba77feb5be44eef1ab64aa37afb5602f7c056f8ecf7fde5a59ba8b37f882cd74d37f6c4c760aed7b75a0f5fa72ac74c067809c131d2c78386c4cfdf1ada75116f707c765d3778d6e6ea5be7a1664cfb60114254f3e0bc39bb31bc5b75c675554d6f3a707b88f48c76f11cde83e3f05202a36a7859477bfcb854853008106abb19acfa7346c4e171b9f9e53212b550bbe65d81bcaddb4fddc8c11f24d7d7dc90184063d63888cae02ef34fc0034ef562db22ede7a047c9fbdb3f9ed848c278cbead674169d4f3d40fe988d1d7cb263bc0872c47bbc067c35872b21478e95a3850cf27323d94406794182e8da7cb9f93f3a91353e0f444f45e4bce34746d89c49312211e3e869b70cd31579dfd0dca71f153d72858a723950130c7007f29894e7647f35548ade00956b9eaf21a76fb8d67191a0bc63a879326ec3aaf4275ea94809f42f5e9f37c98d2bdf7e9479e544f1d8f36827a847c33a2d7fb61be62cadfa7b9aad2c68e1a04fb61a93ca904d4f364364a0e18a078b4844b7d2c33fa015cdce6f54b960b557b5a790c51fd201d30189dfabc3f72a26e224f6943c784ec34a2c7ef88347e79ea3ff2e00b3604d72ab1794e91fc64de3fcf4ede4dc2b2914bb4f5331016e5edac7833979a0fec3a9acc06da258704d23e82f893379dfa5c525817c3db8ee68c036f23a0e7bf738b7337521ce5e957525df7518f0b9824a25a055b2e20d7d839977d2afb0608caa8780be3ffd17b34171e2797bbb313c91a8fc823a212c8d335a139503bf97edd5130cb0dfd242568052e39e3d384ade62a36e257c42bdcb85cf6ed68d738218622eed2fbe0d36c77c64cad4467667c45df83e31f619c58c2f8cbda663a067a8055a96483ac57d5482fa384fcd3a26d47f37bfc7c345466f6db076cfeec0e86da45ca08141061ef10b946120c7699650fa40f7d538e546b4c77763fad5c0255e9074be145611d0303d82f7a8f12de3479915bf8b1617d53bf86a1b5a5397ad63aa00143e520b8e8dfaeb84a1ffd046f2b206196324a301e049884b0b4248642f6c274f8df81104e86b2034ef3659c62212f150857b9658f832befb958f544a4d2bf3390050b252c86094932afa50d1b344a7bb467a94b5b72d0ecab5dfefb775f274f65b466f533daec7f12055d4a8ff306d7d29e448a000d992fa72c12210e9e41bb8684b25e9ef21520df893e762f5411daa4d7a31c5cadc62ab5e32ff29a43997e1de2b2867d92a6f05344539017cc2719d2e4f9e30d35aab7d4c98a5a38861304e474da3a4b858e60a93bb6cda5614ec4737f8de03122e7d05420fb17309f73c233592942f99c93ff08f46c52cd8d78b6a8a29d3f6d925caf17fddcb3e91af517f70fdc1965f34b6cc3140af46f22543ffc135499b31f7382f2ab2fc21812be0a0e46553ef00353b52640fd9215737ea9886675582457e0969a0da64f2557bbb690653d777bab4ede8691a628f416c769bc0eadac8e23f14775605e5d37c6fdb0462eb99b7534b83b25ecb45d46e480c0ac881f43a7b88dd02d1e16165b6a82925c7d39e05d1a1000b465ec4c5a62610cd9c67e9c35133605ee85e733a9ea9e5d6c4604e72b0a413aeb5dfda976d1808f0f92065cbe25588fa0e03e76dd0716b9bacddeed3718f5fca0e6cd6b0c8a3b2ff7144e528f3b037506c0929d607825b134b5ebfe5e915bf221f2a7d490054b40b9d403f595a9fde35148d3f8ebf680d1752475cb81dcc1d8573cc724d2dfd87f7c3576cc8199314f1f4d3b4928d0fdb1f79f69b2829e51039be36eca9f884b21d033decf8b98ae3356826ad2fd347690986bbc0204376d0c0c25b5d57f90745c937d3a7833135428f2669e5c90e3e000aa8fc6444bde5359b74a861eb27184a269a889c086a07a8ff0103dc8157087d5e39d2c886f6743d1d4719e454b296ae69576fe91eb622448f41cde60b68bbf8da69b612ba9d40553ba82cd415883b8eb595a6c0568402ea951b22490ed9abc0b2c520c78296d5e6e79068afacb241e0ce0589280081ad3e368de9b0ab741a3d0931eb76232c7c688775ad1ea2347fda2115dc0ce0fe16cee982ba8ffe0ca2309693fb1b542c5b129cef04fc0e8a47220259db569a217b8e922ff0b402f8b44ee0e4befdae97a50ead2bd766ea7133ab8695bec4c6dfec601203cf0d55108bf4b5cd27975b5e7cf614dfe256f2f11201a9749e74db246b911f0302b7330c7402186f258d911f802831b4689c300a74cded1fd8301a73057e2d67f67a74c274ac381e60e4af7bbd1ec580a9e4cbec77b99eb616e6330f57b5d2426f1471faaf618cab8c279d61607afe3457520d4c0a5a4040fd4ea383ba2e4105909e60d8a3ff0b59e03d783cfaa6f164eec801c77735f63de9d7318d27e3cabffadf64003a6d7e806270ee070f20a1b4d3af2cceb7a5b4452bb71d4e98a9802155f1ea6e2cd3fb2d1e78f122c8347ac442cfe72d0b0e0b854b70b63a9766ae6bfb2778e46d82636349d510a60efb004ebbde232f914ff57c077eb167f4319770f35da9c6a83036344e0fa8b5b53ee97d0030f24942bc54233bbade70b53e3a65220b69fa19a96870a2cb7bf0cfab9ba0f5c919e977c70e6ea8dc03ab307a6220a383dda62e5d7cdd554a60d8340890395433490b547a2df6cc964598c968679fd5d6a182f9c5030d3edf80e06589a736c2551784d0a4cf181f95826c08ce3fbdf64ba78b46f9bf1b3e926fa3f28e9c7471bb657f5c3e76edbb40ba47cd069661f40b50344d9712e8f674c0df3c317914d6836f805d9a484f582f87b72810115d0002dd2514f68887185dc3d7a77514cadd565a4d1c0e74158e03069771a50d0b4c9aa7d6c466624332692e3b383d7a3bde26c81f3c976a924de9657110f194954ec40a2e48e9886bd2a612e1d155808788cd80430db463ada30bcc52d703d75134a815e1237301d0fe6965de96dfb595d685b1fa1d8f7ec7f5a6d5e0d56b3918d8e9c7e8fbfc1fdf1c693a2c78b065ca1e5a346af59b5bf9db511b5ebcebff43530736e6c3b64c61186c116cd3ef18fa3ffaa5263624a6319a104718b99313d79054ee350560b645162061efa621e9c966f422d61f41576ed32f82e378e82c220506de347dce098b8b35b17272b213ac93f3a984589f164b625eeaacc83ef3fd2670af24cd2b83ee5efa9958897431b21260045505a3341eebf2a4ed996f3addc74d98ab9a0d4abe2e1e5fc4bd593ec1e96e215e530743a23a567a6eaa3d9a5cde0b63600afc44064e8c44e72bc48eb7eac86a884f1cf74e533740c0f020a105763a37750ff63aa80301483af779a9ba1d0f3796e15450c6071f1decb89ea627a9513fa45d95598bae05b745ec5edd65d379fc3bfe0d29fa3210144c5118d0e40bbd4bb6a4ae4de40ab476e0c84d578bb9b4e982001248f0a190c1deed28c2f8fd6d191f4c45ed3560d4d4dd9debf358c0117a8328bf9837f98fa43b72916b7d5c4c7c5ebeb914e8ccccbc3a201de48188e9c36bac77addad6b94a413416824b434cccf2923ed9edafb4a36db9011a90cb189d372e48c34b220a101eb90603ab18d02ffa4032d97649fd0ce63a7e8c5efc733729e5f4eba23483afc3cb419e9a8e8b2fdf67e491f3c4ad7c12a6f1667696807045978c09cef09e513c48c55373e24a7fb7cbba3d01aaff0184d876ffcf3dead98679117e8e90dc16364d992569c828544417bc63fd22dd9fae558c49f828e66b342651c66126c129e5a24fb4cc6f51c7123a04788f7762aa8e77495d682df51494dfdd56f62efa20b2375058adf54a9ef3ded0410624a0c15679c5badbe74e42192e705ebb749ec7bb6923404d2dcde226058414d83eb21d888ddedc49b249f77be95653fcd7ca64a3a4bafaf3aea00b70a43432e01330886952ac6d6bf093a70e7aa3a9900756b6fbc8bd6a9163496e955e4702cb347d2c6f9084cad13249be85ca7718de0b7a733222e1a24c5777006db87a9033d14a2a19c2388b4dbdfcfe0b418cf6c6b48bc6b577a056f0087c16976f531cfc5879c440f0f68e415426bac2a1b9d9df826562305dc4f2faa7f20b6ea821deef51946b0bc7749d236bb7bc0a3bfc5461450843e807fe51a64d448d85de179980bae0c5eee952e8d2c7222e7bfaea33bc17931152e100b034f38b4fb33e743410e0dfc9af8cee7e21d670ed91deac00591ff8b54fc7ba4e09c5b138355670d7d7e22fb01ece051fb5bfa529a1142da83ff06264cbd4ab5edf09357c01c4969f4ec5de932ea53d9290a593d67d4eb09e5bf59fdf580d929751da3cfb581564518a2bc92160b03084bc92b741c932b4dd2eeb1fb428c9da29b4d447c29313a379424aab4cb22edb6087df6aa5bd59961a158b2e648c57fb88fb571c604c303db45b35482b262dcd7af09ee8d30d4ea2aeedcbbb7c38f5b2a44f0130ec1c017612e5cc412af55b6562ad30029a2c4b882cc2ee33735891042d8e5d07a28e9d3f8c7de9f11e118e19840b927991a64b6b77a40bc259eb24ccdf4cf9d8b82ba0120596089244267953be2b8ae5b51a0a5d15969d1ea0a5748d6821ccefc5f06acb79bbaab2e5bd82489c17e78abd7764322870ab44d92ca1394987848d968a31f82ec82d3e6f605eff46b034aa796d0c6f7cb15e152eb4faab0da7016d91b85814a8e3039a38c73f071265fe0db94c453a249cb0bbda9451736e95d35cf2646d19feac6dc977175ba1bf5dfcfd48f38bdcb082d70a551eb0cfc42ec24470b34a1151fc5cfdd499e4a7f798a4baacc1fd670a20bcac63b9077302e46241030420e77d55821d7bc0fdca0b2cba475f26f890caf14881e3e8100b897d125dfa9a6fd2f7a46165e317f0f21b95a501023eaa6bdc38310241422ea96b7db8208a83c0561374498f97db0e508b172b609f7e30a3e92819abd5adf3e0174de6019ed50acfa05cb77a7be3f84516a8f31d52f4cf0367cdea119a6ae976118b0ace16a45cf1c3d377433d64916ae39c616c5e6818f3f566ebe8fbf09d4e98128c10be357274f275c88bd16b7243cf917ab66b55838154c63ba41a92364d99f90b6c89bc5f7f420f5028edb5e4b268901a83324d3533b0740d76c980f01afee696d199375fd520357d831907dfd615902e32c9af993185037cfbe377d37e74f406d924d4aa55bf8a3ebfdc72440ebe6e71b93a5022e5d3b569a0b6264318e30c799601ff09edb8be1099445c1b7004462072a4b59b6391ac1a90d1beafbae43500653cb5ce178f98cc9b83f76c444398de9f46fdf516343c45f0537dd240115a6058bb6aa0b36b13681efe24ad09fea45795d37334695c60d2d2ffdda014aecee5aa4a349a87ee465fd0d08fcda58bf844554a466ca69bd5e673958794f3e28df156dedc81ef881d359173fb3ed7164f1f56b69d7627107b09f75a3cdf5bc27dc58d168711ac4bc3898d76817604e0a6fdf1a65c53e862853c58fcaf7acce181babef05a9417382e81450a915c13911cb0212fdc1c4176dd97454c4a0c9c2001e82efcb19c581f0260bc30647b34dfbbd615ca1388de5634a65cdd27b2a4e4c074ed2df45c1d517577d0745f3338d9a81a0faf54c46ee70d10f3077f4bc635c452e6fbd24ba5ebdef9d311912c24ab05499aabe0f8cfd84e905b27e5dac5071c1e83056328e7cfab88a1f4af03fb412d884f64adb538411b40956278aa44d6240a50d2553e46a5a71bc6ef747de935ebfdc114d13896b72fff391ae3b23e0fce0b9c50b6ae1cc46c46676a47866ee60f83895df6e749e4c9952f6950ab3f4b7fa069dd664f6894f7c9bccd14fede62b1b19a4ed36be6ad41d18d1f741815b36ac3fa64f1e2dbba07f389ad650dfdbc9e8de08205063452db4a7e3fbc9e1ea64d073dc6261222d56f7620bb11e2c976b0b4bfb42b112f02e7586d888fbe16af6d179896a5f18c09deff5921c9a4dbdfd253ba6c75f8df7889f5c9d2673e1f2d9d72d11f31b7ed8aaa0ea542f99a70b21ea5630562c12c513db9cd01b9fd34e687a3128ebca02c409fd4276a72c2d0762e761f13f04ae72d3fc5868489cd206295c09ddbde4e62566d72fad282df25e20fd9c1c5556c50a83625f00ced4bf7e3c4fa9e57a9da5cf7fc302045f3d1b5970c9432ead0613fa1a0ca4de85e78a60f86a833622aea9ec6b231f25db1089568ed6fcd67a70d9e4bf5bcbb933a678221137445297ada3b6fd0c7fbe276764e249438c13a909c88998a6e1e3c834f7e63aa991640edf99745f75dccb55f50d2d3eca58bca9f917c0caf6b70677241f873da8d0d4154a720dace1073fca42b4d5e2395df2c257e1dd1ef858aa01e95fea82eaa8ed1ee4e813e0492513b6ca2945b8a43cb7174b4991edaf26dd9c020faafafbbfe37b340c174051c13c8db3ab6d1cef63d77ccb2346ec0e7dc64ff8ae841c986ae145767aafbd503cbf2c930c900e0eb80df57997cffa7aa55b3ef1abe0b07ca202bbb5d081f3963ece40f30d0c290d38e2051cfd909cdec37b9531029663d9a462ac518674dad4c5d044a87fbb2e16a522f482c1efde8590b979fa5cb6f2763ac64b8593a78c01c79b7e4f1d4f15ad53861b589cc86e48c7ddcff82b121984d412deb901ed988c1f84906e90154803aa3d69bd764192e794c6cf6e0994abefc3dcb496694adaf1cbf03fb203bc1fae7b9e2ab226c53e4f5f80d89d6f0d6aabca67d5596f8e2f07a9a43dded3520d226ec0fdf5ccbb6a1c06630e0937aaa8d4678c89b3fc06cf4357a5ec8f25d2e57ab0cf80ca4fad60b3414ef022232d8841cbeb3dc613f5af56369f8241a93160a0ad4ca100a4146dceb33cc49e99c49e021097d742c37b0c9c6186ea460312e377440d7f2c0dd574c408fcdf542d663a84ea1ad8cca1aa92a45dafa52fb591a5bd534233ada849662136daf8eb6d6cbf14d4b743765979c3df2f99060b3dd62b562ca4e4a28c1cf595f7df6844ba99c5cfe9e7bbbf229388b691d9abd9f021e61123926b33a2dd7fcc9c94beefc4d51ecf78d4e74e376b6c1fcad40301ed52f340c2d53016005ebf85c2bd5c74fdd2a31a55480bbc787a539c2fcb43b0617778bb42d26190c6e6a4081214fe69079a2dcd9409fa4038f159c6a1e0271cfb79a7f81a8670806e5acc426a283db12793b59d02f9a0d4e8ca755060f6dca576a0dda6ab8ae243e256c4b936fbc4b8994697930706f4f1cf985ffddaa0719fb2d54c2c757387743e17e8a1b2ae6a64e9fb49852892730eb057ad6e3112c94af82cbcf9398ee60aa4d21db4133630147d9686874a5338c73bc05b478222fb47f8ae179b2f6c416b23474fbc8e079008ece2ad491fa02453c073dab2c4d7d5ee4f20ae6ffc973d921265e3c2ee94300ce59d8f1df41af4c8cf4b42d20825d6629dbf29e376123638aace0481a5ef8130410e9f14c0f38c994968ee367480a58b2cf9670b31323376306b7a89c8ff399b386d1652bf024b41d0b427c52a0c1a13f93551b26a41b6c8750ae61783fd9d2021ec0e8385355bf87c06e1968a5f43e7a3b8043f449a2572f59cd2f687b26486d75f7661647bfd2da104e125cedcfb61f4d7d59e16d59f3bcd2ef3bc144f46859f2260cf2b6943c3d74a4e83a48ed377c3e108c2df097c904521384767358d588fcae33325e443cbb3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"dbba0100f462705d414068b345035e5a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
