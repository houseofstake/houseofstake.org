<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a0b4c03bd709fe531c4b643e1c025cb3ee1063155d9c3daa7c5d73cbdd1cd11368bb577a1a6264439267e252284ef85a7c3fa2490530c569698d19acfa09a9670bd4c811959df1b814690dec2493a48fc6c3caf4b0b454abd3775bb97b052fedc7a0f86684fd895a835ce1ea901947d897088f90aed5b82903262d5588f9ed5148124e2e01f7f3b7136f4f7139026b4b28f5baf2d40af8b9e6e7726ef78d9b3df2ee6b30ba66af470499dff24a845356201d48a2a409c279d815ef884e1ea2c9527246b185b5ec0cfaeb650e41ae8bf0024a12cadf5e3c8ab2a816e1e6b50f69cee781224f1c74963f86838dc6a1338182797b789836cee15abb315ad78e69076700299edfe643f5bca8067cf79c1fffa88ed34f13f3d40f979851c7ac027824094ef8e071fcd2b851a8bc84112efab7ae69396f36ccfbc3f2c5f6b5ec2ae828ef5f4883a30ad8c6d326a5b6611d0dc555632d18ab360be33aa3840cbf22a0263f9a1689386b692218f9bb52a5fc60e8053aa31a5efcca68f39ff40cc8ae5885030167d8236bf09f4383daa4d96904e31a19247dcf6b0bf6d1dec5c7a6a4e65e0a745061a6658600be4cf981929f6a943ec6c837ff92305f23ca1cd29cb1bf7b35802d16fcf8d06f7c1de94908566ebbdc44347a5d8ce61371c384c4dafbcc0ccb9f3a187810fc883a622716819c0c9f6aa9dffd49efed8401689acbff0b6d22fbb96b05d10cac4e4da7ac4831b2a9f994b390ddc0893d15d655b13b38fb9d402ccdf3320ff40baae0a833f60fb5a487274b605dec96893904f24c9c77ebea1b659a1f29d4cbec2b0b33b6c485a14db5da645e466dc9c4485ccc2978c8d25349cef592bace4c66466a5ef07fea1d1faa5c4c495905f2041e2ee79e434c522c9ff3b11c910ecbcabeea1d6383c7045573cac6d8505ce9c3902cf3e137c5f0587c5bb4bf23ae2acc38bbcd3895b688809e30c5163f7bb72f9c12dbaad8043e34dedffbc8d52f5e74d216b556757ef7361e4b6598b603738bcc828bb69b54ef06650f571245f740d8cc0d125b4a12cd1fa03982a8dc37086a61c14e4900a01084dbe2076d6e7c5961c7c767b9408a063fda895efebbf3602456525bf26352b74a3510e1211f2e1b1e0e431a9445a149b390950e60180d607dc2bf6cca64fd239f84b47b1bb4c2e4c9ea8c1f47f6706508ed33113550bc5b484cf3aad5dcfb42cf2287912b090d6ab8bbd5e4365ccb5ff3368ff20b1f2fadfb5a01f7fb88bc98b7692b15299bc47f777fcb32fee741912a952e810edee2d753408d1b4653db4c3134e6a15678ddc8a2df496d6e58c778877b6ff73aa546d8a70f7ae4cb687dac98fef7dceef0b2264ec72b48008075dc419fc889114bbd092e4efde20d464bf4ca82382c3e5776695ed6c91f11cc3362677755fd597bb849ea37013f3bff17c0123d803a8ab9d3c4babca33cbe2475a46625a4b682af3dfd95c43957e98927a9715df2dfcec66b9bb449e8a36177f455285fdf678aaa57cbd930b84bd74a7047990fc953672e9b66de88c6c509168d9fd7e4d6cbb077dccd4e94b4b1def79a30f6711318acdd0d68aeee700020eab29055a574f81e8309ba3ba5eb10c59f71758772fa4f5db4fb96741202b5c0392eeeaea0258bca765b886e034d49959938e4b1c561c4794eff22df7f1421fa1ca3f90f01c52f14b0326c87cd486009b64076b2462f5c534183d108006d019aaed63c93e24b7c46db815c37e519979a0bc7fc64511736c885c54cce9d9f088d6cf1fedb07f7c66fe1e215a08d3080ef326d74dba6956cfe4132c2136e451171e0e3d25ff6d94f1e66b38abd25a887a407ce79eeec5714ca817b9b7f0c91ba7fa054ec7a36c790e679fd09e0d9ca52e49fe0b38d5ae505ff022bcd0e52e402dacc12438c259fcefbe19ea72edc154701b9fe6fe79cf94fae86598340db75fd4f76618599d8f32d23e703e7a9c21e41de0a8b2314241126cc3e7c808bd3f5e41aa28f839f8cc64866e871f7c349273308d5be830b0d3dd9215188b870ac2702feacfeb6881c5f2a34e0c4f587b5dc019d6bc9bca3ad3fcc6e053bc49cc72d9bfacc886b557521883956e7780d25a364535a221da3af57afba764afe7d2fbd31f647763c219b122d11fa55af5d09884421e07ffd23600ef7f5bf717b37bc1ce4a600c4b406fb56abbbddaa472ba3b0b920661dfa4cbd2fb0869a0b24a0abd20c6902d71caad9d19055f6955f6b71ba607013d62e629142c8b3608265a805c42674f87de1e5eb86df45aa800a9b9d3bbc7cd8711cc83a9d240af6161342b95e699b93b76e614431a66f69c8bf00fec13f108143ffef9d1f4e9d62c064498425ba10f4a9e06ec61bd10798895aada2dbcf385349c34575ec6fdac7bc50edd29f4ddc1a38c0dc5d2238a2ec2140806808480dd2797bcaeebd75f21749e4d7dff98a8adf8781e76abbafb9456b257ef005e89b4e11117672775afb9a84e092bf4455659a3a3091b2726a98e9cfe5d4203acbb1cd6869c13c3cd683bd98fada9979ffb73219da3a919315234d35bc078199c2ee603adc1f4577f4abe8305b21646311ca1c67a8331cdf3dccf7f0f5de05fbaa28eca9a868407008535ca3773ec34c2f5de8a40ba8211ebe7c8378f0e2e29954e6e93247f4ea6848dfffdac0ae5cfe78d3b29695d0434958017fbb952f01b0bdb276881b178c01c7d670979603ca57553622bbafa158e84e301d893beee7891fa526689256f192a8c0afa5febac10a4acea4d6ee7a6148bf4863eca3a031d5f1c2fed344afff1411e997bcbee65df54b95ae99a3000d2d36ab84142ec6c1ca5f42dd786dc83d6ff2c8089828f7aa1e8f7fcfb26475b96c26bb71665280788830264a7f246127592fceda3677b37a5e8544c37c5ece4c9a3ea54a71b2c04cf0e04e66f7e75637fb480a072aa415d9478e3b5097fe6e998f47f4c341ef38b3178b058fbe67c7e0a1fc4a773be69dc79628482c1097c19179ea5032fe19677fb37e6f71f17f8d0d1bfdaa5142422031b61ee0a4c78b8dceafca4577949255f848fcc05a187945960d0a626408afcc447e328cd0cd8c3b95a73a716dfdaa625a8e5f80c03174f9af49398ef73ef782f672436d3efae2e3ad509c3f4abe0eb03f034571b39ee4d79b0945a46091c3c1f35ff547d41b7cfa8a99d809e2a2f59c45b520f1ab76ff6d5df87aa466e6efa03154fbc1e57de64f8eae6ffc8c1f691aab8a98315ef391abe847c7200288a4a5959faead93b7f3db97d486ab4ba865261cabd186484ceab297b2d21243ca5bd6c7c4b580b01d20008ecb0930378330f9fef90ebe73cfaa44d9c7097e0f61b12bbd89eba4c47ae4ae21f826488bb0db83f0cc7126a2a9cc65a530e370ebcf7ce767d3adb9d3ab5fdbeed3283291d3b5124db5d983ace9fadd65ae6fd46f229e4a474a5eeaa06cb5a8c40a282c44a117caff6d6b56f6a040b4c898aa1aaef0ea4edbfd2f2e7f7d4fd3dab8944bc19714b377858d3da45532abc4f3030ceddaee1f34f3ec5e8d8d924053442287301f38415a14ecceec5750e92d9ce934088cda1ddfb8db3bcd1939fdd984b44c5642de0aea3b3daf2723a0202050bc25d824a5195ca8ff4d922d032f26d3f864c704d539b2a8245fcd2b0963070a0a4cf2863c26946dcc35af27af655b3d403060af1839279a0dc89312e8836e181724d2ba05da736426c45d18200cfc6666f5161441991f0b55d93e98b6563b0834386cbdd5f1096731d68ba582dde09da05ddfab2f9b36f418a48ae236993297e72bb47900bb7239c3cb91282cdbe3c90d052fdd9736f42993949e1a7ef3db1239217445800250245790b1abd534f9a82496aa53aec1d3ad364f479968a7290e9e51792873ebe06718630ee125cf9b5315655c94d00e5faa0db11023168dc3d0446b3555d2cbc65f78bbb09a4bacbc8a9172457c0c4e274992fa0b763a2d1d3e3dd9025e739861da85e8c4c7c47571b2e100041411d6ad599c2fc1bd2efbfa8b39ba81b86e2a9d95578d7fd1442aa2e4806a0f8713ff483cf20ada35c8aa596fac654534a77f5cac58b24446fc1af57b4bdc7eae488f8bbb2894ee174af18e4c88c19319bcdfee208effa5b4e55218ad0c5f948cc64348233b0f4da0b4804d89b2af3234033008cc541c6894742bf35d959c4c0148adfb0c34bb466362f64fa133872bcbd7a1587d0440d05dfe36075966b19f9aee9c9f14493f97420141293aa9bf8e31f864e2eb0ca722b7a75636ca3daf3da14abbd5a1b13a23914991e30b1eeb8a805a0bc8e1388011fb216c608d1eecc8534c51db114c6a85e0f3bc16d860342d64f3910666bd89b63c4e58b0110d4c4e6367653d8536c28a57eb26a3b4267819ea5a907e1a43e95ff7d3491f23e1ee257e9d0c0fa72520c3e365135dea74467968433122cbaf95e60c976df0109b4e0fb8b06ec91e981747d1d33c676113acce912c622f55cf823d5bd18c400e31d8902f2c0fcfaaa208c3cbb561d5929312894f1fcabdc69d9f4cc5db35a09e7ef6393aab5318da8998279654e8c893b2ae8ce49d16675219d7105e9eb4274c384c42649e669f568fa24eb41edc1955578c6be355292a40ec0a5305d4b07038fd2f0727ba1ab9be3414acef262b7ec40ef5a13faa9a6303a5e62d5392cf87d39d5a4d82f991450d3351282bd60001d51294fc509f5585a54601542287082f0db2e531e9cc746065c5b8b3e2ad00703cae2041131600a3787b9816c9c75006958acfc20acf140d6134304debb81d4ef39c02368bcbe272225a449f1117ac993c9f86c032553d0a7bf3a5ddbab39ca3ab70605d82aa5307650fb71495b2b9f1bc2c0972caed20f90c8a663c6bc1ca522ca3e6ac14c29956956733cb9963772dfa0eb68e83c396aa3fcf723873989d2b502c1eb439cd7fac090dd56a17ac2b9a20c30331a37c1abbc90024052bb1ba6a4b328d0b8a7800ec9b82855af47e22e0423cfb888ba2a6e5d8b5d8e8d5a96a3bb71a933c451bf76cdcdce1d81dd6f0b0810ce996015331b439874ae233ea5853a0b206ce4e960529eb8081c37a0ce569fe43a5b40f3ddfc177ebda8a4669e753d9cae7804600a48e8752384db9ba9c2601c1be4b24da464585d3a240a05a5edb61903863a22b195b90f4263bf2ece091c04c3b840ac32aa4ab9752293d54868333c65c4ff10eef7b49c95d3eab4b13b35153be0dc305167f3107d9d6371993da63450cc6698b4e540c7b9c26c46ec3d1e71982a57a82cd7e114fa9db2c82b201cd155c78e2a4710f56716b44571cdbafc2c27da2f30de4188f55f7d087d1db41da72bfecc270fc4fed221f8a18633647e5a86a059b12a3afef7dd95cadc0497900f00ea275c8f20c5fd787630fa258b6d7f3495376a3790b268d79ba46dda5f425aafd377b8937d41a103845ee90ae4cceacaf5f76a217409516b0042c2ccd2ddfc5e3a5e6e93a8d7f29c33a34f0aa344945ce8321a7c784b0672c221b0864efe11a0f407edbc8f52f2ea172c4767096d794beda35e865d05f4f3413a72f8fa5c10047a48dddc3a32c93dd617432ec316835ac82d3faf32bbc418824dc503ef908002024143985b48539469ac29ae81a7f1df751487913011c10836eda5529ef0d9b3aac51bb1165772884d9da3afad7b6b7c30a667749fc8ca5a2fdc7cee16b05b678c2a0b30f1b19cf6fd06a4fc747b81cfd160d2e60d1f636c6e79a02722f4de77e608b56b02c5e03b110fcea57e72728ac9b85dca2b4381693807d680534706bbd3d17b2a9436ddd22a53e09638b503538ea226ecc7aeeeef6e3e3659e6044600e2da2105f2d555c6910c0784e3286c21fa0466275c3144a3e0345b5beb90a06ba14c56d761af96ef41f806e91735a04147e6a030cda650253e7071a6573f7211e60122f07e3366a30b476d7eeb29e9e6f1762620cb9d8bf470bee9e780fa54ca42d07c66200aa07ef8c4ff424d02deccfd3f1c651e9a374916cc8db4b761031975bd62db57adffbe5a429d2f92da1f4d804e46dad29fe6dc941d1d148d1210118fd348627d436622010c1b3d5a923a2886a5e57cedb9ef613c93d1ddd5c46af30f17aeaa4c6b35e0401b01c4b0d6f191249b46f639e35834be1946037b72a7ad4249e6a1adac085ebba41584013b63974b7c01e79903ea92857e49b7ac92e44dfba00e0c81f1505a9fb70b3bb030f3fc96e7818289b834d9f90ea9d80b6c845971ebf0017c2f025d88bec84d8cbb1265dff05fc5a9fe2ca17bb5267e6d0268f7a03f9d35ef6b2202ae6616453d5dc64ee475eb4a93b039203701bdb85852b97750e6dcbc6a54f54ab00f713a8434d8ed478de2e74c95ea7bc0b15b7ae11c8c4b8ac68f044e3d213fd5b752a3b0f2602a98c451ecf7ece968b6c891726f456aa1100e9d33242683e1b6691f8e227d22f39037c303a79b1d1c07be8114ad7069a5d8f2bbac92948b556de9226cc2cd7589a917dbbc375d3223107433335ab19951a29e88f226dd47115cfb5cb786b38027db7618bf12b3397ee7090a82db89830d5b59d80db23cb0cfe5f3a7f5bbea0b1aad6fb572cb878d7b840ca0f09c2fbeeecff128738c370800de81e1a5c2b6e8d29ebbfe1348ff8aefd1eebc6076dd4332afb4be868bbbc789049d7c7722c652c3e298832878c48eb0b78a7ebe3a39afe95076cb1819aadc4ce6f2faf24501dc612a2c89e9609a30f59a465f65371042c1a8f33b5cb3d55500acd76dd9cbc1aa1ffab8ec8017437213e736488723b7fe8285203fe8268e0464b966671c07e56e7e006ef6fff69ea307bde9c68152480f9e1c6c7820878f5589eac3195839f3283e21dbc8ba8c2cbf3e29db954ca9122d84625b511762563f0900d3f6d0b11435b8ccd2ec488df5a0f0bcf60b7894c03102e5442fc7b06275693e512e1341df2cc379107bf8900d2d31740a323a7c6815f56a0e32df83c18b026507b36516fa75c5da9f7fd5a544067a28b320f19e6104cfdf9bc3eead3cad5ead3e1be07605f624e3b968386e7c06e0d02b0611a92730124ea116983d2120626383793de5180e6fa7beaf90fe46fdd086bf184de89a852b0d4f4d5e9a922266e2e00f88803b13b009fd086ef1ee23f88748e081d38856fd48236cce4bead8e57561330d060cc75e9737553a3a78c2e7f528ec84b1af6ba3e5c2d9d38398a9fae70157cd239ebfaca6684dbc8bfd59e07266c211eeeced75425beca6f439e5b6dc5006dac00106356f22eb0fac9bdc25d6fac9a885e0305ecdd2d0b65c16071a92eaa29d2d85877b55595e2ddbc5b2b24f157608cc1ea381808140ba93a63f3d6e1d3e8055c74069cd35a25549a1291d80a116b9a8ee5ef7ef16d94ab2c03e6e6bc7690cd768069b632f8083804a11a24003caea9ff5f793d97e59125549dcc9fb0c68d249c4bf42f1df19645d19172183904248cf3d4adc25db16811839f4df424389e25b50e3954d0b6b9778165a57317d9e87b3e07c926b374d02943b3fed8d5f407e485e590d23a3b79ea24ae242cde0b84784a2eecbdfd6b752574c878aac2e02ae4a9aa8fd40c8c8a8132dce728029abe273c65ab54338daf23b0e7cf71f4968ed9a3a950f1d6dd0bc69cb008f98cf52f714725bada69aa054ab6a6fab83e533dfa1cc2a102a6b4cbc7dc21d89346964536e453fee872a12b7ad6466df313905eab8e6b64f8c4ef12a030f643684ed3b267e81c0c383a5275e19c817a0dcca106517f743e871c7bf9d219f61d965c34a9ae9ca50e312a0cf64a5b1c67e5290fc9c82931c39260a5e2226c2c2a98bad1b761e93cbc26224fede1aa664cce3947b42be53cc382486a729aef6abce901e18634e338dc4b3f3e2f6c2c90d9ce9c3ea7576812cd21cf1796ecc1e0ce16b30f4163c92f490be02ab08cd662d60bc709d4a4fcbcfc9746e1d748e60db6927695171254d85ea50dc998a48daae20b530218f64bb8e83db346868aafc7ec2edfd4e666749b2094a8158e736dcfb2469e31a81bdbb66c98f527ffbd739a03464ef20ab3e045027b17c620a340c131e2f9819fd0f1366060aef9954eb2c134a2d2fd758ea2854f974c52935420a1396d2120c66e8952e055706f78c6cb41444b3a518e926b106c93c206a1142084a9534ebb4a3fdce44575e891d1f9c6fff655ec782577a60cae04e10abf968e28288c50042eb01a75fe5016df6979771cd64ecdf9ac8e35a61f1a77527fcab45db70e867a21af940c98ed2b23be6ed2dd6961a5e486ff137f5037a015a8cfb1d369dbec2580694d4dc24b3e0d45ef9bba8f211481bddfcd824854c7fc80e3bee661eb4d5163e867216c298b4b590fd5bfbe6e0d65c270c814df48e907bf2b4960cdc0b0f492ed1c77c4d4675a11792cc548d8c083fc750ca132c092c101afb6c83c8239af74452e5f2ff995f9bf19932dae97f3a1167493e4709651957537041ee4da115696c12939d99a69288399dfb411aa6bc587b02f7f1ca1f719a86dc9bcf76fe1b918687f7a91af150fa98c2235e006fadd405b2d539c0ccaa0d9b07107a7362c08bbaedaff31db7355a780e61710ba6a4bb13261a1f0e42eb952efb6fcd228998631ca0a57fde17368d6b7f668d653e7410612251737bdf56901260760e28417992dc91c46ab3097bf74966d9cdf728fef4a2383b80b1962e17dc96a1c6907d413cda6a82d3378fdc6e3d425f897640f3a4ce5432d97aa211753ceeaf346f5511184e8f1222301fc5bc728c8d633ff51f7a94e2950f0d0d1c595277b849961dddb3fb0ee06b066e93b3df835b62362498d8da189f5c6013a9e990ddb53bf7c00642fc7ee64428e0c205b9336143ef7af1c4c8c4b659fc073845e5451236bdf3e66c1a687cc873de8eef851b363f5195666aef45eb3f2465ea365453dc085ee04dc46b431ae4e3459ff8be9d8de6c911e9fb22417a47657652cb9ef522ffb55b215156a792e00290ab1bde73801f94f95dd5440baa8ad13c96ef60e8a74af57c064968e56a48710e9d2a20f9506238fa1b0d00d1c28939ab5543e477c96c34119e2c8525b3a1d55b4af06151861951acac36e47a327f1dcdc34c47c8c009c74b9095af97c389ac3dc59f8e0b0ea4961274fd75a1b747429a14796ff6aa94f324725665e4c17987532f191a576219f0cb84eab60e7f490f942af577b406187354de10eca737462effa70e03680854d51ddeaf7fae5eef071e601c9bd8d8edc2d6ddd5fbad30be58ac0bd247d211e2136de4f199869ab53149e60c2c446f3a3201516718e8798dc5d609264f539ee6cf86d2bb02da2efa9dfd045e5447d01ff8be6820c8c1a85838d337bb6acfc0dd8f8712fc4ec45453f492a2520352573b1c117b66895574ac4c37dc2d43d253b7f58cbe2ec817bbb75d87df42a0ecb543b80bd00e87f3a34850ec9fe3ef34677211258540ade5f0c579ecbb1daddd1672b70c1e53b83c1f73858bc08689a9dff52a301cdb344d7a5e848fe92e31767d444b1fb3005d805ab6b7d04d254a144d84f6e21fa9608ed4dda702bc9073389c39040f694f0f03daa36e2baea3614c7ca12daa13200912ae5eb1ed5d23a21653863e589a6ee5618925831239b22ba2d88d828e44c10f15b118cd6ca97ce8fe62aa93cebefb3e876b6248c570fd7a7f95c5710d203a8853717aeb844fdbb282c81fb102a4b7f735322700fc9ceea901b50f409add1f95de0296374ee89df277d338cac659f6d024a7b13d9817fc33d3dd55d0a7d1675f62f4a7844ed0a883ac5895ed080479617bd62a1205bb25ebb2c4175f62d172271b65585bdb53bb00da74e150be009bf7173fac79b12de4781fef734bf2300f6bee26ff5b67255edb008bcd987ee5ac89da200423d69186178f623f811cc57cffbc228954879f2f83b97217a46de8de6a7503afd59739333d53a372dc901cbc313c90790b46b0e7bf7a1c515e3ff22eb8480b99a74b1c66abfe9421e2d1a5607e6bc76543faf515f55cff913df3ef9763502571aef537863070585281c18d13831fab2233c161b92783efa780de9990cda8569f39504843e9857c65a41d7bcba17e4627aa696644c5a325092cfc54d527d3d87ddd975e78fbfc1cb5da656311ce8f38c8c58fdf8ab0abd535485b618864367ff88424e69680b7c114fe9495d0614ff036f532741494077afb397a499eebdef94828db891bed2265eb0e7f9e7ac11214774995acb30a6699b7c39ce17ca2e116d93a289c4300f8e480ea4aff458f79401607f2ba6e7720d8fd5cf0ddaac86b0c0aba45acc10328d60b43afefe1985ae6a25526a93a12391e80a2dd269db34bf3611f1aa5d29a53b42f65b1c3a7d6691085741f268112b99e3a431f643f589009673df136f51f0e36f0cfe10321da5f902b19e1253ddb55719c9fcdf76889e27caf5bcd322c9f523d13d7c3b1b01b24fb93cb667022e350f7cf6f1117946d233e6c8936e065f12cc243e6041b68155680b99ec28dd7d41c44ceb76f4cf4529be6410181a9ebdc654cb80fa969e5e4076abf99d63f17d8f7e3899663ee02aace8333044d663b388df6f08b717242d3e77f6c62c2c7477e00774a5ff0bcda85f7949945f19f3f038c4cb7cc2e8e05e0dbe90486096eefd64129a861b8f39ca692b0bf4debb44f288b670ac6fbd33f45ebc967f0af825d9ba8f3225acd06f679a376f5b0b7ae43b8092614735e26eecc63505ecd236207518fbdb6e218526fed5dece2d6d4e82c22784a4098f92391cf2ad0b66f6197456ce6b462efc2f12aad264d7d8339e7f4a0b25a1101901e89ec90f078eabf9ba26d5b88ce528048ffdd6e9c246efff3c37c5e1464680d5d313f6990b2b1d8cf4dce8cd2a4aefff29aa1174aaf29e3c71410b25d57c1acafa12272631cdbdedb64f681e9b253aadd1a833296eadc101581e48c52553ed1ea03f90c9d102f3e8529073da6dbcf4e04c2fab32d1bbe85d586581b975c3e92dd76bcbd8b1ce0d5d390e06f88eff33e17c3fae0ec13d75a53eaeaa2bbeee88302f0cac9ce486e7331e2dc1785d036dd257f80e1c62a411643411721c01dacd9f5dd5e91152c9a606d6cf5221dc1892759fa9af976e61bb16b21d169a8420b8eb26e88dba7356938465eba82bdb81ab0706d8f9d5d9f73af845b675eeb0a1af3b785bcbb0aca8a7e62f0f4108f34f8fbfebe4b9d5ffda5666268abc3f5de111964ed75c51ffab240a0b96a1f8354d00e7309165367ae3b9b26037cb8ecdb25639ee33eb586400a6cfb644452edf89fdbfc2c7c487543109c1aa800e48172c0bc53a4740b785f52558cb9bacb5c67d5accacfd7811c95d3280d410eada593f49e105b82610227d525ea386b296668096877b98c5cfaf6a914792a2949b674a21553c88af79abd928b3c1bfc0995e7af3234fabe4a23a933ab63a1cbb3f0d8bed2c5b58ce44c54af6ae7522183e9fa20b977adb1abcc4b44c7fc756fd92277ecbed5255d7a1ced4ff1b3721d59f5dc3b6c12d12e2a3ada16afa832ec494a6eca7d4efc4f33e0b68d59ffbd3d503dff36a26801aac5bacfd762f770105cc6914f993448f3ee60a19b167024354bb8b82963a7d086bbdd86e91b17438a5fca8e81cf0219ffd680676370838a47aef39a0a194e7ae88d4373674dfa520583cda7cd8c1b4d31d729239c5c3487f2a04f4a4567db0140ddf45da8407cf819418e3021a445e9213b6feda2f906f14615d41b59791664fccc39e2f08a6b7c461299cfc5e72fa0bb8b9d617f768861c9add3cebe1c5b2f26369da12811cd6c1fbf7d0e5cdb5351f2e027e46bab3d9a0c2e4a1c6daf4dcafb7d2743e3462489330246a89fb4cc47d0a71743aad84d2279a808c8016becc5b352784fb82058f6f40a357111b274b2000e08c1b051cd734c9cffad767767756a911d01bbee704593f300fd414ca7486c88c8b4eb1eb0da6026c9af3274baabc52a64949e39d3f7a5897382d18094602b8e4665f94fb86e16b354a7d4c1387099c35da6d3d476138c0cd3e8f3ff5ea703358b1fb33dd3026ccd4ac14576019c6cb132f5c455a1f0545a7c29822395b46c51d9d9bdcd5ec185b9e3a545aaa043af0434027653d326a51b49e46c08e7961360c75c753d33880e2153695c008376026ed76ca688d548d46d32bf49bfec33f55a15c818975c66e2d08174f5090e1a3b0ec07da54716602fc3b560c7c5bfc7d2ec5e5087d299ae29da9d70dec0fef82098c47d178e6fd165eb82c5aee053f9b7454bcbe0e35e2c42539d8eef2180b5386dd742842145127231a8b611c08c4c8af025f346f3342df9e760bbb01b42011760b1aa4553eb692c02f5e610013b4b11c40fdbe98e6f7ad60f67dabce31970d23e4741e43b8ccb6d6597f9aa7dc032203c61f9f37c72c9fd7a9e5ddf095bf2f2ddad806d3f89798991a11de33a7d21a43f37bd60e7a88618307f2a4ee7b5dd27ca893124097983c6a323ec3de1cf592354f141c391a614bf94154c766ced49876bf9ffa39d3fa6a8cf75c5b5b3134b1ac29392b504e7e71822d368a6b8fbeb827ff8fc91a77fcbeb31f673b670956b375869e33b2b1b6f11707eec7dce3ee3152128712318f646b3a3bdb0665b85563e165ed22096cf6b67ef42f5f947d6a798c76dc62c6befc07676e7d440a8d78b547bb8ff564a61dfce703033a6c4168cafc669f1a4f75d8a989f90e80c80fd85f5883480d9e4107228de5c807535c0ec159cca64483890ed22e68a187a2e8c7aa06573313631f2ee03fcbd018793c926cafe7b32e8d413184b36cf21dd04c30fc23e77267bd2d6ee8e97bda479cf227e70cea937a55619fff6d515bac8265bf07039b38eabc47b3c89b114362266fcc60b80ed727b0de29d0d7bbc230bdf0f16f4d378e594d7faff0e2eccf6cfc97effa6c553179ae59c354a20104bb361391909f830bd957eec12fb80d5af31fbcf283853041a531dc29ce6c434e5ce4826d70decbce179f6f666357656ed5e05342351a9378afd70fb453c8c7fa41f56224610238d5a1896f53f4aad5c72956393357d13ed98d190967968d45f807717586ff42750f13d7953c17d5a229488637dc15c3f9baba10d95eaa3d1316bff97733699f970c080010eecd84144497675656aaf5694a570921be8685bcabf49f6c53c49ae519cb0e13a6e15d25a05df963390e2a259f1d25afedc8faa90b8b9dd538125d443bcab9a0412a0ee50566209d99cb4f3a3aaa2383442cfd768d9de77d9ee4a91697be0313a77b99ac013f8176ecb56f1c4d2e6408383339b4cd05461d1b483f856ff378ce7fd88d14b728d7b747657e19c7dee3fc1a46fc9eadc0a2056d955e695b8528ec9505af0a9008a22a1880894189cf1d40414c1e99fb7a8a60d40b23ae75d635ee8d16d27a9cf35ba71235828f18030ab47dd07d75791c6870f095012347bc8661a6a117bfd51c9ff54e30b98dee851a8857b1f9bd4eb85daf0e86b8c5bed2febeb516c99bd31fe2acc2f9a8a3223f5c318e583a3093dada48bbbea9327dc4e95b12b65aff68888e42812163bf71b7e1d1a138cc7c7bd74e67053250a2f42924c79978aad841cebdaa8f992790262870b4fa21828d463ba4a89c5896f914fd46181403d9ed807dd9fe2a4cda1a8a850a50a11ae9ae52b5de1f769296a0c79fa21501faa3371b280d19eae034c5192f0a4b0dec94533103ba52d64c5183a823286b8b0b1026f839fadb8029c77ce4016a7d99768ffc4d1fd38cc4817fde7d325b2438c24ea76500dc0188021b6eb9eca6cef2d85a08e72b793aae25f0a7c25e425913d0e85d848e51148bf6f4a891b122e5079bb8170422a187eb08494b8bf68a2333b02699a8bbe6eb5908a04b760bdab764930f51442dedd8b5d6b293fef17868aea1b4b052d0c996ca82e57e2a8b0dee61d0f7b671c379ca90907bc35b47245c07191c1c1464c815f08095dd65104cbc4e8798fd4689fa27722e6593e28612056c4b33136ed4e4f1a9691ccab205728f11d1020d3e59a37fb5df97c9858e98f159dc5101af26632a688037d59d5b82947ff39afe458ea5f605c3329cc7a97cbc64608e9fc3451f7c3d873438872511e69a15ef4e6086a21ea99c7b40a2cbce4486dfad6e9b7273d22e51046f27a8fddf115ea9758745412ef83032f6c0db76f8ee757823524b59c080866ba12f1ba68cea94b1d1abf11c3f7b71cd0ded0cad15b4eb2f4e628f2854e62a0634616b20abc79f06b88566400a66b1fd21dfc011b6cd5d6d229e7ee3697bcd18030fac0d4c3eea62fafd52cd73439e1ec7fe25599c65e44a53164b197ba1bd04496572b07c515e86828dc3e5442db4c94c58eec2232b477e91e66c2dfe9c8d56a2be0fc9e1d41bcb587a94ac190a5e009f7aeb2994c221230ee618f60b96a8a0ab467fc1cb6549003659d847f4f2fe265691e900249c99f316b58e5cac0ba7322b767b019dd838adc342f655c9d24f12d08dd608c367645d1dd0d534fb61226de4c3d1c66f69be4b2d8e4b1e2979c61ad83659c821697be4978cdd6994d45668d09e1d54ad8b4fb795e9c61ae15e593fbe350a87247fe8c8e79da0e54e297e5d8250465fa3449c41bcba6c7056b90dd8be272a4732bdd63769ca8930b7fad0accd67cdd675113591c6ca9729554f167fa95ea9d9fcfa94081471f81ee06b15c754d7e8f1542c7ed24f7040cbecdda2294470972038ad594326ca01470c9bd8d52cca393379bd716c10ab8fa0590e84d5a610b2c3266900be244c84601a19d8c710c4bbf54d694ef31f8ae64ecfa051d6a52b8a667981c5c03e9f678b7caf83dc4d047a3ca6f65000a4465efa0f223dd6bf5cb992221628d13f8adda1063cfd05e51a0cbe93607aa0ff9d40634767eaf7befdd945f33f9268df0d5229393a6fec7fb4f9b68294a291c320ca1fe4fcdc4dd5d9465deaec86d0c63ae0c4069c21eb77f7f7fb281f0b825453f074c1d1866e7b46f785bb95d7bc60a96069c0d2db946bd3847f4e0bd21e90e2ebd49db7fbf8d870bd92a420666bb855295eec7d96828fe97f6e4a25f96a3dd1e48d126a725ab19de835cf91d39632af2b25912099d9624c2c3d9329eed63d79f1f1f34087fc132d24a78fb11aef62dcd2028eef67a38ae957288e478d36de1fe9c7006a41520d2b00f3c1337d27f71ec0751cf55b9ed392af9828f7769de56651c4cff4e98ff1f41ee204039acc421ff87a0280a1be40852dde2a5e24477d22945fb28afc3d5cbfce4806c6d32f396746d02eea8ac426c8243f1062a93063f37accecb7241f5036e432950cdeaed7df6d1d951b2aeb8029c815af02b60b9f25d88a008b174c5c6dacb7ef1b5506d5acae556e6aee368ee3b05d6d6e0617cf342acfb0ea805400e75c3afa2b5d18c884ebeb5ae58ee077688f5f3b2b8d7f331a918029b29175a25ba57a4b67111bdee4570409a4e4f68c514b2726a9be14104249df3b84d5603327e87b185be1d235764adf7cfbeb4424c42b22c17ade78ea1197533974ff8eedbacd6381fb3ec088760cc24948e4f01a10f46e5e8f252b3672e3864743bb083c22969d8630e87fed592fbd6f494324af2159d6964c2498640ac452a6072e75a2f731d2bf41dac9f7047d08ab89e16f8fb6e2a6be8fc9127666b4c4a803c20326fdb9efe08a78b6c66fa924c19bcb59eddbd223ad8f44827b5f586904360c491229daf02a85adf16810cde17bbe7959f57a2554fb41aec14218a18e8f2b78ef50d15a1a98275458802c16bc84a0e5df0c18b083c18ff3381e02e6679ab2c1e3187ee161cbe313f10a34656af4d5f6b4db463dcd215a3146eb8471ee87305a3a5830995ad8596cfd5824ee0aad9d1a5e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"09491b0867e61bd0303e4a7186b8bd6a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
