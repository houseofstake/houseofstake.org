<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b30987fee291930da06801b0dd26eb81c2a1a883c0c81bf8f838ab921e1a1fcc6e6e9a7ca3a6443c9feca0a45014915e476a943eabc99d34b31ebdb466b2e7afb5e2df9c2fb45ae4e0d7de90e824e1acf6ace66bc7fdd749e0402b295005f98cf32e648896aa2c0aa9a6d53eb71eda3855ea959460405a1d0353ef0917d77e4ec796043f6b3e8269aea3dc603f6c06475d4d6b5af0f418f65493bdcb077f87b9117879b21c28bfea695e4f92a159375c76d1bba57ae912353b0b1453de109a990b7a245b4e8d9f9d60d5b3677203f7b48ceeff111045f781fa50f85dd6f0556dc0f5ea2621b12087c96984d6d7031fcddcbdbb0e5ba41f7c3f695ca37c8a850ef14cc16e1e9b097a77a8945c7afbe169795a00d810930d2a3a8e00b161f6fe09354ca98545e91f0cfc592baa34b44813be8b2af947b3dde32b1630b76d5396cee9391578a055ec06343468c9f517c213a8fd347550e5b89351c742c9ef1396b1cf3f418a11352296b56b4eee44234073ca955b6585380b33994bdfc19d1cc1596094aaa7fb1be964ab472922fee1beb562bae7150af5aa99352103b9e60c427bae6445541b548b8f7dc8f81e8e6d407d12d657e319ddd8cc2b61e02afdc4121e77df747728d226668c738226849e1a14587fcfa9d739bc58c57e2f3605cced0268d3bfac2f7e6536146892a59c00fb5021a7f6c72a30c8579a78bdc14f39980edc4d8b99cade785df8817256922a3de8ce282329cd6ed7e012b14d6f38c1071576f53bf537a74efef69346af9e71d7edc4b6c96c912076561e66f64bda3dc2143b621486d3f90e6803bbf22103c61a2beabe765e504e5b45b95d19b213a416b17063dc05742f55bbaecca76c43b3a61b4a87605e62a685e5c0e67a6ac1b96c7b68562abe29906b094f44b6dfd3f5924ef79b7652674d942d16de44e8ccab9c6fb3b42c341ea37e5677b6f846aee8cfd3eef7dc9f47390ebb25138af3fc22bb9b73fff3c6f5b00ca29ab497d66709fec33e12dd05c1eef5001274b78c94503d94aa1bdc69e6da96ae00753dd526e2c88df8c09544e3df5e6868ee68ac4ede8ec6ac57cdc6ae26a70044e73300c3863527e979d2558adb832b6765cf936eb45446264086ad8e09215f54f17e56ecc1109cb653145a13b10156edf0e39858d54dd768fdd6ba012b50d8ff739636f103d0fb48c0e6a5fb7e72eb1a1d313103e5429b171011fb40d669d33df4b671c241c9fd3f4deecf96d8531cd62a12d28618c76de6ac689993b9b5cbe1febf692d9183b552d4c849c39b2109a8718b7ed2850c50fce1fde09512ecb6c5e6e7f4dd9e05ce2f609def692a284e3c3751533278362ed75f4c21b6c7ada1a74807a0badd62fb5dd0ec6f57dcb69cc1b0bd3a5ab87944fde6b67781d9d178c05f20fdb0b18f4a54d61ac0c8bb1ccad65ace8a75f7972b916e4d7849b93bbc9876b5c77c9c688d22fa8ac9fdee9c3e85dd201300b4a06494d694f39f689319dee50546f8e3899ef8b5cc12bfa66a3d0a6d128acc7affbb1bb62eaafd31ffbd111fe7a2ed0166452dbf66be789ba74c12a366f62f16ac190373b596063bbc21d43ff53b962e6befcdac3c5821fe19bd9fe44d9e075ae1dc1de39b4ed3b0bb6d7ac6c2876d683f5a8c13f0286378512943792ccb79c37cfae626bb76323a20da91ff5afa70e9dd605688e1f209a2d7f602b646030bb64d1188f7096f51ce856d398961bf5949631a1b4967886b1129fb5dab6ea7d8ef9d009d4c29487ad8c0b10e5bec1aa8d540f8abc518a44e68a361b28071b4e20fbf5f1edded8e74355b2392a0fb1c2ad719bfc409f9ccd24e192aca91dc211a0caae9a0ff024e762c2a1a024c7ae774df284d72549a3c966db81eed6bd561c1e89ba4e2106b1e0097e58e13f9a59dbfb4b8b28892410c2a10d2e10d55f11a7b10648fbfc63d67fc0a407f8352d0d6aa54a2aea115b41f13e1ff45a05feb3b5c001bab8250c45b28aedcb2deef35197ed71416aa178b8397f82f5e3a845cef35f1e43dbe9f5092e92255b52bf01bca036a131f7abfe18048cc0903ffcd698bae0604938d894f48116eb6df688d573a203903626c4797ed65edd0e4a4e99ca2b33dbb85353bf9b368f12f08e58d11cbcb0661c840241a845a5580c020f467dbe0d6eb8a56e1981957ba38ae7a4e4c8cddd687d2f23269bcd286ddb64d4f28a747c950c71e182ad8c1684fd3c9e636c78fdacb51bac9cfa3a58d3bc89b154a35fbeb36ceddf8b88e9b3a8746666c3407e3a6bc3297a8ef49bf4e65c5159a2b6ebe115a49a4c7a41046df4ee8e3694b93e50197afb81345e8637cb2b58719c5f00bcef9b70be9c9494033169336c7b6c1a721f0b5ced3dafc6b1a3bd8d1160685cfc209c543743e45442051427bd6684e18a09169a9ceeca2380d18e627637978159742e4f1f0711a86b9739f386898584d5a280b8d6b9814e539ee90e0b4c30367b607acb20efbb3287082b875a1d6c2126824ebe04f2579a46fc76f00cc01befa513b472c0f8eb75d2db175cc69078bb1a146f9cdcb805b1437566c4c54d9749153b7bdcbe9eba6802d7978a9027665dd9844bf5ca19113037b6063b52d29b9119d5f214fcc85657661a43d6875a540d0242703dd990aeb05d23b7b25ce2fd9b4874b18bb1e022f566950c9a4cc920730201fab8b16314b9642fb8f48f8346150350f2dd829abc424d5b066847bc19ea56728538a08dfbeaf422264fa58190a9fcb7fa624026c7e9a373e1ae59daacd3fcf32e1fdd67dc089764862f99913c2f2aa6df73689ec6b7f042a3115c02fe9b5d95dc4474ebdec88d35bf573be2322bcb16f8a12a6ee4efffa17870fc70bdf1afd20cc2541c61e01a9e3f023e8eeb845abad914401821b9e3ad9b3831d91644ab209b7f021c1c0cfb5d55d1ee90305d1cb90b5b6beb83fbf2b95078e4ca654acf563c4739574601a0b139e23eb1f2e7b37d652cd7ff4297c6e6df5d74f251fe590272df69f2d9e21c7fc2bbd471ff1c0cde9918603c1ba8fc69a8efd2f18cffca0f5e6e1f653eeff369a939a2901916a7d7bc2112f8d1a7bede5dab491992291d835f518bd3cf697c8d759aba334ed6e3faae20bab3957ae7f2fe2b6105458ed5dc56aaca16888671c227fcd2ef7cff3ddd6bccc8c21b2676386a3dada5c51b64a78391d73be53326c82e7f6e1ad9de2ce380fd27b94106d29b6e53e60bdb43ab96e84bf990e102b5f9c8a16890738db474606652e4ff911ceaec14a8a5716f60df4bb56675c4d3e6dabd8cbf38eafcf8bbd8750a60c10b77543d0000f3a1defbe59c2edcf8f8bf3086f160983420c4ac2eb11db60d09c4ec7088e53564233966880d5b5e1be803427114dfe389cdb18a8b6e285d79f9aa3652f3b8e3a042043587e68f9c1f1f40ef3fc82de348321f5fe7437eeb753f437396446b898a4523eed5e25aeab915e04b58d7fcc86a9ceb7debf1dfecf6e21f544d4792cf30ff8df3d3b2b5aab677d8f9bdcfa38b12293ae4aea07b2265c12b4f52210287cf744747761dcbb74e28a725a580b9e69fd6712d2df929e697ac854b6757919158410906e1b324e865e2c11e2819c7d45dae25141d4fd17e23b3e7e83da2336e1ab502f5b3db5f8ed5033d5939ca6bdd0e435a9b0a66c64596e71de1f33f4f7ec568b892402e496d0441d8fbb3ace2b9b338c33bdc5bb03ebe47fa8c2cd2f0ec9b61572f4c74e12c0b1acd325501091fae5a4072a2118dc414c28bd5a3658e3b6339c1ada5815f95553260ffa9dfa33c5f6f343e87a643e27a3dd55048d0cc621b8b7e2a8611d00dd19183bfec05780faa42ecf4e92a05844dff3528a5d4f2dbc412489b796c134c85f733cac110ae8d64edbe1aa16eb61583758b03abc3245e374d17bf06d86045d8a2e5c1f5702f4a804dc3ee96f50832e245ce291adc650fe3a09d1defb0be672901f61dc6c311208f74063faff77707a6fb1022c6ffc3e2bd5e0709fa340fde1c8a48033be3c2df3196a7351c49dbe99cabf5d59ecec78e73eed04773bf854611971fe91923208732f3a775042f55bfffa1d9f0f4784eb8a9346dfa37ffab036e247a0c5420ddf83ded4b86cda0a2b392ceb14d0a6740cf6b22639de46b5c1bb89a56f3c68bf680545ca0332b0ef6e1257942b4bbdcc7a980b15954b44351325a54c84202d620473f12252405d9f025b9062f6d046431b1f0ed097ef09bcf668f3bb4861a759399f3323ec37558922887724f318df9e137e075d31c9ef6d6920560c9e315aad1e88375dc6c43596948f41734e75f9e9ae07e4bb117c6126b9d105c757922bb7d0937083fcb1d0a29c672e2a9bfdb26fa7fe2d2d4ead61a3fb2684af47b3553dcc0006ac6d52e060131a29deca69143e843259a6e8b9b8cd0eb2e4bc33df47320ec82bda9955732e69cc55dc6d3f226879328a475078a13f202b4d9ba0f74f7ce348f193e932912c1c7c4a17e8dc1ed85e577950cb505b150afcc2889fdc3fc347a6078b98d99e7c9eff4d5a53400006aff3bdb9b6b3a92d7f407244b0ec3ec9c48b97588cc9ce35b49723819c30e91ce85f6282e9e30ccfcb7af7bcb8b61d053c59bd6a4c316295ecdc51aa574ba236b4f4290766feb5f94731f9117f31c9630f88c217641598d045a85f0ab4c0e689b3f339c4f4ca883462618724de4ddbe3011bb54a7df64ae033254328e7656ab784041c41b5fac24360d2c36afa2088e47f400b73fcdff8918418110fc2582780ba79efa16494293aaafdb8c185b991d7788022eb565b666c13b0538f9aef8fc38c3a418b212315c3fdbd99c5ae7c320a4c5b7b056b31ca1908b4e82d72d306d42c7055c93087a6f3b22ff2cf5e5f085e55d64323fb1f087ed103a5c122b9a368cf6664095424d8f796a5b73907abf002a07167434518d40212f97895a0fc4479271f7accdba2ccc16f4f91ab36a2a3079a14b9edd8757f445b73c621a2caa42112f7b49f2f14221f10bf2f9e99ac89cc489b4f8f87df78c041d1e0a5822161cb3beaff9cf233842c389aab856dfc45c27dc0610bf3725878a1ed5d67bd96d1a13527abfd1cd01c4b1fd893fda88572d518df8c7506a746bdc71e1bb0258a9725a67cac9f879dce51e8b4e0b28bd744e35f9e04e71448510da9b907b5b8ef36fba0a5aa9d07479be4845301b069ee9d6f294bfc0c9e13cc154e02f0414b9b4529e4c27d4486aff83834731fb458f6882b3ca46aa1e30820dd49ad7ddd76655a5c6ecafb83506d1bc8ca8999571854d0cf3e62d0b1755ccebeb7ea253f640e67b29a3c730e3fd695227e809fc62048a4eb76274ceab283eaaf89edb86538b130ddd08018c85c5bd2d449380d0be166b9392480d8c9197b6cdd15dbad4b47786afd541e09b46d045dd22d68e29c9fc97ca8a871d40eb262c750813d40f29223e5eb97afcfd8ba44eaaca67e1b98e00c0f6c81dd27a1f270cccdbc3b2dab29f060bc8da39b704fc03e6ab5d3f8ae886ca1a85f5690d2d3430c39f3e8984d48e3abdbe553ec838afbfe41b6884500d91a2a845de33603798dc88698ecf35f85abe03c91244e4a45333e3c9ddee45bd779cb17c65345a8eea37c82967aaa657406dbe1b06d0278cc42dacce3b4e2fe26f5bf060d06335b8a8c25fd32e7f81a3637f06859da55b133ee2172d516c9ab915413b26380016b0019f375b85c424fdcac8069fc6be7159c4568d85a3d71915117e88e73c6247b22cdc1f825b5d01a536473399ea96a2b2e262cbd041061829da32e923042ae5c06078f23b3a2c43866c9aaa29e7143b191032b7736d4410e5ae31898d74f2b81559fc66d9deb70bd307882380146b0903fcff0d5ce94a5dcba1a4f5f9e32915f8a7fb5a5da2cf99f66433e76a154b5ebd027a056414a8cbcad1371fc9bde46c33b0bb60aed0904469cbe0e814ce92332e6f572cfd3cd741c6961fa7c5381c5b41d29916d27824ed3d773fdd25c8f03621ce3ca3aa7efc87854c917cb752e79e783a32afbd924899fc1a4b4d101076e23a40e8e2bd68800bf33c0f141a4c7098939224a43c2d81e3021a2a5aceebe2b486d255311e28079dd5939e4d5411a1a74d60e03bd7ee860744d9713b85db58af58ec735cf0f84d3caf7df30e15e1b2142afcd83b5ac505481b143bb517eb3efe21f0304aa8ff8ac97e55b61d6aeb99383f998f78c061a763a92297e86105a8ef6fe5d175f1916e123c1a5e6cf3fa689cc01991660d4c5f9c9949d02f2493c4f252a3ab1e75605dce844a7eb5d047b9483814e956f1ef8800ed969e6f98835d38cd550489d133fbbee42e4094d995c80236b501c596ed68dfa85c3ed9142b3c0114c9346b6bc8bbaed7e3f6d0dfb2a2fd6f3f34cc0e80070c48826989830dab784fe07565c8109a2b8df14dd33a7ec54fbb17db1ef578092e3c86987fe4e1a5abc6271de263a9655a76fdc88b1d2f316fe73cad8f32bcec576a6e45ffbc1aaa764b003a5b3c21cae19664c6afc500b4edbe890184a95c4c4370e709181896e7dfd7d837b870c442803e4054742c827f058039aabc5ab84337a66ff2040178f2c59270398cd8954d00ecb5ab7365c551c09850b56b2c1961697838c258546f4d5e76c2c0ee0a3391467081ac85196fa3cf14f06f5a9f8fc0d91756d9afbb6ab5f3a8258788b6b2a853f2172fddb3a219b8a877f8617cb0ff47840c303304641a73757c5ab1473906f099def010ee97550fbe8e573cfb46df7b930fa02226bf5e41fc9976684df085a4805f6edd0946b80f5743d3503e3dcf41b03338edaea105d332bb94014e70f010f02b85cf0e218e5b2b48497d55caaf656bf155fb2a48ccaec02581628e25d7bf7e58eba6e977befb507ba7fd5d65008cff462f93843bb60b3b9ea7fd5763bdcf8421ce5dbd2bc390e7eb83c3859034dea0d771c483413a8c25e24394760eca2a66104faf902607a56474f901d55d02909c37bf399a960740ed9af8de18ba31c9e3d2bfaac41a43c27979811b7a3e43e4d9b576ccf96b8166cd5c68d2eee754844f981412c3c672c4d771cd8ddefeb5826612265786f6591c5c76957d4835053f879329dcbe5d2639692c8b5900bd475535095d6e21013b1c28723881b3e0a8b65ef1425b369c2e57e48108e445a1c92c07ab3593dc82f508d0929087826f7bbca1c285f2fffa488ff8144db00b28d687415c69b979b9f246dddbeb1c80fe3624362c0633666e618c45a903eb40b57a07fdee2085417e95a2a9cf843ea5da311f9393fa2fdd174b07f210ad2287d35b28742e0cdb820e4653261508c3c0f681cc47f64c118ce5c40c51262575ee093329621f398ab9c1877a7cda23eaa1953ef9aa22dd540943cca35882dd4c61dcf83bf168c833e23feda28cca27b93a2c8f65715d0acb059baaa42bf7d06b3b6ba64c8914ce1785b5b784a91b826742a826f15629c1f247f6be9847206c04f7534f8bf2c79ba0250f3087a2e1b35dc48223a8f9d872359ea3bd84286cb275155367620249852ebf1e47e6b3db906b7feddd2dfd0f1448a1e6c0a7402856229aa54d7a2dbccf1a913569c87b7b625ca27b0c164809f9dbbd0d40a7e92322a33040fa107f205515468a41a90971a14cd2d4940a8694d268f3a1205ba149dfca0cdf5c302df245273583292cc6fd9dd6930951894b49abf2aaaf35b4bf2fa9a9b2613e32fbff182e8d84ecd882d7564c820f68b250c9beb92f48f0575514f5d8be8c7687ec633c4c2411ee012e30d63db98e3c519096c5a103ae142da1d88ef6ca3e14b44045c38602f5509ce91b17af547a35756d3bab03023cc636d2a4f50b52ed416a66d1df0bfb24274291c8d187c01a1c854a4514557bde6b2dad228b9f08530f4b8f41d87daf6ac8e158840c4088ab04e66ade5d250e7c2e10113ea2ba04f408254666af55d591f15710f36a7d17451555fa09f01d752116b39736d0a4c3d4e2663c3b4d2beb83743902fd743e3f8c4f2e0c09ddeaeec77e262a152162179e0c9752df6cbd38a2143d5485c7037bb19dfeb5dc9fecacf519d1ec59806a5dec4bd80a25adcea63ca0c12fb15666e531e4401e05fc9fdd50bee64e37bca35f1169ae6377b945c9743dd3b98a6b37e59db7fd8ea6649f29dc72a67b97a9730a878d54a7722e16e780895fbfbc0a449625c1365faf65cd329a0f67c2c5b7e3bc042d9ad08da49cb41e7725fe35fa9318b938aec3c959aad9235bbcf4f4395bd4ddceba0aa1020052bbfd52da6f9e63648de7e38de0c38924a290982e036501fc49a1e332f64d25058961d8d06396fa9d19c5acf510deba427d494aa80bf349be00698464b0ddc57ae41334a873ec2b462c3063e1aea55c521a15d12b1e8f2a09433db8e81c73896af84c50da593acc6b5e8333bc98002ab8f8c9c0c5c4dafc7d7481690c950558e0fa27d82186756fb29f5d3a9a0cb897517f994a18025d7ec6fa5efa471165188b39c502b51d8eb10cb1a80797844cb28754094cd143bb547bef470173ff6dbd65078ce3ed8c16829cbdc77f27852d899d6a0d2b4bf881444f386d1c4127cd59fbd91ada152c205f561f5aed922c623b2ea46e69c5a17fcf934a2b1107aaa0c3b0e2e61579c56a748d62b8ff473a56c67fb552d0287484a160f4a7ea3abe515b5776effc502557b6e353776966bc9388b730d8f40e6694e8f00f44d8895eb1469eecd7e140fd84165d3bd40845d243ec22e30a7f1606e6f1d88a1cc384aa0e00bf997a4f96c0a1f16de640ed3fa124b7cf4e80e46be46752c0536c313ee049d2ff8d707f3cc4d8f8d6e2f672e0383127ba296458a5a8d60a16ff555447e0e7fbeea74def047206558685580bb1d516023809dad9080784e1ca90ee2f25be7cbdeb7883f49e63b7184b5b03a3c544639727e94aeb26d3de8925b006ae83f03a9fb081c8b9626a2f06cf3ec212b1046ed01e923c02fd68e13246025795053c18635ab0c1331f772b951bddd9179e66c121c356d5f2275fb652bb749612ad1cfe48c8266a2c9b72822e8d452293c3afd295c43bbf023c7fd9e1b242fef77add75ff11abaac80f6782684269b46ede44ec15dd35eaf9a2263a190a9e78aabb59c36d34d7bd5f7b54e52ddf4c13b47703fcbe225a15f323ac124b1696726b94b9d0719c625fc83db539954ccfe343d4bc8d05063c2971edb1d26d66ec2e550e635b7cee4cff12773266d05d0e6aae57f02215754a950bdb878313f7f82eed5aefb09c307b7df9dee3fa90ec876d829569fb527234f6260e3e7d578bc6bb030f801a6217cb7eaa14eecbb96c2159ea3b589d212b3a5470d4e621c67277f83304a250c33c093a6de0911c91308680f3f8fe927f72254ff6968bce174d9e4361f263d7c76b18d6f89736cdd1b7780a76b304649d89fb072bf8ea8c80ca3b7da30b778fc37f4761688ad9439371b62473200dddd1ded90819e29e856407df66bf47a598f11c4c9587a6553718909c1a269a98c0f4cc3fa92154d59f737f72e53412dfd7182ca781f177435abb11b816b263e9e746255726a9aacdeafdc3dd4c7dd56b187da926d84a6d9c5988d47f914054fd5addecc7f44e9c4a3af87eef4b7689ea17763ec6cb226744d2fe66315abf145212f5a326a13b7f67c6a5368de87dfc314ed9ebc6cb4788a149b2da33edde11bc47f511512012c979647448d32ebaf16ba8b4558add063e5ec3741e414d9574d5b5c6a657c2091059cf63fbc05f703a587f830dbd58acebcbd798d3123c321781a5e7b8d72f69a7a9f1a3c90dfa92dd6e5c5e51a7f32a060d052f31694176943a8933e465c1cee6b2f2f1a76f30c7275251a16eb20d99a69d0840af537503527a26d68961d4e903b7d4d146792ff6a861d288aa02054f9cde2eac44990f0d9585c6e8e649f4e889f92a34243a28abd0e77df3e547bdb1ed10f35bb3483c06a3f1866f55a29c05a2bfc4ed95ae279385095ce09bdfeaeb92b974e557d670a0923b270a8851e065327b7f2948e529b1e56566028c5de422747a04daf7e7de5fc8e142683be87077e17e9db25d9dde800e6990aba2f92698b391e030311972eee0554945a31eff27cee93a4ec67ba6325c49a4c806101dc44979cbd5796eda0b228f3df1a64bc639664c5911c03ac0155f8b56f3e13522be471e5d1966ad4385d684f2c507cdfc53333b71165e04a8478242c51c2b5c9819e4e9005776777c6722023231110fdde7d21467917209b5d518714147ce80291df215f932e4577163df2e31fbe0c7b878ff3141b5097db3648496808995852984c1a972b0c110505aa4715e7a8465a46850231da54f59b33aecc5a18e445061444f9af7573670c7f91d467f008f829e3a5f63455c4b73f435024a05a06d8c4165ecd318f15cdd4f873a00a409db6766c47866855310949c360293ae716f1cb6def61b33df518cbe84d53e5119d066907437a9515997787e5927c6cb48c2f61ec34a38480b9947d9cad3b6aea277e353ef48c4689fa9526239ecbc33531a094feb3a4b3774d318a734dc62ec895d5dc7483c91e8fe20dea2e52e1b7dfcc5b5854e722febab05e188477a44baa9f7d7f168c16dfaf98fe4959189b7b67f0b3dd597c2ce724db806a5ac36c8b931ae81346243450cb7bd9b14110001672e1bbea8820c6b02a1be7df75e897cd278ee65573ed7e23a1345681dc64927e8a17b4752ff95d4ab3fe2c924561404deed249fab5b1ddf328305c99c65ba79ca05ad25c5f1a9aa540b97ccf508c94c1166f94b5614801ed671aefb9bd68a970ea59466751e220d14832e2f79528849210ddb25bd3fbd0e881ad0c94ae348cf2c2c25bcd5ebaf54aec6b6faf49e24227e8dbadbc50ba9199c982e421ebb8329241d6866e349e4f52399acb2386b98356df0e94ab584aa74736a32096fbc6776cef1cdfe72466ddb4e54bad0570287dd333933be8b7342bc336857e2056b96862c74fea2e1d3bc38fc66a3fd16fd572ae971387194548439b58bfede06b4a91e0dfc417185595476dba439cb7f50ff536bf7a374353c41168175da5c8353e87d58e96d49ea142668dc4a1dbc90b4973f8aea93f7885e2b26dd6c5bbfcbd2c90b4ed8c3cd873dada1a0d63736010dbf6c672ba93d3087a9845c4731cb5fd4a3e586c69ee8541bb6d5f2f589305fcbc0f8fa329c30ad454e0291e46cf98b790dd9dcbe2ec8a06eee705401ed73a419c9128e4584ec61f91c9c1995736f28387188842fc8647312141ee91abecfb49c29b27eaffa7ea77c471dbc433bce68f8617db19441b3fc6167c436dbd22634cc109dfa474c0d1cf4b9ca6fae13aeee670c0ebfa7ad2098e65f67f3f03cbcd4b292a5c971202f5c5ecf67d3cc6bd0f79ab2ee9c4ccaf9d3d4c942933bb6b7ab56f2b36c6d714e182a7d4316f419306a9e49dd3c8616f749cf3390d0b500da87a521dcf2784624aa2c6ef8c84ce8cc77dab02754e11afcbac5468d2edfe523f1314229b4427b7f6d9c5602e32069d2a515ed4d3f9f65d2154c0a777bfec4cd25bc49056dc1917c9967298ec6f49e6a936b4de69c20c8aef0f9475b1b31b38b7abec112ba4cec4b7b1506552fe1a85397375bac08ab277cb1bf977aad5dc846cf8f448c88edfa39b31e7cb3e87d2a1a4d292ed5e478cc4ca663741920a927a703a12f9807ed29a98861b854f51115164b7dc6543c706d3118c494357ffbfa059c65cda4582b16d4c8a50dc39644500dd8fe2f22fcc2619c958bf84aa8e577bb524a21c88394bdbd17c8576b43529b6af7790b7df743d8224bcf70f5f7975e42e29aebce0b66e948653812d32a65e5fdc75abb48f8d965866382ede7aa6b55b3ae36a59b6987329cfa62afe2f92cd86bc1eb5338c5ddfcd81a3290d9c88913aa207de6acefba586ce0503a81c3d94b4e545ea736d3359c523cdd2886f011080a2624311302a4ebc0698bb82f6e6997af64a3409b8f471e47968fd701fa1b933910e4231c2ed1978ea38754a051bf1458aa6df32f7a08715370234289df2df4f71f27924c1636e9fc664e65ec845c8e46e3020ccd574090e7cbd032d19b03224dd95f44fc5bceff9143580bfd00ce4da093cc765704dd6a44fe00c6c20c22a9cec4c8715592ef29bd80768923595041cecff2e4f764e84f80ec72684073509d0bc161ad6d82bb2559896ad88a747de11aff712d6c41dee36814a1a9babb02c3526f3b569783e8c14f6a491663b5d32078013026902b82fece660f70212146153e9c51792f4182250f283742b67e1acec59f667a48d3c328e92bb4a063a5e64a1c9ca1954aeea01ee5667bd7d97caccab80e500812cd7d52fed3ab851ebb380debd829862b8e09476e5ee877c714d0e32a01c139864183125bf5cd89c9964e670fef73ef46121a7fd0e919d45f63e9780874638499afeac277a311a35c86490d0188cf4d46491159d8537a8187fdf698463d9647f35f347d9fbb7d358b37d3a40cfd794f857fd34cfe50734e448b0d524777c7dae621223d6b492922a50a32f0c0f6c9c781f871de58c7d00b4b85ba01fe0a43c7e19b2e9f9cadae7bcf6b1050ea85433ab9f2cf54e1d2cd4c780fbaba33b024cd462ef1640ee0c043d291cd9cf39ea462fbde6959601957228b75a26ff5a793584a564f0639bed1f4fe641898904e2e0ef476c7746ed0ac2c462d653af8dcd22653a391c003e746a07d8a786cf434b1fcdf51700e690e7aea5569d9992f94d74403f85b407ec8e209f989e42d7e460bf8277cce4c1861a49a642c8c5277865711dcd786647275d38792d1cd7b8cf6f097f5a2aa2336ba6ddd266eff58c2728336c46f1d9db9182b9f01ff27cac3634b2aed438a96a3db9ae11fd7836e4e2f15ef8494624548a24f7341006f33e9abc9578315ae02a85454ba8835def26742491877c14e6cf5b293a308c1498bfb848cdd42843f1fcbd4137fe61ce14802b8f5459c9c882435547fde3b69e6f3558b1097973f819b5ae32318364f5eee898b65969fc31ddd1423d103326e9e1b8262b9ca955aab10799a76092f45f50363debce9ac56d15c3c6b958371e6f887f4122dc9b893b2807f6239c2cb0585ecf6ab2206510ec1842c8d923e2e270a015db055d3ef56e4a11413d0e560c81cd53b90e967fbde013a63857b72ad9e94ac83a34734be0b3c82fbbbe39b44d55d05dbffb9f1c9c3b80ab2f79a8a5013a8b21383502e1181ea4240cccf077a8eafef224d12a402033e18808e292c58cfb75836223f0e6cfa4eebb4a44b6b6669e090ee923e7196e3da560e747a4edaae72f65722dc0292121867d9f0c348cd28bc188a0267b443868a1770d50783ca801dc3a66b02a3d615f6c1ca7a18a53578a7ed26a456d40e2babdb73535e7b765e42c15b67ad0ddcd5f16ea95c4a1755d990d1a564f627220161d65414c70cb7e16a5c41d165bbe756af37f0325b2938d312a4ccddea9d50149735402ec367cce76ee7f1f700bc05582610f3f2d7474fd00698ed591a38904bcd973cbf580c2ec97dfb614d0d931164b59bc49b2bea9dba0a0e667036dd687d3caf24c9fd0d8dda307d4a46cb8e20667273066ba084490c18ac3a00c4ab9bd321935b73ca96778819081002a60334769754e2c0c8c2be27e6f3d4d723cc0c36ebf79f978730f7afa9e66c8982eca16936d27910a202f97d774ed76f213c9536e46775df18aa0ff6700af299db7400546dd11d29e4c9f785a0b3205b74c4e3ee76cd8b94a35f6bf11452ac3a2e2034f043f65d16dd6a72a07512a0b21c62d1b216501ed5c1ec3d7b89b058c80a911cfc1230ad03b7a1726cc7b009d7dd3efb1a10bdb2bf8dd2887085faf8c5e18c709693cccabab6b2466acd2b55993577e23d77c87d74590f4ecc6c9c2e7ba83dd3e275fe7e1e9eb62aed40bba3ed159c3237060b2dfe879b1acef79b7e8f89a60fae68ac3eb96d9c1e5fd67a9d5dba1139d3e6e41be7c305f699c83fd339e874b0c95a89a27fec14bb07c01ab4a6699174654dee1a8aa9b2ff1250037d484b9c83c057a46632ecafd53ed01cd592d7e262b80a8afeb167e7b61e705dff251db513c9f0dadae494fa7826c2053a8b68bc5263b0ac226d20c66d17ded7285a831d3391b391a9b93ace0f3d7400351c415aa5d837ff623ecbe2f71babc0e01e029a2fa8b17d7fda8637eee030e42c952a55fb9c82a18f745c7cade74a77115e88709fc1bdcbe20f6276770a012c924d1885859f1c44868b6ac7d2137e86df036082419651edf8bed902845bc71e7d3bb6f5347c00e53577a722d0c1f8d93cef9e448e3fdefe5088a8bf2f701dd62ea47ac9df0f84ff21aba64d0c64155cf89f5c316ed1aac2a7ef8ca4700060887c44fb33826668ffdece6f0ca1ead51b78f28ca614387f09eac1fee3a8a1e81486e13732e532714d83d27442a1ad28bfbd7c99beef54560deb1d3360321f85e289acb2027285fa3870e1c787c932e6f0e5f377aad6bc3dd6167673845c08005528be3cc8644c3fa037520ed20ee4673cbd1e37caa783459aa69c5b1d7a6e5cd10480d482356a3be1a1ab9a3540baad94e2658d60cd955acfe8029aa85251c07bc932c1e722ffff5623bfc3ecaaf4ed09be5af53b208e78a2d5e5ff7d63949123be33f1e65ce47b4c0fe17a9d0005a9ac0a6592cc00c4b77874703f98fa2d8ea4198e915f38e25a3c234a5d1e688a8207a11e0a291f079f0422882cbe8e21ccf296d7070681256b87a2159c1653d03a873e7aaa767181ff584ca9ef3c5213e39401a5a98df9814a8c6fd2214f97cdfc802923decaf996189885fff4ced29bebee6877c99c00e42390a2284e9e8b91ec808f35676a7e8bd84a00ea689009c3607e5e58e1d04f3f4a893107eb5e546d0a7c7d7b99b7c92c7d889443b48853c4c918579fa67e48b091bc8170e9658f7566957e0e1edcd4d68b13696735b17a218a6c6592aecd36b48330cd1227fea035e714e4a1b5edbef2bd6a560827ba944e954ab9d3e47972c0f37dc13dfa45d8929d8ce75bd78af896037c05a6c8623a8e4675b1f95a88e4294ef2fce05aa7ca09bceba15e2975c66ad92d5e61a67b0783fc786b8b8afbc4a86e37afe8793806058cbbdf968cf2249ef6738b079895090bdd4c0a0acd417282657de71e8c3d66f9887beab4d012527ddb40e796433c9cbf2f28bcedcd3367d2987053c125315346399005833a4e2b3009db7a341ca784d35c6da1fae1b2bb804f5b9fc108bd9bf2165b693e8623555b52740e3769fa6ced1ce7c68404a866171846031727eaf573756375af77d854bf7a21db5e0bfd9e7d1dc2583a814955ff294f63bbab4b0b7467d2d2bd9a9e8bd9efe1cbbc75c532f9622bde7f011575fc49895e193069f8474106fa30f2ca7b320c63e253809fb43b569d81e083b307d033cd6fc487b3b0a3da34c9760280e3bf9fdccfc448572936391aa96bc1607a9c68507e0d4cf524c749fb5cd487524fcb7fd29bf67025338c208170d438e2370e6085d735afb1e3e6466317267af468914582133efd1996063119c7afb661cf9803df030f355fbb12d35169202f3e60c11c7aaa979df718eee858bec4c57673a401ecdc25dfd84e0cdf97c51e1186bc099aacaf3484702f41bfbee59ab383d14408f821b7a82e2aded0b5c3f19ba018797cbafe3477db4ef0a4afce202fa38d6ebccc6f8fe36b0b7747a1bc7cd19f25fe5d3302785a08c73b5e83e6887d5092e631b43a356d85fdd99b14860e04efe2cbc2f5b9ef20e5228b842ad3a54105b33c84c15904e45763e952001e2c5f3533e5855db83ebdc4bf0c77071ec2175ed8037f9da7acaf5e33b6da46e247218b33cd53d22e91d172db7e1f7a1b94920d286e03f5a6bfef7c54a2787678f87dfb8e4d0ec68efb97e543b8d9ad2e769b0adbaa0cfe2ea7053faf407e3133f36421ffade94ac45ac297de0508","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1d92f157948d8068f33f02e45de5d720"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
