<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0dfefe795d092a8b31b450ebaca6fbfa0a4d6dc7b7395c99acaa5cc0f4a6ffbfc8ea7b1148129664abe1021045947eb86f2a712523fa992a7368db6477ff2aa39b593e61273f21c2b007c52f8dc884657c1ca0dbc11d2bbc908ab00d30da80d464a8704713f1aab6a21d95c50ffc49082f9d80f38814d69da43918c1cdc15a912585502680ad78dae58369166d67dce45cd6fa6cb5e8efbafaf030b66c10491da22c2a8a8ec919dc33499bfff8fa18b1a1c3ba687ddc9a21a75fb64b5edb5e64f2925e59d4e6aa97900df82fdeefd201169deb2881913f7bf246caad8cb93a8fc6b8b2da40e299c3e65b1c1d8d1da5c1fd5a98faf32287ea26adc325c13e88956be42aa31078d376f13865c392e467921055102962dbe19cb203b5ea16164575636a68ab289d075fdce3cefe6759fefd275677abeac7b64a54dd1fb233a2956c08ded8bd56c711227206ba2de447e8b70088a27bb0b1196f300c1cd2db8d286b9a7d618a776830c31ee87c6957b67f620c61c0f832410406abf08cf8301678111b7e05c5680c241a783b2bf41b642b80192ebfe80f790b052b2b1a276bae60a2d8357c3040eda1a8ccea6ffd3ab089816ae5fe4eff92b74cc2eb578d92e6a3b6d95c563007467a2533f9a05396e663aee81f05e732fa4eda124f36c57be0e6525f06b9ab74fdf24fdb17f4b1d2bff1cf0b0ef8d899b4ecd43513069d867138ae0911292476037190abc6510f2f90eef13c65b700947343c6acb609f6344cd3a581e606b29c2be1bf39610a1b2ec140687a6ce2b66edd352e6f31610f93fc464edc45916f16cee9b9e2a9107b75b5ebfbb1bdf0a5ac28fce7edf47e056c18215b19c6b83815ce095050806d84701df41a1c00c78cd5a1940f145b118a5205adb6fe685ecee0b506d3f5d74e4acac7dd8d857600ad5813db813dc05ef9cb38595861f0efc88241883bdb38ae40182d185d6d8aa1b7e36b2a466353842c0db56838f3a2c26c60ae9780016cd89e33514fe00a6393799cc7903188dfdc1f2d7adc6d9d93c7aa4f4bcfd64fac54149272b19e8098df5191b1ad0b293ad6a84820585cdcc664bbab1cb6253ecc79e294327d6bdd37be32f2e5b909e75ae1e0ac19398dbdd0a576a97ed1d0a8786cb491955654b296d2a8e4c29a300e168ea532aa8df640e3c06e44f4711c7c667ba6b637f73365563a421a52b5d595c1850b3efd0b21d46d1b2506c4472a2a70e9c344aeea027a270d2e09ef38cc021f4bc335cd10cec868fe99051d457606701b2b599dbf9149922d6c3193d8824bc0f7926dd7736ce261bfa5ac1ef23e22f995ef186f4b13c5d83e6cc44fc51ca2077ea7ab01e78b26117cc6ed8fb36b47b216044a0125e88d381440899d1c688ac06e7d4ab7fbbba8aaa4d5dcbd3e00d71771e1976d32499bee618b618941fa91dd4d13a6ded1b9e8311beee772d9db169e4229c0d90d7a02a5ecde1eb3f28f5e4b0c4d8198459ecc1a1f4475ade13d29b772c10bd3773f4b6157ac9028c59f91b8dd28adff432a5eff7a6787143b2caedc4379f25065cab33ea2c38c9f46735dab4657ceb6fc0cb2597de289a1060cc07fc639fbb2ee3b3b29e4bee5fa1c090bd44ef2d2dfaa9d626b7c81e40b2eaaa9cb2cca977931eb4b53a2bfa03ee3e754ab5e9adaa77ec58c08ab61ecfd6016430704d9b87122f3390d0fd1f2f6821b520dc5b74bac1c7b6f9708271a13a03189b1a651f34585453b523940dd32601424b24fa6207d7b36d082cc4f0c74d24b634411792a57e4dadecf2ce6585e268a44923de7a11f3282261cc33c4b5fab6e39ca494f6fd613df7df36759631fb0c1b1c934bb8bf3a0a11f388ccb43ab06c06250554e6e2869bc164a90319a03acb8c3f51ee2787516438400a53459bac7e822313e774a6d89208a57678e6e538e5f45341646ad7ddf29f7ec4bf2b37bb4886b782735205b8129a71a95b9af5acdbadc2d1c2bb09074b101cd449ab5b5e8b14ae0ae6b9bd2164d9cdce486a8fcc27a97f93a76b13f9b35045704ef63601cb39f84ee72664617fcfde22ffd3e87ce30338533e3685d706291d1df9d8b3f816453d29d0b2c81d225fb691b249eef2304055db8fc0158eab20cf024daa237c023874b904a291e8756e3a36b87530a73399fc481a44a1a2fd35c7d95aa0460e68dc77c2dcef106e30472ec9c63aa3a129a5737c729e85bf0209cccf79a6d44fde71cd9ddad3037a73297a9e2347da851fb10f705d686af5861a6804c9b2c494a235ad3c77c2fd2a03dccad706256bbf57d8cc67bdfc86e1dad81d227d06a100d458998a37f15625df1b6360d2e1482396e15289dae7fc8bf12123268badeed8d74dab532ae15a29d5d2885c4d6fc28de6d8647db4e031564f6acf8c06fa5170e5d522ec6353ce74eb5e4b10879aba68f34ee9c09cfd7a20648eb7653cb0727d49b90cc84e169a2884f14bcb91bb9b61d6aa6cf568aeea8b7f4ea727a291016eaae2d491d70eb45763c6ea068ee8e4a80c89ac2fcae960fac7129cac6247085a0d6b802675a85bc36adc2da9caefc0a1bafa94fe76db807a848652b3651ca572dbfe4a2daeffc6dfb1bac052879a94a893edf2614d49da32f9dffd3d7067f0c65507a4c0bab0f94215828c5af9531a27d29f2fc773bdd06282d751d83dfbf75fd1c0ce460f29fb7118da752872d2fabce5246daef56dc43e1adca40fb6838683882b965009ce66697b171f34c9b04d78e94c33a0994c5458cdb9acc9983bfec83ef917e3c4477ddb746c1a29210767bae3a8492551d6c6406352476a70431e148b9dc2019c585ac513b746ebf6c42789b130c69baaf7c169610cc78bc1ca575c77bfd0344532ef4de16b438fc1c36cfe74e353726784bc8a929745d1b1c8fd02fd8ca08abc0eadd2811711674b0c84509de51fb077d2dfd309f0eb9b86a5a317e2b73ba6ba0ed272747b0bfa63a87de835668558036e684fa34cd6129a249cd158199cc5c82e398fa71a79fc28237336705946328d9deaaa3827fff7ba1a03aca3678d6969b9877997149c6c9fb3ea15e583c5613e6bccbe16553dfc93fa0cb39957391455854cffbd157301ae23ec1846ee9848ba072750ba4f37661701fd98aaaf1d9cc3aa158b8bb5771ecd7e356d75f256d9abbe967710e2dabfe60ab41a234cfb2f481787db3348e8ba5b2af18a8d72c85cc9da05a0bbe11a6ed091033bd17acc5f86c527bfeb1fa46460fcb32e14675ed0955ede89cb9667114d4a61cd9e11e61487aaf5a529c337f13dc3177d01869a14411592aafc600599ffe811720212a51a5d11177bb110f79a2a41ab3bfefa3286b32452d3be55efb7baea0e2afdc059555741d279fd77d8f30e54002a1efc1c807591dc1001ea0353b7eba51c25170a4bf899dc793442a8c3cd33565f1ae6e1bd5714c1cb2e381903611d94bef8eeba577a1ece2418a9e6eb7bb1ae5da0ae9903d55ea286db6aa7399dd7891d3e88eb9255805379bc2cbbd2a207dbd878c0a33d6d1b1dc07ccb065b13e89c7f37db8e0f090441fe69b20f727d6fe5180bf5bba8b195077ca6d6131676e46ef92756dabe87e8a054e6196eafc0ec05814e16189f9fb0d7a948a62e590ff162ff6d5e35e78581e6007a0d61a302b483dd59f9bcc23e6c5502005f8b49fd14425c1e37527f80f0f36e695d0ac2da119a41fd416dbe919d98dd70f113dba95d2bfa80dd44160441300408060054cd05a4ac3ff5544aa9005b90ceb1bb3e7ac3e12a2804fa5adc56b111fbc72996bea7bfcb11e69f60af8bbecdf2ab3defb91679919e7e0f356446e249c06fd19c0ec12f6159f5f2dada02601435024d4ae26d713aeea03e09d318a6d162bb95e14cd2844bcb245447679228fc06348ffb29657cbaeaacfbb2c0fb1180fa9874f4b4a37d3be649167dd515b081c774a5e7a146d00a1fa1e12ffdc0d89608b0955fffc72c73444d7b59d0f0659ac130a4a00cf9d87f67015763b7630cb2eebd21392af7919d3dd76e4b3d105c0226ee2ece4770e64f6ced0e174de794b4edae4fc6ed490043422bacac8e1b4d7e4307a483757d4e905d622a2833b6affafc59c88e01a75f75cff3712f46d4647d2f56847466cc7502985c5fc2fbfd69c33adc56e0423fe64c1fabf848d14361c2e83e41b4773a3660b196a50f9920e102ebae0fdc72a5d79b837d2e598368032b95b74097152603f16e24d2792f336d7b40148661dc704fa400dc41e8c5c52ef66ad455d4cddc246ae8b8a5703c75ad5febfd4eb225ea6ae305e74f90ebb1e0a7cc06a0098f3e914eb066151ed64354d9b8e1871302acf8a69f67e4d357ac19062509eb52bad6d14769fd8c422a1322ae82f27e37e36a1b96f0e0f2a4fd8a2e9d498ff3f1b4833fde852605b46bb97509319f22b562da7f47e5b93c6ac42f31368e2d76bca1ed552b2bc754830ea2a27fd6bedbb298b8a6f1d50568078a82e7d034fcdeb4b7df2eb7e92da17098d7bc43d9215cea19275572c5859e65adea13e2db8a090ffafac86d8f55227d7759b0edca5fbe336d4d61bf33740c36e4dd9f09b4b4e2a3a16ad0de509bf32281f2ebaac193f65a085615a580b88be58f3edfdc8b16eb49c2743c9f1a71de4be3e3a55bb73d4335229da4e5e05ca260eeb621babe93bda20a5eda6bc33c98dcb00b4e9709cca9f86362ec3c2045380938c1098db482b43cb173a854efa60a31fc8d0ed32c54755f276f5b414ec25bab1445870a31cbeb75f36b11cbac7f2c82458ff548d9a15f9d2aa0be874127ebf5958a759ac5ac6559d94d6ddea594e01784593839ada47224d09269a8526c7509661f27835f5d48d3f65aca57b745873520c88c6d970ca8a69c7e5a312848467ee2ee10c366d1bf3657da2c416f156d4c142a0ac61d6917180cb2d664b332c79541b766b39ef20ca81930184a650517c31c8d012d16ee05f1ea818edef69295e6713261fe76789ba2df81e14af0c3753c870d4878b38bd64126db880f613c71b6a9889ea17732234056d9a56e47ba7629d7a87202813cc766a376f0d8277acb61587bb818251799b593347d9847554e0b6be5e36ede2beda65f751bcf9b7387dfb03ea00fc2c3ab33585b32e78e38b3c1c3ce75cbe4a45c66e9d046a6df4cf694af41af240190b85f623694fd15244baacdc438c7fe81f79c989a384e489b8f28c7ba3a89cdae5a73c083780b82c993eb2a73c4b8c354ad50c5e5544d27a9b4a27414a4805c16143c5d07084db7f6b1f640438d516aeaff41b23afcfc9d891a9355f276bd6ab10af0b0324b4ff9b512a4597562036c11de1b3ce289bf8c8257fed18af4aadebcfec87d5e1617ea0b80d5d66faef0d65c425233ab2c9ec9377c0ce8e8297f60f49d14e1ac5df4e8cfe3b46bba080521fc42fc2583c153f772d981242d60a5d41faaf7aa5a02ab01531ce7b2056ad0b2e59ce4ab730afd841bdeef0e6fe83de3d099422adb210efe7ba2899cb4634298eedcb90ad944daddeb928197ace49924cbadf62171c55a36c0496aca807eff52d54dd1eb9d2727ccc2badf71d2c4d46d3228678a275b6ac6311a0dc84e5eaa41a23222a1088d39e44142df98dc8464b0595e0cc72e408a55396a534088063d90ce7bdcc88df1377ede12affbbbc6c15ed8f5f3f4a411c9055d618dec348b7aab653a2c4301c4ab71666b5aaafdb1814d25af25d50cfd9999ce1e9ae825fb7bd312b7357d7988c15c02a0c1ac10d7cffd23dfecabedb53ebbfb3a5e7904a306626c1c20d59f98246a177a6bee1845c290eeb2bfc515bc745d947b77bdc1ddd60d61b3686049b9a792b5b3c74eaf7a96cf66f865e0ab12674ca19608d11d60c15230510e13cbfdf8321aa90e9bf310ac88f9b2a0a79b695136d6f7d45dfdf23dce5f05728ef4938aeb216ae39e148b2a1f814a5f7ba46f65f9a3c1cd3e55d2f3aff731d6819c354c2322d1f25b98b5e3ba3f1b26a38b9f0b492b3b8114fb2d7471c44fa975e175ecd60db4d992dc7f4dee76b695e7c34db43f791d6a8320fbac26f200c7b027f9ccf2f00c7ed4cfcd36d0c93c43abbbc648fbb4465907a6ba11693726a7d43cd2b927deb003fa9cb9ee889f38128daf63c3b1b5e1d8dbf030863fbaa4f5fe1e21abe950c75588020912f973f73d952a3177555424cb2e9772addd2710314fc30a1843b7d98fdab2b3364ea128c05559d947137b2161e3272317d148e71e00c60dcbb995890b0ea58f2ce6e979bd3360732e0e96acf6d9ba09ea7e273a9b15a2e9178bc998056641297eda5f527558bb3797f8e278b4b300de95ee81a87fdc42d754d1a75a2d6a32d7146195ce0fa085e95beeb0ea79bf5a129a698582e1f503c952cf7e9541999465a2c5f09c225210b370df7f416e2ad2725f2efcb84ede21bdac0ad953893faae841149ba053e1b19e5215ff3e52338ecce90438640205a19a5d16fcaed66099e9038a6ac2c2530fc86e7a8a78102a6609b6e311bcd859d807f8f0feaa5129fb61876c5bb31e72469acd2e6d985b2195f89b2edf0d85130d0a1d804e7e4f2f59253af2d9a08741cd7dad6bf25005ae0c6b38a790d87999cede4879e7f2fe62249eea57ab76ae25114d1d66393b55e9e3f7ff8071e3380262b01cc4c4b85c6f74ebbf9126468e635267e721c66ddab6a4e3109da96f2f5164aaa1919718be8e3b201e8ed4ca122b175bc1a13872dd6c95f862c4ddd65f1e0653de015363484c4dd33678f70bce6a35a752b2fc87b0e4697d330193f164ad916eb4a573c780cfff6988f6fb246e1c6989918ed60ce09c7d4b2090ac9839a34ad0d1c980faec2233b15fbbb1b5dbe289ca71afa4a456a09c3f2cea1e305b6f7fcac044fa57da9bd016706dd3768848078ffaba338f5dfadc86f0b3d210227dd502e55eaac626d991962176e7c2a81925167297f9612ff2617f0544096d4c724542306ad8a09623b501994eb31135d5a6867fcef6275a56680bb680280a4bca59b98aa0c453628eb2ef32d9709fedd3e746ee877459b2131b6f8923f03070530a4efdca08a74ea1b1543aeb66035d6028f402c0dee3e8186844276ac7a62cb976dfd980b0e52482095b5abbb7dc30e7081efed6104633c7dbea579b5db5e80182c3889224b1f322fa9c5ac4dc9171f311f743ac1842ac72dbbded7ddaf799c20f74482fb7db4b94f90e6e7f5c183915b5a3af6ba42fd967d270b430ba53ce6bc0193232dc5a039205c7babdfef86db538b7139f31b817e09aa38dc13e14b3c96677e911b8ab9a139e47337407d9a145b82fd0d5166b5ae3d373582fc77c7698576c55041cc6009b0807487fe8ee02fd4bde15d289a65b0f11f38cda333445c531fe52e84c5aed16e88b8f7745bc6b2ba4403c3955e9c12d00c4766c4ac44838bc5ba6793c0639da0f5d75479fcaaf785daf9eae61db2a1c754e04c86074c515f5ac9949c72c8235af11c7b50b7983c98a231130562b160466b7925eb253f448d8a8cc7185d20b8cca24823dc0c400d9dc82c65e5bdee6f33cb84f69025329755d9f3c64b2bd9c5cee7f173dc1490dd4ac8c05f4698f2731f94453139ba2c8d514bc0b4323a2cc0548b558f829c329ab9e598a023c27102100cefdb7dfdbc7e689f9098bf653022c586980b02ce18d4d50fadc2b87a861153d07d764c94dff85090a2cd4f57d30136cbefd4e6e359bdac3054928b1898bfad6d33df1788fecfc2104d91a785f9e27834c983576efd309c5da8ed6bdf84bde89c172c888a605146c64d8856c66dc40cb4fc58320f942999b87764865e860e7baed9c88f5ffc716a5fc5c1ed86f83df8f01f17d0da4e2c3b0b2ea79d25346b2b2d798d71bd0806badf2c84bc58fb02b870e7f96dabebbe9baaaa37298561cbddf10fd65b1aa5e597783d3f2e3539b95bbf3523dd2c758194f618c67d73961fa2b92ba52d9bb20a37d9c675b662469d48465e9620e1464294761dbbcfc6e53c7f91a9a0f80f487e717b4011e347d815dcb52bbcc1a60727bd4054fa070b610bdcb0fb8194f29f255ca682375d35791cfe4a3ce14aa51d2e760e6cebb9e03d1dbc889bd95db834a10c03dc2cf7988053de2fc209d6e530cffa3ce57dc1f718e0259bcd25f2a9621544cba35a26c631ac38c2fd4f686354bc9da49686c1c7eedc48a3d1a6527698b4cce8257ca540fa881b26f062976135074d0c913ad32389d077075ff4063433e7a592bc22736a3708adf0c2a57db24a859f9a7fa6d0f026ae277bc0c643454d7fc375dbb31c0ca5e28c6e6546b409cbbbc1953ba315ea2caae6e6d091f4e0546f73cc78c4e1b2dae735c17ad38ef5b550c138fb3975b7a19e76ed41cb6d2c2b2aaeb792e2fca649b2e162821d866952e0fc1bec5e114043d72521f004dc724eda8b2c82d3201b9369f88720e916da8999b5fec1ab37b15a9c3e62ca9403591b5e370513689df5cfa542535351b82a9f736fe55689739e2b7932a43f2391423a5b0e2052f2022dac1e6f5476c30004ebb304cf79497c3d00f24e5c20e64a9143f6c5770168f4d266bd5720db5184e6ed8dc8b7d165fd85b907d1dea5fa0ab8b5d8ecdb67aa1a78a92e52269017cf9770ee5bf1d89444ccad74412cb0ce2312c31fb5c3d4bda443cf1610e402317820b494213b32b3cced6e1e3ee4e2c2c13c41211a539c501d5b0df7c837e8c0cef2eeebcc6dbc9e4650de75c720d801b943094eeb6095e9a9c32b20489b9c55c4c24694f55704f2a86631a5b7184c7dddc5c8d3a361214c7f749567fd61bbd3bc1acaf0f146005ff3766ff9f10185593f9517bd0226afa774c8b0db37254164a27936f025a0ebb4af34cfce14d8e9a9f02ad430b886f6f3cf01a11bd2f792d1297470e37f778d45145494ff7098bc71627e0c359dd563ecd749432d4a0c28f28693d7f1f515545f165638763d1d24595b428d0091073db8fc7fd2b424785b37e53b687ea8cc0e4da7d5f5d9debfaeeba3a5e9d8c6a7915b89674d0f37a39b9393f43367054cc51e20962a5f594322827b667d640e1bbeaffd0353b7670e79369ba9a8fedf6bb9207cd05f51af0fa948e764529eccf3287c085a431279bb9a5834d2e54632e70fc61f327e4111411a17d10bc53f1ba9467692aace9a9193c1283e76c569319238bb4096d295a5b3b399aab70026c0f099da93644a5757c246e06a181ba94b81dbddeb9dfa08dad5d6d0985d2883621e3135108cf1eba06964f9c158e449076c75819cf760125295807c3fc9fcf679cd94c4974a894268d2cf427e462c14898fcab9eedfa9e23381ee22d749b5be2aa243e5da343de9c9f407c7ce89c4f0059b97832c06d0b8da8ecdc03d95f81c7bf27fdd0e4a630b02b9ec18d0705e33024b1b2d525536846e4b2d17fa405b08036cc1add29edccc2e7d6ddf1ff84e3565876d1683ff455b7c166ed94b228c41742a740fb0d7bb31ac8ee06e51b2d0827d9f76713a90a880ce1b489811a791e861e9dd964a5330dc27d7a2635baf3601140fd64548bfd9f64a50398ca7efdba9314655ddc02f5c41691e0968e1e42f0b3252a672c7593cc83c055893d03dfc9abd69a2d4f8ab0119e9b7b5b0b94cd01d931136b05e4dbec8cf693e69a0386070a02c985806e2c02217daa6f7245b33a4c00df7af064215bb1ed80c88cec0d4c0c5d6a8d261ec2f04e51c933e97834681c1927febffb081c304d1069a09429197cb0b0518d20c2bdd7a2a38278ef442dec505e8b68530fa3fb9aded0f991f6ae52d72ccf8e76dea6ef8b72e1f79fe809f7db55dc4970cac953a9b7af23711da32280ce72579fb7afa3002648e8f527a89030511fe97e8b19551f5f327b755396be60d5a36b591914934b69f504de4f18a1dccef07e42b92901549a3937301516db9efcc0e316784f4ad79ecb94a926eda272f78d21f28376adccf3900ddd2b04ba420fc52f2ec1e031a7870fc338fe38701049d604642d31cdd10c72ac89c341cf97c3743bf35065aa88fe3d10287478e1d205cd27eb66417d3937ca63b3c5dfb4f21e539a1d1a3ba4d1d14f2b49a1b5c2633ff41ead8d5613245e2746a642c9182d75a2aea0a535904e060165075d173a9e1ef01c43a9a6b48b9ed16e585a0efedacd836d8a4e2293be43e3a568e616ff25fed97b1b23f28c5fb2d00c8eec0ed6b56766ab4b13b57fd6d56c39842702986b7be9a6514c247248a7d86380928b68421633fe1405e0f74ddf57ca0019e308fcc4e264079836ecb3702a1a78b9de6e134bdb3ac58e1a93f03e8940477c611168eae78ad38913293ffaa198a96f4e02b42a8c69c61fa6baff94f0472a2d937fc7f92409425d65437a33162ed2b4cab486d3b7897b77c928841062403f2ee709c113a22674718d296f20c1e254be73d185c82070ab76084444de0e8d3ae034c87841fafa8ff18508c6d68ca037937c47b87dbc590a34c9caa4bfe233fbd2d1a2b6f49f41268fda34c34230036124a940e994591e8fb78d948c14eb1dfb168b64a364e952fa37a10e8eb4f6f2fbee71ecd0f000660695dd44bbc581ac0accd405caa3bf600517efdb7d944e7c73f377aaa89c83e924883bce73efb304feac81d5e30e56132bddc26b6ca00121361137ec97d83581419b8b6d852e82adc5f389ea785c6018dc9f65a81c346f87da15d137739e5f0d496cff171eb7e9c8bdd15057075a16473aff47e24f8344af6435e368d23fbd2e28c8164b2eb5d1016eeaf4f00cc4e7248269300cf62309b51c19966a1db4123e392a4ef880d346386a568583b999601b57c5211c0efcae220aa4979ebacddd4252c99bd26ec72f11d8894fde33699c7cdc646e5aa84b921191aad26b80e8bd1a320dce68caf27ba6f2d6422044e36e96b72ce33439c6e51104b86731c5bd061570b43df226f19907d48ddc61810e41a36a127c8144c6620efc164fea40182ca47eda20ab32f68c93bd4b1f2aaaf7aaee1bfcd84336c517e1325d69fb65a0839783b2b7bc1695729350e82377cacae4df305110b333d945d1e047823c7172bd995ebe8ef996b6603e461fd1239f49ead9f168ba2161f766314a945235c40aac6f60beb88a992677c229439c5605556fabd759d5f84ca17d90d26dc2272688e15d6466433a84ec12013ccbb0cdcd7237104c179bc2acaf58fd69e0d0a968b18d2a084550ff931c44060ec6d6bdd400c3d6dceba10583386efa5a2e98026e0cef9573d02f8b305b60e597f5b6769fe5399542deca8e99e5d59653e68acf4ff88f94e72c8eeac8cecaea981e473004c6762334209df2a1a8978087af49022adae1d1286c381547eb98678800120b9e2b5b4897285844fabec8dcba6637fcd28ad401add102b8e6f1806f4637663e9b1efed2f63578e42eb56935e58c78f81b48c01009ae719e254e25a2fbd93a4b57bad1632055d6259c07f1cfc6080a463a9bcb4259eb952edcb2c7a3d02d3faff3042b7ba47c77c554c5154c19b506cc89711df9af3019d54bfde40a87aa2d03b4663fd184f1b0cc3a989acf96eaefaf1f76dd9ab6292404ff247656982f15bddb1d4640d2cbcfda34a64d5264edcac766a5616c9fb2f7012f29122c55da992ef50cf55eeff87dd0daa9cdc06a6547f08f887e42b9ad9ee11db822b9c869012d9dc3072ae01d781c2beacfcda29a5b9341631fa7a7234e4c39da4b53c7c85d8cc6fbcd60e96a202e778b06f07425bf2f2525c2e5e9d49cd3c589df7124179bfbe5aebb3c16e37c61a9fa3bc2680cbc6c0146a4d40043677907e18b33cb6a99e36bb9babcff8bdb42a8891381bac6ddc921ba8eb2ad7aae4abc6f02dacfb467fb95e2f2eae67b2d5a326cd2b20780f848b44f73fb008d78547d58b5b34da33bd5e5e762710aabfd4bdea92547aa6ea1b2cd6eea7b2dfd65695cbe62ecdc7e7c4293bbb46d1c3781b787a3e39b86428ebe73b5dd19c45d2cbf7e652889d7c7116a253d48f633aeac2149fd0ce2d51b18561fec106e4209f557a725b3688784ae20cb5a327f451d1dbe0bfa479e8e85e7386a53cfd5df74f677ebecfd3b0675b0c8691ff1d5a9e7b4d92e814c9fc654facfe6071ec6f4d66b9316397e36320aaccc2355aa83d36227e8e71463e665311383c7a941631011f97e5319887e0b7388780c80183d4edf61b41b41a01825a52283b08df4efdfd172f2f28a8af627bc0ee3944d2c09b6f36114d70d7c4d454bada302f6c3ed6d2d55ebb40781ca23b98db75e006bbd8ff76f4cf28f0011269f911a3f3c87eee4b97cd30be9d4ccfc3cc8a919bf6d3105ea9ff3883bcb80dcd6e4e9a92441ac9d16948086a8e0a842f4370d330623f1bf7c24bb0caaf76dbf891191f5dd122bedb4d11eb22628fb3dcc8d171a9e6458748661129205c54cc5efe0b684ffc22176ae8acda1cbc98ca3c8e06758ecde5c40ce3c64a06c809da9132836a0edfabfc56237a4890e93a8d21975a1a42756518b6488fc5dbc113fdd164cd05139a688d43b1c7ff95b056f3c2701e118d994b1d6668f20fdc06eb895a81def8d8cc4d88d097951d0b9eb65e304ac39c2e93cc45df3a6fb16e55091a6156a8c0de4f5d51db8176c7e7bb42d1b04af5c5aff1cf07f71fd5fc5e2f9831007f88b15b803cb7f64ab3b5f99b99dd96149c345fb624be1b75808463c7b1846e55276af00c5e69c629c56a93876de77eae25a9ff35e510eb4249b255d10789637084280ecca43aad73ab5abef1501342a5f4af3500152fb677bdf7bbc22e4088d7c9bcab5b96b640a4b887a620bde596ab78618cd8ab67a0429c9509712232ee95973bb292c05c449d53420efd0a72d9c196a80a18c80fa9a9945b882c352353373fc80e948a14055f220abc8ef25111a4f86c097d6acd7216dd5524b741fa076ad494153a902924a2c1c7069ec18b9cc0a6ea153e13794efb3ea6bc59fbfdf078426936a015513b22107e00d667a2b2d38e958d4187265b4d314a8286d739e6528c67a5dc3336bab5e13639be3c778cef252988d0deeca9277f274e1d874e0d9a8a7cf47a2c4b26fc83263bc1715cacf6ddd6be5285045e2f741740bc301cad299bb3205ef1df3829fcd551336e755dacd79de3cbedd7402141b4ab62c69b5d8b8332ea975212be51d704d5af58c642cd9b0f714de8146a3b948ac1eab527cff697366cec57015ea80bff674d553e9500e106f3f0b5a2a730ac73a73749670b1431cd6e980c8819be22f8c8828ccd85b2180e5f06f52875b385bce0b4b4f84d57c2bddbb7fcedc77bfdc13eff146152ac972632beb1ab480339418c94061a97b536cada93c6d38288494429af15d79dce3f2f19d167519b7caf51ae09f4db9f22f2cbc32bcf298b5b380b979ddf4cbf6dbeca1b1f999ecb760cdadd2d65e57943223c3e7e639c878829460f8075468cde04f273a4733058a43925a7bbaa51f48b7348d08f8cb8b029802b7feacd806e995652c273b254d98890c250147f67a1d93ed0a0d6b6d568efe39caa94fea1c13e89ace0a13be12c9b1ab0547d8466bb7ccb5299b185df33661a2a3ba1ee5fdd51df8271e6bdbbc9bf6bc4d6dac72bfd7660de016fa54a2ad62ccf26ab1af3be686221bcb6cfc6e6e2400266725c4cbc0fd2de40c657233a59859d2a488b0a35a14e3c32f9dedbae230c4e2182d0c69cd28c4d3aea6188a65e957d01f500fa2f681b640db09c062f03aa14b036ca21ba48c59a125abf5c636016e9d704cbda9e63cbcb84404167879a1cf78e429f015d885fac562e81d24edcb2860a12e7ddcba2b0b071d4382b640df76b2642bcd0a00a3e1d3473f8bebfcaebd8c545e77c1eb8093e5573b04702cc1dda4201c60a5329da14ae96847bb659a7e6da4679a9569b6b06c95cb859558e634bf19fe1ed62a54c657671bd67fd51936efe3a108d9e9c0a1cced06ec332c3a57aad5dae9e486150abe8319111ea5e4cf7556beeeedf23e31012d642629c09b40a3f850f27293e6e3436c5e65574bc3e44895901b50917ffbd63b501c0207eb4f73719bf9b73bb4376450323f97bde18dcf0e0488b5d4d8b7ce2407b2845a297d123dd3f342d3325f9f001de263e9518c55c4948e8878e5a2db74c26ccb62f5b7f5d20a5a4122fcc39cd8f27cbf591ed916470e0ac4748dc6bb06d39676f9e7c5115da3e97de76492f5b84ff27a8e9e939ee1cea47b7d3540e73b5f3a9aa0555a68d67668637f1e314a56ec96c89f2fb6ec8cb9acb9b00a5f9f49002e4d804a9c022436245a89c4be6673359704786dcdb4e7993661b4c9680869736112c1d6635d79f65eeceaeeb447b034aa818ccc1806727283e12ddee57102867739824ded2365d713babf510d328e270ea7a41fab09655de60a567b81ebd5629cf88e48bf9ba32ba1b899f759483b24fd223a65fe7db8cdf04a4be5a9e670b94a323f6a288e437b4be43d5ffcbab9601a5faf30d97c15dc2e4a5501fbf4558adf56f851279406ee3674552bda83973496f583cd5d78018b5ef617a9a75e1fb3d584cd5559ea1430fb4554fccf06114c8e6b73cc0503a985e75eaffda601fbe32f09f42222c4059b0bfa5151651b0bf2afa5a7e42c86ee1a3e801038ab6b9e9812867f96c9dfc694b5aebe7ab54e2a463a3457c688af1d597091fd9cfade9928332df28268904d7d0b4f525bbce076b4ff8c4a56bc86001fa08864a070598d2beb086def1a437949b89a30065b5fef93d2585e95ab5a17eccceba1fe8c6b8b9a751cb751fe2ea944686a44e25f7a3931e46923b624696cc9454968ff478048ebd39169f3246f854e49aa36d422996044b37432ec6506b72cb4b2f260523747555811ab50902d3a81d2153abf948d2247982ac0a93f2493f7a1234d3c9fd981fb7acc5f4a6df411937ccf70e30a5e8cddc2de45268d1365d46210d8ee5f2197f31b26b30e2fec5b2ff3f880e0a700b5158742ceab86fd877f09e3f19ed2e86b7e6c950c32ac7cb6c9219ca808749f440cd65ad54d06326b7f37dee21d79c5f25e5087907532c6cb850d07b710eeb094ac18a55b1a30091a634dc2f18b354eed9cc7ef8125cc3c8ecfedc768d44ed9a12cb891c3d79dff09f4dd4c631ed93d526993a62706cfc75ad96c1cf0cf58f3af112f2a504850ca3eb90cc5dfcdac26d6bad7521beb9ab44c8ff33522987c4560555a9232e315f6de0ff9de916fef7253f399e5092cbc65ec525c2d020a9eaaf4a40f2eb28afc5e4def45c5d5bc5181ed56bd127924e497dc6ba3799e6bb07d5fcfa3790925e734ddbcf85089e3f56f1d5088119b73af7730f563a80af5dc907ca6eb45f831753a00ea9eeefc9575ad3c344a8695fdd6f9afe27450bfadd55c09a30c70f21c96dcfa24f073081bbdb765339eb6c721320967ee8c7e30f139d2c4fbe6ce202544bbbd25184937c10cfb6b55c32f7cc403d7edf747b04b9649490d9699fad8b5067897e9fea993b6f4df1ebee9a8fc9dc159ab64ea8e67d63c05bb1eea5899ffe556fa2b422039315b5f6cc5c37a94566a564230e83bd25b5ac6dd94fb60c466001e7958b5baf507698341e836c509e34079e437ec1bfe5e575d6e1e8dd211d6eb3e8c7077ad643c7b00a979935856715792c27d568b3a7d0ba155f74920fed3fdaa529e847ecb091d5e917dcd60d096c2a298b432038a862403bf2d408e601ea2f56ca9ee783b1cb5eaaba6e3e419318d0bd450eea3f8c21504cad227aaa2dbebfcec8799e3f5c80f102ec00389b20ea4a562a340d42260262e8a592d909f87062dead567f7478e73eab50d1fd0fa197284a62aa09d523b4734bdb29cbade33bb4b7b79b36d773c08cb075c09056ea5a92094804057c9829a9080107446fe157ebb81db2194f68f6932a7e79fb381a6886eedcf507af1b88a9092d98ab0746bfad6d908c5338e87b8e77969b4bc724f9e98a891d3b95f134e1b1960944136024c707de42ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c18045da2868ebf6d581bd4c299b8f29"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
