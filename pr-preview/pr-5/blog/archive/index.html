<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d1ed94e3bf828aa5509fa0c1f60d0c1248d0ab56deaee0dad15857ffa43dcd573f166ff3127ceef98216a0ed6f118afa55c4c66fcba9763763c92e4c031b5581c8071449822748f5e05bbfca59dd1e21ff68be348fc71d7ce0b6af9a13eb91759e113864f4ca8b3cbe31908ed0ee73910e35ecc639a15f27c5ec04f349b308e044c31c879265cb62b55242d08d0cfa1dd2984d88c4ed1bcbdc0445c6228122427df840e079d6bada9206f53c93882255c45cbda315d37a5e288f34c8fbbdb8b8f797354c8d2bb7376b022628de999fee80dd24ba75d4afb8ea8bbf29b74a73c3f1906c360b746585b288322d2b61c6798aba4eafde934164e516ab47fe0d086c93ec9567dac94d8fc41968057423212e74e3fe780c1d2e198e7a93f59dcf0378eeff82a356ba07fc2d485e3526aee49f524c78eeab0dc8021ffd3ea4c28229bfa281eccc426d2609f4f379b7d653f053b4ce17e79b556517841b7d185cb46565fcb14b7f24f1bf012b97a3bfb72d832f7a92b69c8b33e8a769b1e0778aca08d5909ca48545613a46c89cef8fe9ae4a1a23909ac43ef0be54414d041c83426f93ac7a258bdf6c96f0d1874431e4b96bde7f51c9a545d8fb6b5961d28819059bf5b84f39301c19e713f5b5db3c5cd29bee9616ec630d034bf000411113e80824b8d8c8ee735fe59d425b3f4c37aa7ffce0aa300c6ea6d6dbd7bf9bb6c22f5b36c5d89d5a2726f9966f9fbc00569606ecd14e69803c346fd3bc01e1e01b46a79bb9ba08aed735e1b90972a9dd66b04db32c487e48ad1b085e75a41048fb0373d991d0bb600f7a470a3854d552449772f3bec6081cb482941806f9957a40c121e96fd9606d842893dc381752f6fa867d5aeffc4d08958ae6957abe69238d1d8476b7d01b1a1d3c2deba03541825db40ea1a5949382485b56bd2c2ca91e7b02d905bbc30809ccfa9fba52d9c330765f0e6dee1c7bac7017b94b4ec8da34e57d5825391410dd81d94792a47f94a70137034bec5fbfce95926f11bc12049a30f3a2772a8c895894cc4e1779629879df06d341ee9b74a0394929f8559d1e49dec99673cd917ebe77612dcc7107da66f6679049f2b3586f6e43afaad9e5a5d61e7ea6354f9f4f2b4ca82a3333ad06bc6d82a7f550e8cfbddb70d1d8808af5b07a908b15ed545a3b539cd23f118b092d8141883754cd6b9f0b2aef6bd4f82ee42153fb4757db7fd3aa4d49ba69b5f420b0f1d9ced7b5bfa96a20c02b7fb451450e3f72d1d2885f94bf6187f73031fd280c312733949f22fb9e13a82cc6a15a5ef2237f8e0069fe691b604b791bf204d5df2774d5bddfa0cb98103068b7c8fd7ed3b0203744a023df5dae152553b1cbea28f54c7a5997e9e1c3ae546be98c294b1c9f4d262f9987d3f43dc0bc5184bd8a3bd3d4ba36b042a7b37d7b9df6891ad2556f76aaff5e2c13a3ec5c3b524548b2f8a5de49749c5ff57b16f9d14e3b8fc9aed129ed38f71b8690661d8f1ac883372c4f5f18ec2ff426511fcbfb1b79b7e913e190b77680dfb880b05cd629cc436b3ce54d1f05411017391d19f4769e2e56f41676486a790bfc277d6985c0198d5c8cc79f8a27cddf5e1dae031bbfcccb1397050b4ac75e85a65a0b1893805fd239685137a12307134f80355e1600781c55f50b46b6b3506794f87d060781ca305d174b84e0f3e9245dc7e635a94f0f4134acff62ad91b933e50d2d1e98a13f0083cc47fdcf25a387fc273287d1c0e0f778309b798092f225578a14a34f35a8f227a7fcc65ab64f2a74f3a2cc3d29966887deb5e1bace8e623084fd460f4df90d16027c82e143c00901adae834966604cc31728e30e2d9e66f5eb152ef5b916dc65f3c2e31f3db0fb1bcf90c2581b5d407e47bba35ccbfd8963818f69c85ece5006159921d339a4cca9cd97826ecc8f20ac6a827ca0d6e706665223921283e3d1cd0b9981d5f48081412bb9e8cc7ebed145270403ce485ee0c38444b26c3bf0f8adfd1bbd13df07f87b3d9b926c2b2addf13892467a6c90cc0aa350a4eea073612d361bfce90f08f60bbaefc19499afc7cbacf026a2c92b7da09dd5cb5c1dbbe06526b16fb187036460b989435f9f80f20851a0555ed845ec792e3a9f17bbc7e6e43851981813ce4ce69a483dc585165cbdfe84a573b2fbfecc300fe5072b6061c926b7921cdf93e07d0e82a226dec0bbe1af4004e39de6cd36918ef3eeb5d734f10f86ceb3c2a9c1bb5fef5e8a07b21a1c932dbae6cc27f7dfc18cf0af1a4d0352b679a2d41cd7fad36fddc3dd6752a9b8ab4b486ce3a880baffb59e48a7369e11d4ddb1afa881f2d16725a02d2277241289bf99ecfd3e315d377d8a5ca8dd7ac49991ea1811bf0dd260cf34792e092c98c10f21cc0da17f5cdd22bd3b24575ba4fe81d15eae174efba3c47f06445961269965b63d49b3da788ee7fb505af7a1c6fe037ea45293aaf1cb6e63d0291452ff1d7d07b8b6054540a962384603ae2c9a95dfa92fec5b52413ee7b3a326f222e34b13053fcb8cb99560f52439d14c63738dd7357140adeaaad00ad67e685dec9f2889044994e3d75b580bb40109aba2d15e5a7d353dd8630b2177fa098a36cd36597c532734ad58f83e59b89cf372fa3463733e5dc4e5e1a0dd73822b527fcf107f639b8579585157f0ef90d63ae2de8730476c6cc21b29b9199bb3293c7722d57894966bdd6640aa314cb621cf7b895bbb24132cbc0d85482421b98b3440d45efa144e434eec98b44ce3f99d5ac1c6b7830f9aa80f4f32da8e3508f547701acad7b7e5fb74b52133858dd5579c463e1504b9f2d6c9dd7bd6a5720b00c9cf932bfbf1347c1f8f84a6f44398f53e7fec5ba689d37b879bd92b9b04538763120875a051741e0556fc218b78eac7c8978084630550603920ccd0d48439ab7c8927c5654ec39cea16e40120d81d5bfd9e231cd139896b78de7640ba49268b368ac542d5a2d9dbdf63381d1125c88520204dd1e097597ed8a63ef1f5c28303c9bf937019ad2fa52e45ae739e52f0e02d095dcf6bdbecbda928836ae320feb70ac35390cd0c0e2bd46d34ca9b1b6166898807f33a377a4d9f442b14867065ee1a818f24512d4bd2e43f4dbf2efe1329505d5bc09cc53ca29760a85682615ce734abbfe34e00f17b208c0a3347b776efed73dcff737bc4b4f128b6242e3ece4f05c1ad5295d573e51cf78f52c89143a108c708342c1fe030fe920f65bcb622902798858065482f862bde6c80368fa73c0c49c659fe70cd084d7fed462dc3a49db5a495a2d843de466f18bfa2790b133bae5a68bc98cd7b0a83e61f8b5e3adf31d9e378ae161ce6bbf7ad9b68fa395d5190101b172d351f0870059294eafacba77881550f4aa18fd8e3fc3f9fcd335332b1f83ed9fdf6aaf6114e0aa3d523aee40b7f0ff401552cb91eee971595888570a8513fde3e6196f59fd8cb9969afa7395d6ec43ee2e164625b4b59418fbe92535a7c6b6c2883d7e6cc597c5c913f13b7cbdf0e782a0afd0eb59a2a337fbd71d6a0e2d3c18a53adec5679778ea224cbfcc3b8ab3338ac0251f3404782a6c24dd88bae1e150d9001544b57dbdb37ff9605b31761818e8b61a3bd98053481e333e3337c4281e797af1a7a1766ab51e505e7a5b22a1ebae6ce1da3bfbd79fdc28cb12080f34e3374a1703c6ce36a319907d9339860d8e8bb23a9cc95ac26f105dffb91278bcc27e27a6865447908988a02ad761f72e4a0d7120e467c513855fba7d69c3893a39e928fc70b499cb11a380e4aae89944b2bf1b46e37c75d38942b84e9a00ec69a8fcc8cb95fe5c28d308309db08292156800900dcfa82986b37b002d963d6bb621ce886345426f8ce1716c03990ad9354e11c0b4a725dbfc77026dfe968e1a75dab1d3e192f90d0b1381984e41e35dae90d4b341457f879d7df9fa07332807447bfd6ac4a25b04b9f5f4a92f66f972fb294e88896daf1b2622cacffe44aae9ae3e5921561c1206cf59ba822a8ef8113fa5549c4afa38a7f2f0de916654e4bd2163ad63beba9cd6460ed65b347fcf6d8cc64c4a385d8ac73f6e8edc81cdaaa8f80e305bc3c38809fd92dfd32da967a3b9557ed786ea00bd8675f58a6faef7d36f05647daf0ceb0b232fdabdaf74c0dbc9a93de95c143cf2285d0fadb7da04a24889d0f7c9962f2d6fa937779f6cc2ff6f65e9c1055bb5176ea7ac8f04552b4340551da30431f5588ade49b19686952e70fc0b654f5e4f58dac3352d640a7b8dc5426abd370cc9bff73cc7efac11a581c3cd24e65be8e9d40d72fdefc6e796c86bf77afb9102db761f7f28a3ef8c2edc92ecac83a5bef4b4be8427c4997a0b001793fa224cb7fedbda52ab3348536de34257b0ef63d8a0894904a253c8b4874734d58392ab285b4160ba03c013b2bd8c04562f3932dc1d2c813be5ecaf5f9d98ad95d49087b431605b3a38f85e5f9c7c9ce39c963d562684e954b71cb3a95cb61fa07c5e06f0e0ba7f54e82f39f8054d8280c8a7be3d16320fef95286c12b01a14aa4426f73e16a93e61211d67ec139f0227f685a62eae2c09c359ec8ab1218395e833c77d0f31b2bdaf85ce221e134d1bca812a88b13eb534a8dfe5af9b8e1e8c5f9ad3ae373fd424428bbb4fc1dbed14b0d54f6d5a3aa4c66e65423501b75e0b21e38966fa8feae0d3147344c347d0a5618e0578a87582d7eab4a7caf5936f47ad4940805ad1292a3323ba51e23ab5277f078d44219da70632fc6fe395f7e051d32e19cb1cd3f9e218508c752c782cdc0dcb5aaf023dd41a000ec502f33516945f19e3b63af7ff1319ba308d28f64dd512f876249b6be5cc8cfbddb7c34a3cf22478b776984a9ba0d8d2250958ec232f8f8c279d966b6d961f42c9c3c31a12c94d70d4a5859864b70baea556de811a300126d4a9bb6e4eefb5a3255b4895dc58e8a0d6d3e70f2fe658fb44963af9ed68ab6d878fbaa9b768a86ed76d8474c1646d20e86e971cc6bd67f983d8add44723df15534aa5dfe9ce91dd203f4537e08c8eab582e55ea25fa5563fd36777fdf9cd5ea51fd42dd9983dc41b8ffa085cfbf65264b3d09012bbe33ee32cd5adf8af848248ceda4f6378bb9c0df6ce3439f1b34205122d6392faeb09e1f4191b6c978a1a859c66feef2ef90f1185c2f17fe639d73a43e2dedd25f60141fe6b15d7062c9d9572575f87c20168103f9784a9fffda50f7a428e05a8af4c2e8fe03ee35ead33b20f6efac2a341631b891963665cb2b543e3d509696af100f626440880ed3826fc409dd1b88c6ed7d7900b91eb94cae1ece28214a757871a76e392b3751c68d869b164fa7561d6843e7e45ae3793ea8223752d30ed51dc15a9dde21eaf92d8ff838e3dfa49b3ead58509acb173c4fc08ac8ec4f3712586d35e5c43f7f65ed10cd63536ad8a1abf131efb5b93dcd92d094b7e9e231fe1670908cc93fc1863398e82efa50a0012b7e1a612a30fafb38c95881896e43884825f1f228d33b91b7edd263d5c76fd7b30954ca52605ff63066c97ff72d4e27f0e78d1ba2ccbddfdf693fae3b1052ffc51a70eeddfbfea074863e3a894a6e623389ff7e24af026b37bfcfaee63308f2aa7fc7dcba31465ccd7964d1319d87c7db9ec6399ee2aa624530ed1a4181b3f5d1b3ee49f046090960b4d92255f6fb375a2558cdfc91981a009e165f8783b1a43aa31e04c4b11f2334bda44a834f3c4a8b974b470f836b863bf304063915b048713236a7c6fbff13fb1e0ff41b274fe5c649c2dca278ab820007f3a0d1b8673d8da0d02a37ab6c089fa26a055f3089f6005fd48f2b63f524f67b59fb9daf29291434a21933aacee1f7f3fe3f0820263e34e0bb8cc12b4ffd292e6411624197779198b48a27ab5d0de528c7419f7d9bbd47111d31de530f089d4da6f56371c641b3a3e17c8cd26538de6171a2a06f8cc7f5bcc0dcf500f5d7bbdd7e04625c57e03d66457ca1b5e7d4db8bc40ddd046c3b5d9cf1f2dbcd6bce278a70cec98547511ba87ff1774161f9a7e3ad7589bb12b6e0be33b1bf4bce7a1d0c57e8a3af79b59d8f6ff6e79c956f45e3a51d7f4ce78eb815f656d7316bce2db219cc3f70d2a6f123bd19eee56861551ec0f2175842df79308af1755adcfe46f9246d885a1c4c3d04838bf5989935d96c048c4c640a9f98dc7a8ce464a7dd285c10f38ce7bdaf6ae6213897268dfe8bd95c9abcd49febdceecf8fa5f3f5b6244d44c8170cf24fafd3f03d94b13490d9aaedc7feb5642b21896ccbefbff041cbdbbae5f0d5954c1f75e0a2c26f4131ce68b51badd0a651b7b643383cf83e2a9d3bdaebff2dab70ce4c896212569f1bdab2abd70786098d9b4243610ec21bd34f8842a0a494c3c7c8004cd10461150d41dc4cd92bea7699c4393fa70ea3a2613074e3686fb59db5d8bccff60b1d05093d3c57c4521dce651d68357c0dc9b8c4081f209d0aa8176b92367fa45d043787962d60c937d2d0d943de1c0a1b26df7a1c7495d629b6d4fb9034e339f5b8c330e499b0dcad75c80123e8870f14a175ba1885d7fa9b7a38d647cf644b294e8320b5fb2a339d0f3256bd993db7ed550fe509ad20bac660de4b3d3613df3d4fa7ff8603936a56bb4f33990c6eaa956ee174aa2711b3200c757831f5008efb53fb0ba1bdea17e50b8e57a41b49ec742b05718519deba78c54d3f25335f9ea828e93538347d53b3e1ee200b3a5bfdb380d09c61b40c799f01485345b3f7a661e4463d31a025f02e4bc93679dc0c4903a504d6122fdec73324cf18a4b0a501563385e15469fe73749180794265fe621c0534768c84b3233577bf20ea1341738491e9a43e96036c2e8478c398acde4fb74038edcbc3ed1d0f04a3f9b2ba7d01cd394cd85fb0e4233770da6121e5f21518c5b6043825ee8c200f5fdebf2c1204158379195f4158740227297fdc04a030f1a33346837d6371bed39b8651755de0082729c8bea147c0a638765dcee38532312e7a8b9a6cbc366d65887c27459c668259cfbd8aa4649216a42a44288490a5795aea2a0ebe0589f748e5c2dcaf09ff1ab0474b6337e11f482b12cdccf7e783216bf57c122ed57e05dcdab43a97b16d39501cc35f405a351165a069400e1ddc1b7623febdfbda2cf38da158d661f0d64416407becf14b00c68ae7a320714405eccb4f16e9d30c1dea90ffda90b674233f337d1d4fbd88f21ce234cbf844c4d329c455092e560a5e2a6f49ac792dc3d0cc81e11c598c19049f34b7b5f31fc0e19dc7768037751be235477470620dbdf7424e5e8c43703256e8b831bc82f8b6a3670668990046335b1876dbbc7fe9e882f5732c4416191027529b28916670bfc8ad8cb4a4242f5ff7f93f095de9b61298bcaa66a302df72ffcfecb3b605b9bc9e904360ef50f914f5518f50118914af13efb5e85859083efb623a42e345673484461e795e37d87ed1ba382b69465915b0b5af50bfc923a2fb3bcd5e7473d66cde8e844cfea20263d354c1d6357d8b939a05588d0b439f0b4f9999ad42de05f0b42d874b4a1cf763eccd54891517e432d701ca350e285d56aebd0654879192d6c0ce2950ad12c35a104fe6bb9ee8a79227d03de00942eb6a29f4579912ba898ebdeb701a8d8c37f3fa755a15d71eea59b15329b924f1ff48a67c777a21d7c6a19e8f93eee0ed1f5d207bba1399e75685a242ee7bb2252b15b195e9e848259e8b81eb77bd3a9c332de9bc6b7e096154c8399fd88de0b405561497a214dd5a4d8c6f025562ee0b70bab096281eca9e3b6790be9c86ca0b988f1cbfc4d080c61540e2c5c38ebe97dc307e93eb89d40f783d024ff77e092925dd1724032a789e67bc438a3e6a3178f5942a26d4540728f80d2067e9ccf2e8a4433a9cbde7c1fc7e2d79fce522d94727b0b9376fb671d9618cada6eed7d8121f9a579fc283257a806d781df8d29022f601bfc7a1b0cc86b0dac94de74193f72d4bc673960708ecbe0c5ae23b050676d5b552dff5c15e67d2f9d992e19b8f9e0ac24db414c0cd2f92220369ae7faac022164d2122959fe6793257f740e3edccf3f18faeded8d45eef71c70a06a31fe30030baae6c5f9a2812aaf18d2228608d7a068bd537961060ae88852611bc79195b14abceb52123b776f6262c3c8b6154176db200b0d64cd1624bff1f4ac5f434724ac75a228ca9d75ac8253d3101959756a79040e0e9f74845695b826f6f9e2ecf8b83c3fe8b6386943906528eb433858bba90b7c36a8bbbc4e73d509a93b76c877a353362fee3c2d66b2cbd844edfe21321a8d8f5d273e5c1c817d42821968a479859b8fbd64b371a7a1979a1ff5b5f0d35b2043398a619db0f79cec02cedd055ec2e15166d7fcc013fa653cd7a13fdd6845d6612f1be4feb5239df412cc9ee2f0bd4e52d0671fb7c2ffe9593b8db9415bed6a8143b73bac9c876fe5be2e83c678e340cf73bd8d14467f73bee0d861ad79a5108b1300d58d1fc0f9798700eeae77e9051f2315ad484f08fc6b58ffd65f2fb13f76b86b253d290f88fd7f2654f5e9ced6849584bb3327e27817bbf7b09ae04f5163bd6feaaa484597217ff3c3bc04f234165b3de581abd0eda3ea9e90e9e3ef846d39d82b5bf043c6f4abadde0ff7476bf7505461b18a2a613b31c6ee103c3b887f0750241467831ba52973de14bcd6572e6355ef9663e9e1c8306947c5a92284b1b0b2640dfb29d37e827e29f1d7e6d9394059c59d0812c0ff1af76d4ee40dad30d155cd431ac4b1c8c30171d4810b0c1a27de56cb962c994e38c499ebaafa8030bc66c950a6cfe779e0d8d70c9158eece71deb1055324ced90784ab4cfb9c8218b82179954df65200a0541c5693d4e343ded787e7df9c597e1c8637038d49cf8caa1ac3e8309c00b3f8baedb3c1e2436cc52bc0fb9afeb154e15e80f48fedb5dc21ccba4533a8a46354f250501e07eb6e4a2311c962d0d1306d9766006eb4cbb3a28c28ca32927b209ba1d1f9128ae279053a590cb2e026012a6d5cbdfb3365a4c5ce38b7bcdfe13dba34eafa0ebc1a7b31b0d1ecae7804d2f11c2482e16dfb89a764458ac2145f7e2340cf2b7b01149c88daab76383091e49eda109d5086a5be5486b53cf65b07b978f2c67bdb7065adef0c3e2d2df60d475bc3220f10a621231b6f6d3820486aaa56e067b8dfb20d126e94da7c98cfa614ef971cd8aec400319fd1cfac0cfb2fe1a27d3df6dfa364f4b6f4ffa27b2232cc397c947cd2f7690a25274a3f0004f3a2696e9da7bb7f5b69947dd1e5aeeb8310c140e3c75b380f4b40b77added581954a2b0123f47698461cc1d226a53c14c26b487131ef79c80472a61db4365c98e96322961fce26cf8c5a7a46d3023ae2609a30b6dfea5be7495280d9ad857467bca4921179019926aa90b8af9f91c1015c8faf4b8f723f4f5c1f8f7a6a4e792a3f5e03b663df988ab080b95b2a67ef152385981aed271d757629f1915f3ad9f8ada0c22d6f2a5097e2e75ca71fc6eadd37e5dbb029c47c05da1b3c64c8c0a9a7921c5a87b7f3a1ac7f7617d185fb3025b42196c918f9daf3fe5b4a63cde738ed5c4e6d9f888d4bb348fe045416bccdf3e39131d58355e48c0c8989f04192c45bbf8379f25205a1617b57434be591614322ae0291b2f3bf09773bd4a0ae7497655cd8e6d8ae9e485f01ace2a2f7138c9d267c3dc1749b44ee04cfc02a4404697ac76cbf6578e9d20f1d914351a69b8c72cd1363cab2c1d83f39a08b0530df2d702143059a212270d72c800aa639d9a646a83a9ddba08a47a3aecdd3132e0fec5337af387c2e0bb95f7d67ed74aaaebbb92c10f853e6b10afa8f1627d87d8e1310c90dd77ade2759e1dfeaa763e6e7aadc68564f9d77d0d6c6c7257d45b67d23419c6fa5c6d69df507b4b7c6e39d553dcad79d9070b65b019a5c8fdb5613be4bcef40f0536b7ab7d3488ebf219768406f99896466ce5c12389a953ff42350f127b0cc11424697ac7994060e1783e08e9f19f9a8e837dfdf1719e1c9a2845d5e86f50e862753cbaff62b2ac17027bc6c41dcaf4e8b4cafa096bbb1df1b29ef85119e6055185af30f892b6f1fd58157d734e7e8daa68b54ae55fbadeab9c81ae2b0e7c03febb2b192f09f500dea51e5a856cad621d3a35ad5c171d1e291b3a98738fd4828f61f6cc4f22a0b34cb6d6de234e3410c2c6ce33750ab0fe6f37dbfbee586ca24540f20646edd33ca9e0031a89889f54d4594c717b5deb079e35ede30cb012e6ef57e549c1efc03a3a6c8e402f6821f791a1aaf76c9d98dd7ac02af40d3799e3f3625f8ee9733db496030b1f9e2ec11e596f951505890812d78ec9269d2f48d2f0010a35c840e590e7125a49c5638ecf96c3d58310dc4443a4daae64c3251e7e87acb59f89ccf7cf36b0c9c4d8e6cba24b0021e5f47cba300cf008f0c0cf94da9f7cd38d997db4774af28507639d9f58b5812a53b8fd532a63734fc2ba121b80250e9f99f66456a8e76cde63d6e81d4733f9666c9182d9aca0cd422d777a33c4b21974aca9ed0b328db3cf5bcc74f2f459bd46cde6b69bf12ca8eb8cb4dbcf70cc8f70a9eb801dc2c2d47bda7e44f9e81dc7564b3abf5c49f20fc5ac03b1fbc40c8363cff2e2bb9306a4b75d5ee76fa539fa6f78c8b4950fba7cef6d58e4032024f054ea02995a6c8bbda782cb86321b6a66be3ba1d028b7bf8638f348a27929158ef10baec87c2207277bbc670e9b860150b669eba01784bcba99df284d15a672dc2dcba5471c290b2a5ce3a1a6b3ffb76ed03d0a6390b407e295a372e954f8ca0459e9eef6ccd91ad73ed8cf1c6b8195b0d578479c73f082429a32939d934a0e9bbcdc094201c01ba32b230d6a27902c533c94af31fdd93c74682ebc6261a7801abcb4da4e86f8d56d3bf576967857e63ab4abcddb27de3675ad4de25219b2221bfd8b1244de603d1dc21e57759bc55f061e94cf0827d88541530174ad5558db62917282849dda9a58917547da0aecaa30ecb5bd5c272e8db9237a50a78f6444703ec24e5f2a58b7b23d97e459eb4cd5341d87608f9c3d32f39f776a3138e3744b0ab366ca4f7d775a0220963f1031d631cd93d0ed597932c5d2cd9087ebdf97155d0629dd797b307cebcc67485ec4165985aa421281d453a2de31cb4c9fdc341d8df9490d7bfecb9f0deb92c7e9d578a1dc61ad26735b4c4d1703fa8e50f3b9a7c6492c67bdbd77821719b1731c8d6ce35fdba35814aa5b41e94959c97a0b708dc90bf54634689ebc12b4b8155e34d4c06e3f42310717a119056cd269cb4e49f651b1e798b763b5f69aeb6c6dcbc58a19ac555c2f1ee3927744215f78efb808506ff6a8dc1e1b7ed9fbbcfda8eee4b45a41c641083a0b6a0f1c31fe62e6ba35cd07ad1e06e316d37de6c09b55a36d7fafe1ea23b5fee0bad1babd285ad1c5cd80b92c7d4779afc969325b6c6120f137ebf0e477c01a9b91b6d8253dc0dff684bb594c35a6865870f89c934f0356a64f91ad25a77eec867604f8ecf3629a412b2a3434fdc68f685f8028fab12577f2072d98f123677f7bf67a70ca9a0b6f60cf24e571d5193a4c49a6d7ef052d15c1b724c273f59bfec06a8f1a3dc5d6d6af44aae64071d9874439a0a36ebe664948d0e58cfce85e51d0271ab90cd1f127e536c3a68262361914288d84f58f3354e8f872838e94fd28eeb128f10d02998a88f1483252aba6f765fe41b24a9c93527fc6c245c84e96a3af079b34e0510a1083198175fc66c3badf5f07ae8343a6f28ac26137f7981a999692c166ddd7f5b6293fba21d719a0067c9295e90aa88dee2c6a17af593503bfcc9e3f5200b397eb8b1558c442cc0fdd405998cd6017524f2dfa6a22c8f4ff3b3c2bc204852cd5c5dc096c2a65c4eea6cf8becdc7427f219476c16550f32de79857dbba7c38d88200e1a9ac3fb2836a9b4cac8ec2e46075e83060bee88d831fa64f7d5c68dcb383fb83520be62880ebef54d527a5f67e30f7565c7c444dbd1b6eaff53750242d1487a1c87e0eea8bfa355c4748b514b0507680785ea4cab88930aaeadfaa5c0b89e71f7642a86a0a20dc7c0c293a32de9cae0e53729c35625d80a51c13095537003271640a3ad591afa8a6b2117cd98885828599aede2deca06a631bbd4e67af860be3d0c5110cfb540b6d9c243822d2749d03a37c63b54edf1f86194be8feb7fbb76634a5b77aa62cbb08d2aed84843f4feac6ceb3828f219fa4837c82f3010508535bcc09134604634a07d623df82895be0adc690ad81eb7c972adfba3d4d6b4c02cdd6cb492e27f99646170bffae100e8d57e42ac1bf63aa1e66d5f1acbd0270e2088c3f5067f4eaed97eb9ca02f6b28d5e2e8c22306d2e609b50c0238095332b9a829555eb4b8ab1d8ba4d943592b215afd6c38845b4b1f7caf04c8fb9cefbff9a1d093ff3e0db219d82591088a657a69c9cc1435f64274d5fd7a330e94ec49ff8cf0b418ae27a498d8721b0ff9ad11b3916a08a8c4609ceeee3ec4758648d9329773067cb453f8e0217b5cf6848c8821db1d1e0163c5419316ee87292c6eda76cdfea97d7c10923ec888886fb9cb90b1304d2d4981a5342354a8b6bef473a28bb823971d60a3298ef9c084dd88cca51dad8a15d13d468bdbae039b50f4d52e3d42854d0c25fd2a0f734a8b1a41b5073505e4f0ad989511555a0088c37b1691a00802199bc4cdc9de6e4f7cffef3b70fa6d440d42f33a4a366c624ada0f59da3042cdc9f7832f6b4ebde8b77a6262f6c9742bdb57bbabac7e6c0d9561da00b101204c4239371baec301cff74f01a17085fd387e00b4eb73eb66b8707f75e6bddb69ffe69e5abc85b495433af059f448469039f97e865e7d8e136b4d291174e97dbd85a2db7150e7ca88ae452207f5aec0be7c6f299c5cba2c3d535f077827a48ffd62361e9e097fa62a8f4a1c5c7925c336316d9483f5ae73820b7827eb03c2d050f67eba4c5cdafd4872d34645abc6fec3ad05dd6b601c52e3b978994b268751d78225aa09033239b35aba5426c2ba3dfa6b0031284d53d873a5c12e3093e77764d9e8556664ab7fde6d891a1ad2efaf954b3989f4f84ae69177c60eedd4f236a5840fa45c077849733b6bb238a66995d3bc59e69a40bebc07c56ed8c561d317c9a10ee0ce9b27d1dca47cd27e4d73fb3a80840081c19a297325bac8debd6bbd429c345f5df15b72d59c235f326ca3a7e351561fb879b26db4f0515b0323ff340b927ffac27345cbe4c3d26df2107716d8115dcb4a2d4411c575490de5ea033952c30e418c4af3f3f90b7e49754ec8f74d5e178585ba6f79116a54cbd61ad8531e261753098609b7f67f777236c1e70954b2e0ba84ab4ab85cf345061c1419ff599d296c0c2a8b448ea3a53139f7ec3d098b69ad09457f8a68bf43d6397236dc87d99c9909b18b458285a200261d7b11e154e7f75601eca1b492980a42073c87e368e321cf23ad71a726d5d4811315a8daaa28a7ceb10c03384d404a7830a62f201ba181c3a199d81f1e18ebf4c76746b3ed922789ff221058c11481ebeac28f273660ca331b90d992acefe0d0e9d23b5ff38a3d395c3e55c756d1ce7dc28c056f539c5163da60dbbee542ce3c7bfcda49f3d8175c85efbf9f368d36c90f2bbb84d8786954a61832e9f6070ac066a0e29be3926b044549bc083433ad5120c5aa7b8336aacfd856bc7aaab7b41588eedee745a4be047a55fa9313eb43414bb87d9cfd79164dcf84fafcf1f424a0b7370e013e3efb44d360442f9090d9e32e24f3a04102df037d3f5b77f8c44009a13dfedcb9fb845a7594004c4ea47c402d6922e0fa6bd158a1971c41dc9ccc2b7498a7028b42854457b95660b5b6a2c7029e5da3e1c8f48e32b94724e9ea0db41ec12e45d42231923f69587be82bcb35444c683191ca7f256ee51706663b7f8781cb8c56c862d4a592ff733133aed53a5842c86a65cf06ee18e0fcf19bc977a7c43a3cb5e6747272809aa49fd0bbd826dca34270274ef077f6fc27eb2706f0a37316e5da46d2bc96577e10b961e47a22e096ed55f4f5f5c561f743c9c1e95b0351cd8af570fc15af066d720cd2222b61f12615edf6cac61e7676a26bbb124c2d11c4d5b8229cdbeea8df908d5265d79926f53b866e81f03423084a3d9f8ed7f75c7723abfde5d4f5fe5c7bb01e79ac761421cee0d0a22cfe4025f63b725c4336c112b494f870c6b86f865163324e4b9ac21b4c0bb0b9eaff69537ce4dc0302bfdb8407c3ba49a623189436b65bae69c29618b9c90ed5866b4ee611e65359a62fa382a4d4a48cef80add19c462ca1b921d6765f64bb0ded7578d935bdb525f344f29a9c2c994c0ee4a7cb5383b23cdd3eba24d386468ccdcc1c1eed4bd9e60451e14edc789d1abcafc175e007910b4e7e7cc710898ed0f22efd08bcc8e8cf8fbeb213e94b3ee07196d32a2853fbb315cba05b5533b6c12e5148b1478508f6264f260e3afb232d37e8532e961c0d34d8e91ff254bd7a3479669de44fe14f69570990c1fa566ba9decae8599872f8e2ecc26c84236dcc757b3d286b34bb210d8be71f7f9fef0bacd46725100c27322c2fd0c9bccad02e30402f2e7a851130de6e713b38382881782806d645c9c9bc055ba73c21e5b725ed5acaf260b66d240a12a292844fc1e626c0165dea8d47373d182b08b84109127964e28a3626cdb1a71412ee958b71c93d1ae54f9efc6e6c7eb9537c24e3b5728ccea895bb1ce71ebce1512b7ec6aabf7fc783d611dd8cd98d212412015316f8470a62627ee6920f2d7b4db9d83f7deb43886456bb695ec2a10151575a437f927ded7d10be71efd4d7532472bd4b328b8b60bc2e0b11502f19ee8b1b4a735c49095e30ab3e943b2a83ac6658fd7a0d7f51f48289169895d42f23916aebd5dada227404fe32784ea5c2d7241a05560f92187d1a619badbe9e5dc994b3d308371e9b31276b4674e6e79e3c5e7d453e3d4aaf17d688acccf04825e546b52d872dde45640e979c38c1a9adb09993e157d67128ef8b6b76f640bcdc6c542cc49457043345a1d55a2d3d5dc1550196927deb7154dd30d82daf2010b6df478025a7507ab01ef726415e439e0fe00d9fb3354a20e7e868bb6415ce3b3cc994adff8fcfd67d6df6739505c200f37066b221ae3124e82de3f4f8dcadddfc575b5baa4653450298697821f916d6d72772079d79a3aafbe58d8632bff74e76e389bac91dff1ba178378667d593c64f3987dcfd6e2cbf24bd0af3a2db73f2d2048b0ba809052e698d9df6311306ebb74b072185486c9a385215fc3e079494d3da0d826eee68b428ae4443a51d805587dc66942142ae68463fb95bdc9c024238628898699da1ad2a6b501af2410ea6d9d13d8a5a9402f792db8c9881495f075459b3b7ef23cf6a44961c49458fa6d33f3eaa1eda7c5e4d96379c9c060c6a0088ddff39717d0254741369e5ca2391a0a63fb69ea415120d7f52ecf3b86a3bfd19140497cabbb363d3373ace91ba7251b704a712267eb6091686340f472f41d0ee73141684b1adb8e929b16bc13be09397d7539037df3ba45f74fad488525f92a4a4c79831498cfcf067944705ee3f74f4a917933676b0e2508951f6b9fe0204281749949ccb0fa37df95b931df84de73d8be51ae8131897d5193061e1e2633551f8e896844548d314f412eda0c3770c31e84939e84f3bcd30e3c62ca612b95b2ee572a34d50c81f014f0c1b8e794fe5d52830647fcf3179a77020e2f0b95e3feb13d5ff798153d5dcbbc448e83894d91f2075187fdb722d4cea557c7255eb284f10494691db3243a413825e0a8b2cf5f65fad7bb7ea87145e12b3523a7b8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"084efd878934c76a68eb51b34d2b9e51"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
