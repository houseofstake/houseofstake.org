<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5cba0f1a1d96a85d43d3365f40ea921ffabfcfe35d250a5a74272ae6fb1d3e93370e0e594bd6c65a6eabcb895b399495dcce5d1c22337256d907d70e8cae5e0d03eb5ee70f9313701b93609d3e999ac53bdfbe562c1c44b43feeae17be70aeaed647dfd499ea600c1e79056bdf09632bd508286f31cd32597773bc311e5f205f5c2645b6e5b2c6ba9621bd82530071a9d14fa472515c02e85d7aa3d4611d2253c6fb7e8490b5be394b1491f1d78bf63da15e44882b72f9e112933768ea4d45ae3d81da027340051a132dd6e33691a39862c0288a79e713742cc7417d438ac9fc75941925aeeceb24af3d962a0975ced85f8e814d33cd0a85adc127e53ab2fe63553b4f4c8f832a159e19bbb19ffedb05b1ab6797de24b70c7e5d959d02ef6c24106de575ea628e91f8e896f83939da35e2866f80e9cd75b62c1330a4675dfb82458a47cf7f7f943785dcaef79bec64df488b1ffc96cfd2c1267b4df81fb0a70cf668e545470cc9db252343b4694ecc0100601f1e627730f48b9e6e3f8a248c09eee1611c3e3db1838d920546ed2fb8e303ecd3a0e2ac090d226a5cec634e244a412a5d3ed73f240c2508be345a7d9e43d428f9aefe877339ab771cf6285866f6eba4e71e19d372af5d94d2f32699d320c9075c625a9eb82d15482428f2777f46a9aa2f87aa093782273f97db3e92418ef7b36d2204739e526d7a619754f5a742d0b24abe8379a71276214f3f61a0edc4620f7f6d9b55e63f543dfc109f6458e1b13010f4d3b849d7301f797beb892d93aa3df57e237071cc8ab6b9a376a133d426ae6d4169c2c265a0dd9e489159e56d66fae7d1ef87aaaaf1d9d07b9e47843917c9baedc23f1c16ddc34c1bffd537cecdbf596b2f66a1894ac68c843847b81080af64a5a580c61564b8bf41360602674fc9ff1701fe5d9e0b3bebda74abaa804bb726b61a3aea885dc4374b17f021d1a21352fa691d91cea5aa67aa0a9b3bf4fff454617e24d722fbb6a476ddcb32b8322fd8bf858c66775289a25715b2f3573223d92cadb4f444bba9e8f7f9a993ff19203ea1fd059c8bc320ed15f5c5dddd6a3312372d07dcca11b7fc38e61f87277196fdf34a2dcd621a7f1c560a8564c586ebad6902b24f3b16342bc76aa93a4701f4c0fdc7a2f1d7e900574b3b3f76c1ed113438c400e19c6d8765c4a12309556166e240452a14787e0efbd35b36916a3e612fc41c130b11bf92a638205c28482f9090e113817350dfcd90226d2af2e11caaa190cc9d0c20abb7d57522851fdb1a799e057e42b16201e346c88a9be7476dece98cde22f8d485a921e46c31085415921d049a4a0f17053fd7050edb2c5038524c5a657e1df9adc8036a7b99149fdee4ae66c136d5af7b8e30ecd355ec3369740d6c4b0e758f0b4f8c2e47052fa6ef6ec2ed7b54bac3325c4f89cf825082e648c30c46d7948d5e918fc6630ca054960ccc4cb17b47bf6b0d29629b2b578074692a9b38e2f370ba7a14ff943884fb809bf71e5f7d579e4529e9a1abfd4c117c83d5ce473d4c5c016ba0ebca45d94be57258073511fbeabfd9d6abe000d5b82eee08f25474dca0d08d1463329ae57eda2e844d94e9f46c4fe9beb4ee243f05565babc16acc13f01eb85cbfa0ab7598c7c114b449e8e47c1a551fe2be53ea8f70339a054165a832a63a8d7fd0335a8ef35de8f0a554c73afd2555b8deb86d3babe08b4980057aebaf275bf64479c6a9d523b8cfc082df69a54b9e195ecc5f310575b5e5a2186c6c7885eb9049e5ba6cd7efcc2962f722b2509cd58f6c84f954c7e85bc19ce6f5a5e7433ba8a8d05df0ca5a3264ba146f70f81287f771737828d1572791a405ab36044b871458b12348e7d60fbf1ed97b58aa2195139a8784e040efb607ca1693f385775a583d5bda686a651f6e9a1412fd9f98679bd345be604a16c3d346ebff0e06c05565069b67f4b5eee0b16e9254d5352dd409949f3f58932b174889ba8d858b259c676b3e355ecde24e37b715aa7ac9c31077efc9818e07a43865c41fc8128eaa74c015947aa368ee428b1c6b32f9c921f487d3a22e95d45984bde856c4947fa9bb3deaa2daabef91dd41d76b460bb5c94a340494c9ecd4b52b5c74264ed44eccf4ffad7805032ba6ceefcbf16052358d856d0abbec7aa24df3254cdec77acdb7d00ea48510f0f9dd163a856db623afdb1e84fa715703366f9a29cb9e93ed29072b5558de0bc1725a4e84ea70d4dd03ce3f6b2f31dda1c77af411dc187f98a9af9d713939f3439af01bf4549ac99db6c9c6df60ea9ef19d75c6ae0ca530926b9ac77e5e833709cd52e9142f82a0ee5935f94f8a15dec7aa8fe57a7165ab507d17ce26b5f9ab2e7dc6b4536c773c6f553b9c2f2a31566b387c49db806a8834aa96c15af85d16305ab2cc5b64e4471dbbd9b771cf1f1d5042cc7ccc9a47b7237da256b16264a781de776c9554e7e1fff740b99ae36a7230d2bbfbc49fc28dd3c6a51279ebe44d7e7d84d8859f4b7e338b5357807be434b17a7e29bc9eb76e5a409f4dcd085dfb5496ff77c84b14b252f96145d1ae1833fa606429994004894d5c71a1edffb5ec3f04be0ca4a01cedbd63ff511e088d35c4b67fd71e5a24847f8fb9c39100191f3e082c4ae7c1d68e448ee5ad42a87f1046fa451f3ffea7567c72960a6481ac9c8bc46b8288f6de7410867d11d45b17227b487481fa7034d48a7ac5e31d90a84b6fd52e7e9590bcd90c7d4016b286a788265887be48871afbb96169e3ad46c4472d5a8b7bb745566d56812368c400ace9d1799105d476ab909224f45560b361772f2da6a21b4a48b7e7bbfff16c135c2fa59ea715e255d9afe5f3c1d92cef7c373e736911324712f54830f70cf35abecfdfaed2b2fd9383bc1c1acbc4a4b568c7524326f16f7129033b940fba44af0a03e15b8d1e1b192d95e5e2fe259062b670eb1f5ef216c5755976dd52971adeac8e09a3d92c62648989042f9a6bae7a1323fbd1188796ab13a3ee7b67f03ef17ffe2044224a30c2a9ef06d0e28bf4faa981e134f7508ff7ae7ccdc4b275710395333109db6c3ddbf0acbed722e9fb910e58f5cae4227d2207d37f7fd6b4b97e3d91c5d5d660d1004b75aa2a67988ecb6cf43a17e0712570994e6be3ea55e4eabf265bd301a450dee2fea37c60d95b4741f79790d94bec260c3646a961218dd5d58b19b87d90a58ef6171e9b4812f00849002a66cfb9a60a666f2d9ee6d506dca4c3c8f18f39fb4022913e301ee15904e06a6c0b043bbf4a198eac26a9a059d3c82863acf434828fb62750c92324aa05bd5db28f5d29aa803f20387e136bd82d53f64c18e3d8d8137e6d50dfa42bf10d21fc6229804332e9e7b5f164de46bae57de83e882ec3d28311bdfa36c21d78a3549ab6b171b82485feccc28a1795751c07000129d1eb6dd696455f3e182ba706052b197b291fe8b56a3826a397a33c409792bb3da67eb35e61fd6c19e6f14bd01655acb55297b1aee6f13ccbe965f9d197f70672f67f4c956a64eb0e604de6b61863fd3be0e968b0621d3cb5b95185146379a2dd4da79f7cf2571176253fd9caf22408152bb85f1ed7853e0634088f44cf9f7156d8392530519b1e0ab53af36be4bcd77484cadca690d153612298839815bba8cb18f34c1a1c015bd91c3253a3e1d179c554011c28985a159c5a657dc23dbcc9cd163f91b3aedfd3ea613176e14985f3d5bbe1b697f5c05931af0197e0dbad5f4d32c05608e5dc0072c0528a6cde5f016ce3e4465360eeff0f00fffd743a3842d3c719e0b1ad477a36f830b7cf39270f121b40a2abbc170923e68ee05957d7f77fa816bda6a3797909096d802cc28524747c1aab0480478f2630e241307fedaebf77452f49be843eedb0fa025bf452d296509f143653903ea87d5afff8b6723fbaa864350b8cc3f26acb1fb489ed6ad88d14d94c97f065897ed07f83a8ad661168be24998dc30ca1be90ab6a592e062850a43d727712555efc16d35475b15240290a971de5a6c7dcb544ddc241576edffe263466f001a5cca219f4741c40b5f71fdd74bcbdacb579544cc07f896023e5b2533876dd0b9643632084d1a9969cfadd459011a013e4cdd57e0c42f83318cbc53014c17f71afabebeed120ee2ebbddb2ffd59f4c3af58937f4dd0087cb390ad6df01b6f9fc492ff98c9b3e29d5578cfcb000d09d269b31b23689b31b7ed09ccbba0dbfa866a7f61e97bde128031bbe9ccff9d7732468a012c6ffcd7171fe95efbcb56a18caa4029ceb154177f56b10c6b53e3b9bdfad898de5aac516deca14b948be0a4695e021dc309a87411e065e5fb427ba0fa87cdfdcd3b176dd75570a6998fd6b23bbe59490caba7067964a5419fba23608d2a544e6e685fc094dbea4540742b189554dfd598506359740c2638b43d2bbd4179f3f8df49eaab9fccb2bfcdfeb9e63bacd890a323e12ab036d0e8b5821a285a4f0c1f45580083012fe623e52e82bae521affa8a03a5972b95b881cfd76e38dbcf33e288cab0224432bb265875511265a4c4a91a53810d49776280afce63a4be98793ba6b6bdc1464f0f09dfb4c5046b8420c80efdd72b5c7f49dd5eb3ef29b47db4b786d1d0875c6d3754c04b2e4e9708e3cc41e28eae4152acc029c8e5538509640f2a038d7f16a048a7647ac59dd414384f306fedf96b3cd3a438becc683690c6e1433ab5e2b2c722b0673c219cffdf95f93d9ec0280a446ac59b676a3096ea07196a386466b698dbee18e6fb38dfaa35d97e94400f473cfaec3c2ec3c8fb4e50d01a9ea2c0c0e8ad76fcb1b97b624d649967e6721c0bf434784efa4cf5dcda8d6cbabdf0ef4102ee14893e442793f7b2a2aad0ce9d642177c4e19036a4d5fbbe4c9ad8fa7608a9cf95106a19156c7c85e8e9eeb51d2ce100fce999e30f062cb08327f3ec3439e3e8b833732dd78e9b7f8e0735e8106ad99ed1bfa23d77d8548a320a4f0d9ef49f16a645f0ca46ff1649cdfc7ac408c21d4c21bd5e47a5335f6b443fbc097ce94f4c810ed193ea583a62c5f17b09132db95e38122213c2ed33bfd34c6c576dd14a8710dba30ec63b326529d741fac1a1ebd57a60564bbfdf71a196c85408b476fee004273429ee298251d03e1949c180d547da2cdf4c370d8ec7ec0a1391e382eb9d7e940b46232f8c2cf9757f8abf90e1bc120ae91c035a6e473eef31902cc90740fea35c075be848f9d454e177682dd9c38c9d108062cf7119095fea12f537dd405536bdf4d76ae1af3fcbcc61db39b1065d235dc3a45fbfa8b3572c359fcdd45921fcc5419d7da3ac1b96803f770c4867af799d2336f9761c71dd050bb850d1c5ec1c88cb76cfb2f142b075a44a149ffa8e61e5f6b7fffa76b0018c89ec92828839077d24e3de7b62303c7a7b3397a2d2cc31b481234de44d925c3521d790e4bfd4ad21580cb876d798f4d63fe42f26eb6cbe17a50dd74ab85b330bfd90d6b85a0cb011c6729e0c51476bd744541f4c1cec080e1e4ee0d785c0b893eaf3f0a6e33b86b18e2f13f36a6853fc715813b4d7cc097308d309e439f8ed84b2638c19054ad0d9ea3045fb81e41af1c27933dc9639f137ecbc02ade4f35da06441185797260bc5cad2d1c46bcb271faf71db433bfee53448379391671b71094ddbc7f1fcb4f2739bac22b4f98c3abc85c85e0c1d94fb8ac429819f9325453471763cb42729df4d7f256fbfe2011a809c94f4c058a83c7a60768a4b9c74783093c19d2b6663fa3c39b481941f16dac06f1e0c6b1ea27cdc6ec8c117c057fc889c1c170dd4c29f754ed9019dbf3278e01aa5fa9ca7a419d689578a5eb9504ed22365c0bc1f006bfa8c18705130a3056f2fe6ff4cbd531e30cc91b416b115c6b9e8d1f423da2ae1324b4357cbc0ca4e8d327b3075184a91b174c7be918e7b7d945fb3e577136fd0e813d29f43e34702cb08eb23b8d7dbddb7287db6d0efd100db99d405c74e0a355b5b4bb83147bc3fc28ad58935d68968618b634f3d08879a91357e10c76de0d760b1affff177a867fe108cf73e89d0e890e53e27c2feabcb1f257f2224ef56b8895dd4c450debcddde9254cd7727f241d98c7a3778a0d2da1f3165ec62212178a0dad8c2ffd604763aa06a84d557dab29fc2ae1944326fb446dabca28f00f438deea53da1a1bef05be01695f666ce4d86a0f9b7922162e9f77d1cc64b482719e4bd65613f40e6abb6e28564db01dc866075005e6429f516e922e7dda4c958852f3771caa00245d0f16606af35d545fa575169b6b24babda3368be425f8178a194eaa09425141ba6b77b49aa58e8613a18caa8147b2ece69977a6f95765f63735155943985262329adddf2e927140319fc5b43b232d343fcabee4755a1931b34208d88914b07f9b5912ad3ae1e447dfb4c8f14689703e961bba1c351e00eb36f68eac65a9fb61c88d249688d6233ec8bc78c72063f358149e79f5656aa8076a544ee2c00db354222134afef43fed81750a02df6d4c6b335df631ec91c254f0de9660cae7e8775417dfede6a66faa4c0aa1ba4e16ba1ab2fe3466029bd88980611edfa0b0e7febac0343ea5a7cfddac969e99038a92d8a5ba579c7098b44a502fc36acfc1424e22947ec4f79994a0ee908f786b5d6b09f3a04836e659a21c82f6f1be8ee2cbbc08ff5ed59cd2f8a19a7f4940e5868af0c4a538f5222750c2e63f36fdb220052a8ad065ffd61c19c8bdb531a5805ceadcad0ff1c011c771a27ce0851dbbc649554003bcb12f3777f0fe6f526120c8ba1adef83907b18e663066c2b8a3837df5b0ec359ac4da732d0993ed7ce016551e7567d1398072c622f35a935d549953aa22d9fc26e7d5e25feed878daf03dd29763f15e814860315f1b3df8e5e134fc898e42fb55e8386946c6c7298a76d153c2d82aa66ab352d6f97bd613be79c6d5a996b94e4551710c85c25405d508dcc21841ee2f46e3fc420e8a164f8fe2f809058a381492b2e4430e5cab92841f8be5bbbe0ea4ee2d0e5f2ef29eb26bf3633d897ecdb018d4575782a1ee2f9c837d5031342ca2bf4a4c40c3fe75a842832df0f5f4b7bf50d5c1a606134a076eb34b1dcc9a92d7a1cd448e01edb441ea89042dc502462911c9dc49257aeda86c34b6b7c55c8d8ceb872270c5bb5047f5118da678ec128f53e07c5291a3cb72d40ab36fb5de809f1f0edbb294db9c603964e72b018ab46063857b2d27eb43f749471f5967071c0e04a6c236867544b51623443a5b7054753b98be91bd648b62911c65c66f304a44f6594b72312ee7fd4fbcc28f68552689499b520385c09d408d5a93888e3e0c00948ea7c09b72336c3966da8e7f3de286ff5768da5bd7b7c45950546daf26f27187f0dab00098e37f6ee48293bace4a7dc946a50c6bfdee0427eecf78b0944e487685dc88e0cf0150842900be6a1a285e105209c59def2e5da8d0ecedca7c71fe3c6fea1eeb30cbded084c3b71f376b3277de18cee1c1cd585ac11b16f2ee07d2ac151daa858247ebce2bf538288b372e9fbe83f54ce71c145bb3e943886234b68da158101a4340e4045a8809e2c41a6681eb8dde1156c4db5cfa118135ff441607b27f7a320f8ba710ff6d24b7d6656f7c68203ec18dead1fe1ff6223320685649df1d48756bb65bc12f44a7e44838afff43aaaed699574ed01203d0513485325ec3a93745f33e1f8cacfb87aaf82abd4567567e04c1af7203c1f67e2f48a14b85b19f19cc23b67a510995c42ecd91f04cfba6a392afa7d8101ebda2b92a0a060989b8ce8dca744e7360e2b95e0cc2605706e756aeeaca429e34e72655680a98dc5d2f7c5b8ef52b4afe6bf481545ff5e4939cfc79675a2328615d2ed0df8a12b18b0d60da803a608873463297ed9855608f542807f9f7d5b3c516be04e7362d356922153fca50a7e905a94024ed02846928988ec344a58288f7e778b0a416bbb5d67db5a42eabf0d127ca40c8dfb203d04892867481f40d61260a5ee51690a6c70d75d92ae5f21bf2dcb888873ada041b8c25475851d076dbd9f20ed3ecd24c73243207f4f4ee3688a29f81b5209438a0b472d39b0144f4cd4eb843bad494053a8df73976bb770ef61a9b840aa42378503d36b25097683f74af15da01428bf6b7a3cb2d120aa1f9f1d6fee66df8a9670d6001531ca7529ddd428692917264c639fcccfbbd492d8ce23030020b09c26b450c8e43dcf6d04adbf95ef9733ecfd74a2c615d49eec672c996bbc64d5a47f4ad894b647864ffe5dc4890a40a5f792c847e80cc9585e20b950c2ade4f9a2ac38dc3c8cb6b5da74d3171c9a3df14d5ea9d6cf104e32a0eef2750a4b5d41fb8cb22a2bd02e642a34a88cdac4f72c9a4223703ba1ca03607552b08ceaa1a1d3aa501ee5d336e7165bf05067d285d54ba39a57f5a3a47517c1fd6609f9c31d0b19cb88039a403545a01da9171e27304d235a44b14bb2401f4131f4f9992b2418202ca3c0e369200b2c0af62fd4ed7b1fbca331bf32f3630bb2dfc4027b39f96e23623e2e7ec546e020a27b00a77f86e9368482bd359722214f2be78ca7fe796785d48d8de189374b9a82c575e84facbc6812afa2f3c977026fddbfb2b8db88c3ff09b3e06d501af8353a1b2405c2c89fbf89d2f0b993730e4a4af9ea3110f3ffe1da682c22c17ca5570d36005ddddc81727451371b53d8a5f0dd60677c0f698aee23ff70cdcf86677169c56e89a4bb52ee67f0db86ba0aa2c2b847bbd1293e698d7602fcea785e0bc268bf0cc9ebcc4ca18c9d44735e28accadca89599da6116cb1ae5cb641ea0d401faec53f8686ab22feaa635eb29f5fc3d4785dc16e10684cda95868af9a6d2f24b50fcec5a470d1699fa199b5570611caf39dbfb152e821a1602c03b52362e86c5c36a320427fbf1ad5bf98d0c23175ef918a4846af7f4c4630a8e9d6ffbb3eb9f23dee7898040968150ee6c506842536034cbfb884b21dffa6e189eda350eafcca3f256dcdc189e7798d12edcca6acce5278c09de0ad2a69adf23e97cde7a28d8defbcbcdf6303b037272de4d25b14ebce2656ebe56219d9af9fa2b71a2b70fddd184af482ce48a7df9ac2fc68efbc4318d26332c370993a66a2df29dbaf7afd230927dc0543bf9b2fa5c797e307c2647949667b520d722c5a0263cebe1a487a4a7517df0cda76cdf4d1e5c87a812de87bef2ec87f9b1e74596869431a27dca8a2742f9c91493fc2b7d9d19767ad363fb0b6b6a08d8cb65d1401d871882eb4f5c872bd51cac197a3f49b3a6cbd6c298956205d7857117043d0f9294e087933620bb9faf6c7913bd140b7edd5f7363674b39b17f8f42ef497bb4f78687f26f9d4a955f315f40e0885afb3a053bc285c35d37c67c4e6544a396fd51b4dd7f404e2fb697875483899052d279a86aebbdae5dddbd25cfd777d07b34a1f0f57a4ca171aea03c9d4eaa5e865fb3c1440f240498ae01ad09387ebcc401d73c734be1586c6a9c8814c8acfe6b4847b4ce2796ab5d5a856e5e05ad5ae8d47218981821108e048396c24acfa7e769a4c23e9c3ea32f6fa716d249243c4e45e4810bd26b27e54777b79f66d70fcb6b838a87377c0c3cd8854c431a996848ce92d2ed845f4fee34323c09ce5e7a4a973a03e0e26067ab49cb0805543b6c32aa25d59034f8c6aa5a6e21019f8999dc6049d9698c94f4bad7b577d900c89d312c0dd21df2f7655423d0ecb92b0a4cba6dda7e5ee767387c886b0f25b032c5b68c47780488063ac057ca59e6dccb437677f36bad2d67fc62858c40eb7b0e88c50593e6519b468850d5e4f42937b1b8290d27e45687bb132f9b31a4bb511a211f40546f24c4ee25caa705cbbb58c769d34bd11cd5cb1564c6e11b7eaca672c4f8ad0aa32a7659a183a2d2a9185c84f6a1faeba9a912d8c2453c5ad985fb06e7eb9e560de824238d6e034fedcc346f46b3c38b15ff63b74a42659c9092a581083420abeef534504d05c3219de539e1a0b2353b6423d0ca6356d5740c67777a1f42d962f99860b30fe6af1a16d66d2f8000dd2b8c3b9332210678d28ebde75c3732e17d425770fb39f3752f20f2da894c1362fee94c0550a635c563819c716ccf029487c1e0536adb622375b55ba78ec0e276fb69ead86089e8124c5c952585252b51880efc8a356f57884bbdf190ff35befdbc0224b1ca8089d1f0fe35a894811d1af3b012da9f1b5f188e4781a68e5e4dce4c3206de876b7c503b666c3e36d55f3ad806e1c36c00f7519c1d99eee6a12dcf9f16f1839bf6258cfcf622c6900d07e4fe78b2dd95784c4ca09854424f60855093209431e6da36836bb6ade5651beedb871f654bccc0d104406d86391854111ea5e2809f1624ff0888dab121944c16c0452737d2c015a8ab83e7920ae578fba07166fbb58fa17fdc2a1bfc2a0d85ef571ead5152046884a024efc5e02bc5431f4d51cc3e4a54da062b0cbc7ad26c05481b32369e13e6c3e7d3b50fae3b896b8d1e34a489f9c2632cf049c09e686af4a3f22f3ac9621d3b751dbcf123cf663183dd0748567ad42220ea6419ed98862910d4c233e36fd44585a0a7b54094cb310840c6c2e3a578d370c65c32d54420808afb9a9e1f3feca04aff19316088aefab0889f42903a3c2210d145af1d36d4a6da393f5799ba81530d7aa5359f67624afcbf74cbc10de10e8112940c9a577c7a6794fb58f4881c67739773d02e3e0f59f2530a84daee8f19d0facece254ad1f7a947ee2a54a1258a8c4b935f296f5bb1db60f9d60f3ad02835e0d8e5531e5a5803fd684b10bed2a82610b5c47a70a274f86c478c03b4fdb25eff2e836aab9e5a764bb1e2d061dfe6c83ecfda80ead598120e934ed8d5827f04eb9ebc3da6d28dfeb60469e36b10cc62120092276af09122ed417dbb7b0f2c01f4ffb94dffdaa9876b7cdd4a4e37e1afa5cc04f69973e0b4cdf2bc2206443b9a41e05d9c24614ba7e3d9c05ed4916abf84614bf8029d338554699e42c0a14a7b0992a859818e39fa8ad7aa0412f306528f4cee5d3fd0a5c274c236da0229bc457dc8c4fc11479a9ac3e2e333e8a1254c0965de38117452e855e0b33f15b4f0c402c4a35ed47b935dfe078d7abf56881bf2649929179ba64e92027ebd99c4bd914dbfe38ceeebf08ba1fa4ca6478365356c811714ae10fa7e4ba5c5349bb0b17a4727c274b20e97ca81e0166486144c8464b5254635147ee8f96d7b67bda288b020635ab08a46ae27e2c94aa64c78ec561640630491c8496fa99dc3f924525ccb8215cca9a5f3e05b984cdd21070b1f2a76baf69dca161248c252cf1fd680182cfff023809293fae967ce892a59cb72a667fde61bad338aba43864eb38250371f5f36da57039299243312083bf350ee6a1ca3c9ed14a3c23b54a5062d416040cdc73366bf7ff58bd971bcaa893ac07deebf74f7751a764ef692023a5cb8ccf2b8aa175057f65debd9a00d9622e680b4195904b8200093876cabe1e2d5f8597b369c0d4ad00b69f11ec01147d55a30a1d9d66faf8d3cba621390d5a7d5fa8dd9144c52f860a8feddccdbbb792d78bd3d33a9345326e3454d274413f6192374110bd3749e5c2532b513d7da1a11a6211d132f7f207293c84f27975a12ee82244b24123c99628c242aa36d12fcebae4c2948f4b5e547adc40b7264192a1477811219e0e641a6c2622409b078d3a81f407cb2e4cecc71501760f9d5b90ed5d1958294ab1e94b0ed2c08685ca498240bdbd797b6e63376a3a213b56970de911aa029535abff1b4b853441cb05d32ebc1fa2b31f182c9033550c9e20f54521bd1e16e1f8d6ab97931c48656176d1ae19dcd8a516e5baa642672247a56b5e3620f026630e374bdd6616d00e98bc9d4f355fd8ff2af296fe93bfef700413a803d1f6fe8a590e74b1880402602ee112766ba145498f582e26606a127a7a2897016348a14457753d123ba48b66ca3b73e1c110a74a341fef62a416245719980f248ad04cbed9ab2a91b8efd4b031fcb46511e701c983ab28aea9e58ee81fe07d997559ac1053d5dd66a64247124b36293409d1ddb59bd013788bf021f0e2bc533f9b4d0f599a45714274b9c487a193dcbe3dca085579ff67b42bb7ac4e482df49051ff7dce99f323d3eb9c8854107a7d5f4c44bf2f6b496c96f9d96120e0d2913ddd6fbc2da952bae900c1e0702cad3ebed63ef40adc6bf4ac3113f07b1a2dfa4f1c0fd3506b4a8802d1954f535512bb200511f22b7014bc46250c7bb5dd4c2f50b14a991c6c3a54bb66770d124298c70c0854c66740d6310e7362d5a3ad7ceff5be3af843ad72a82c057d9ede0a74ee106b68b3af25e01c03469e064a58dab2e01ce3ba9c05c7a199a0315661eae073a6eab885ebd0641014200c3ea58dec4057345ad94c3cd83bd1d0340f2e63ef8ed54f860906f411fe0a6cfc22d1e6de2d64cbb2582a3126e8eef156b90cbe53c221ae8a0dc83edab9a18b94c9555c1a006250f551a870fa5f3e1e32c8fcef4f277b4e3a4c6a890c0dffcb8594bb56662af9e7393dc6af767d9521c71c689bb0bea7d90d4ed8c66f84e13310a531c0861c81ed6b4ed3c7ea2d9db795ae9be55aa6e82faab7c989dbf3bff64b14aa443b2351782eefcb6d37c524f62b6d0d66bac7a5a63033e2b839b1e3b0265260905f46befb75a4c9cb8fafb0c1e9c1ba322d687b415bd19153b0a55a5cc1e0aaedd025c174200c69ea1bc5bca65d5462e3faf13d0a0b822bf6d4d0fe2922e372f4f9d3f8cb241b78c11011c12f11399082521e059ed017703cc2c199e51c098edb8f309bba651a71bd8d11887f96fc35783012315079937cb9f56beaac16734f3e482c530dd5728147551c7f1e5410cfe0d70544fd05273dd5420f7897da560e445d04ed410b1727d6b5be83d124d6bf4e64870c54041ccfd1b7076ebe5d10200e61355fe29b1fd2c1d6ccbae7f8fc3766b7a95b8c6ebb25e2370d623017b08dfb00b3850d50098132b45c18ec182a2a0bc34fd2ceb40120d42a1cca42305887c1badfe2d95beb99f3c496fe39f9a3d0eba6d8f705b720cfe9d21dacefcbb19d90a702d1c3c8a8907753cf8ac51bd751c0813c4fa62f961bd358e799dd65431ba0d817ee4be51d7fba7bd101e539d9d228aa2c22265cb372064bd66acd9b9a60aed5f8f984f3643cac68dd8caac0aae4794539ced84bba7f584471bef53244c72c77d2e8a2ea8e9041e10fdec4112f34ef321a50027cae8e986d73cb2c2f234b4810a1ab2b9590d10cb5050c50b60ed2749115de02705e1871e14ab6a29723599bcba4ec1c72abc4cb1113a43f7335b95c0ed98a015798d332c117078c76eec670d1190b89a05d04fa485bfab1b14cbb3b881b21fdacdd1cce6d8e1993f08e42808cba5fe7d7db204706df368a34cc8e985d7dc898ccc852e6a42789a7b74ef7a666c6597bc66648f8b08c899fb7a01295c0edf625439077fd6ec32858faf2a10dde7d20e4a2221a82f331ffc53595710ebfa95782a2e3d1ce388b79d4480d439dacb2f0eae3987be1792a2c2f4ac8cee63fe2c8b3ea9f90b6321ce4fed49fd90e6cd15ab21fe7d5175ea9189330cffc7876079b4faece3a64b7d4d2b25ba6c78c4252a7dbe9ca686ab1e0fec26fd3ecbf58e7c8b6d1f48c49d2e6950ec1bcc8b8f2f459ee2279462c5de5277069c5fe29b741a5b6852ba436ea3684eb79629bcce61b149cac94f53bdbcbbac4b6ec23578c2fdfa4fac4e377f8b46dc6e09dc589e2d3d760927d2570c4aaf4cd7642d7c346c5e3f3efbde1ede5a627bb936c93c51b3fffa125fafb6d25ed108e90d13a3ddac630b3dd623c6f0dbeec20d06e7ea1084eb1923127c7be9223bc94c6fedbe2b4618d07089ca8c0ad9219c81112821450f2f2ca88d7149b218e9311dc7caa257d4d3da5c50584570ae3c0ebb03a904504f97400745c8b0e521b556ad3b44ff41bad586954ee34e2baae4daa899229807ba8b07bb758dc0d98fe2c28c0126ae856a34f5e8d6c67c3a6725904309fd70b3f919b7eeb25ed70ae2563c99b46eaefd48adaded9e98ec2493441c679d76e7a2ff2c4a7542536dd7c1a1efda6d66ac6df166d0878e7ec9cb24affea820098df6d51350ab1994b463f6b4f8ec427752f0b861312b8b128b1833f54f8004cd69f7a878dc5c48ddefed826a9eca6bf78ff3a60d01a64f05ea946ae2f56ddd63d01e4e11cc417c3dfdbb12a1203a2c26e52900af76e01e91edc3eba0e31079403f5d9be7cf14cbd55d84ace3a985e476533fa7c1fbac50359722b3fed13a989fe2fb64bedbfb8fd2145701e97cde9d8403e38e8f399f8108ec2abd3e93d653b1c9185f36dcf92c97933f003b77e979ed06a3ffc8274d460d217abdd3700d3f3a0b5e5e517b769397fea9751fff165acb8247a419fb36781867495f306deab6ae65a6b710c534a894c422bbbb47dcdcbadb408b9146ee24b4485cf70e8a1564bdeaa03ab89408a65b2ebae732557d474959797da7007c9ca359694ef37ff379d8233691b3d533da5d75e7bd5446535f88784b827ff7d1e10d4122fe369808b15b2bc889036a42adc68ca3352b4f84e848ad526502a8166b5f69c24b3ad3b7d5eff0324caca8afdf9ba691e2cfdbc99ff9d4145395a7448e0671f85f7bee80ef5e2eed5305aa3a7837e1fffb6969eaea9a74bbaa473b87a6e7026994dc4f27626ee53368aac5df1610487629b9eeb5f7800ef9ab0b0332cfc9eb0559ecd3f6d2710fca5ca2c61ee23dbe3d81286ebd5daf03947a142dddbb3fc5c4a4696bd6237413eb22ca145e8c44e40ba3ffb0a9b5ae85c7406c9a8c0b53c3b01d8c2c4cddf47e0032e201e1f4882c3fd7c6380d287e4d1d577e44136f7896d7a74766a0f53ee355dc48d1ae664140649e65b1a11a49002d801a30e4738b58dcce19edc7f61e6e9096a44e73fab4c162cd0bcc5bd14e778d184b0d83ec43015dd1fc588eba049de31170c718c9539b1f3b9ff78ef4e8041c6defb95cffab826497049907f33f73915a2f2010fb43582f25f8433bf8d4fcf8884b92fbe61dcb4aaef0985ff2e827244875a8921b2722cfc691fad3fa7f6580389c0f117946f93856d2d6290fd951026280fcdd8ec827268caa53a02d05f630050372316bbf50add23df3f116e0e7808b9bcea1ab871c49ea6da464569ce57987382ff058c979003af0eabbccc63614db6c5a4b3c5cbb27241586ee8a882d71b555ac929171ceee7e6c19253f16f9b1b03e22014d08e63d6ec48dc0692c3efd62401bdda7b7f288bf55336bbb815f73836ca98923eaff12c9b27cbfe7a130c75094578b3ebaf3838b02070beec77594fa2d7f91178a3ce2847c19dece28934e317c2f95a8de6e30cdc6a40718553d42d7e241dd9b13d882931a6b18039294f53f54afd29060264589ba6205138c1d4214497104c063e51c95cd47d7edaae249825f5921ce656e231c1a10d237a8a97cd1ed40b1162380e314260654eb3cc7ef8a5a212674423fb96423767af469fcf84bcab96e8b26ea2bd34eff6dca5d6234cad1d89942798bfc69231466814069ba913c0a2dbeba468d98249ff0e73c631d6106cd2373af9abdd6f8fc79bfcccdee1cb3579b4f9c4f50788c0b9c730303100f0a37c87342611b0fd2ea1da1e854c8ccd23364ca2d719e1435b8dd84ab22a338bfc153841504fb1c6636e18391693874261836d4af4d4ddb7d21ff0e4df69d774f311007b81da8c5f54007acc19a46f9e9b3165b6de1c2f22942c6229fef738b59ab1249d94f6ed84dd94547b9bda90bdee651d40f190844e79f95032b6783d06cd3f44b868056a8fbc0dd3595c8feac99b176da2fdf141f4b19cbfcbaac125a03f8b326df276fa42efb66887c84a2d920c94a8ae1cc31a77feb3989b63fcead000a8468","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3be029b79a81f6301f4069e0a77bee15"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
