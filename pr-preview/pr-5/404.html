<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"61acaea11d34ff8d18c0d09ae7e3b2f3087e33695f8cab9eb66f6fb836ae84924251e416e79c883b35b28e397340aadf90072baacaf09a07ccebe2ae5aa97300c7e40aa133ddb0bae99c4d94cc183e353ffb6f932fbb5965269b04dab1c41a9bb5df8410f4a6374da23b3fb6077b011600bec944eadc5819033409a316ce9dd0e6d8289acd270f1ce87b6476f61184c80a5576f42029059c2acff6b86e010143db09fab19d9df73c8e70cea7c903c27926b96b012ee954271c59413b12fb1babd1459d3fb74ffbe72fa625746f2bccf2df68c609067bf3b931e2d2a5fb407b573e47214083ac5ae968d78c4abf23a6a6722e977f446406a10dec4e30edc8888640fd1da3f2b0bfbf416475cdf103b972fbe44854b005ac0627730f3970f2f54b23b630364c7fbb337b98743e525280b565a1a2079b957925e3c8f09fbea5223235fb61cc64688564d901525a9d278baa94586446c4c2502b2ca6d6e9cedde0bd533ad5ae89c427ebc4f04e44dd3536db6da55fac1fba5624fc7d3f0fec32176c53815a5c79254f74ce353003e551f1dc7e89a521c442c2d3d4f61dcb06ff65e542d172feb5aa23bc5a6e8d722a1eb8f44615bdbfbea3e338c28251ad52def7c6a0fb501524df177c460616f1f1232a3980582157d52c02384973e139f70baed0941c0f7e7fe2357a6c14c418bd3efcbfe6359322a6a2eda71d85cda87a6b94ee0555628e164e44f1745dba19f148138d93913eaba4156f125f360f11d6427937170cda46913a4293078b41dc0ad6ed6e0f7c5b6d0c30c09939b804a6b5e8cdff2d412b48d5b947206f53079f28ec19e21db0da0ebfa0c092b899b0f762faa9f929a265b3b8d63552a22029f1113028ba38b0fc6375ad762265351c155dd7a168d5ca9dd9275bf7b157cb7c569fe43d7a775f36b63162379f1eec2faba7d884eb3fbd4fb20dc5eb166dfb5e2532fe54aa9ab7bddc7423add62c8968f91560b6e619009c87801043ce68b620fcd2de8299a237683cfbcd31fe59eea1d39a5de2293bbc416c1d486058e80c4703f1dd1f057ff19caf3297698cedae23a6b5afeeef9de20f11370d9a9dec37adcacc91b6d7f733e88926703dd432ee36437c8a4190d058c998ed58eae8973b5bdcfab76f06ee57944059517f7ea74013e21b333f6afb871f9ea5323031bb7052372d96b224be4663b877b213706ffe69e91fc0b2eb03cc50cc41c6b74cb8216464d014b34b5c5fdbc3086bbe881c299785994a6cd6d5e5d22b5b5c0213bab3741b02337a1dbb906eaff991ae997073bdc88e93d45438ca20e5c8c809e6c87b919a13dfe337d52b71271cc47f4f711f9b1ccde3aadc279c2c83bda13487348d7767bc5fd10076160d4e3e01d2498aedb62638c03b5bee0867d32ae09f5f1d7cda9f9eec9f3d08e40974f6521a1cbd33fa3ed6b47c5e99a70cd137476fa8e0ca00a1cd592fb3837f46bc384e480cb8437ed35dc2101ef6b99e76f7674d066e72855f5ab09258202d3be5ff43cd3fa6a21e7259a1d4c88fa2e35c71426b2ee4344e6aaa037b4b52279010ab83c8a5bf70eedcf45d6e3bff028653e7fd3708e04b4526fcbbf46d3d3294184f3d712a3aba933297725ac1bc6ba347b4aa967265970f7ec061712184dd4680637e64b8aa55c42fc639e08d28f3b407cf60337d0e9e0e00ad72283f9ca012dcb17d6c5b9c2915358a47f2415aad06ec0679da8036b833c32c5a66628ddeca960c7d6457c61adedee1daff8ee592a387bee563ce296466ceb47b7c40adb63077bf21aad92f7a2806225bd88f5edbf3f497450e56d027015dbed3917a17f7f307e71f91c1979fcb54f137ca8086c9d4aae85349fcff987dbd6021d2a54e72f52853b9e89b9596abbf355a536c6046723369fc36ed050c7f10d4115fd46ef1f65599835c3c081ba8f32c9ca5a0cb6db3bc6375dbd66f115f651c8c118c6d34c4e1de1ee08290792ae58dde3fc9a134e29ba7ef4e38a6398b393fb07b59433f0d13f8d7bc131a3bae1c0725b3760a772bb736488f1263cc6b24a280e0a4b7f7a83d9f5cca6369d6b04a412ff90b8cd6ff91a8301f1ae41d5b9c446d21fed67ef351d8bb6317ba73776c059b461b59d104c7997d1ef7140d097549f8db498046000685c8110be4dbecf95ec6575b7a0759e41574292c969140fddd090340fe3207fad66d593d3db50fc80948c68df752944eb4b1948c0abeed699d29f3390846f064ac0f0a2f75c718c3d0a50b8b771b78fc9b68dbfd330b2dc96d6980ad0a8f6bab3d7721e3ee28d51d3e8a16f43615f0b73854deb2a0dc36ce0d3f562ba174cee5bb42e8e2f3b5a69a0d0682a4eda7a45076d5817597bbc0c5d3f65f0926fbf7149bfe94d2012082e722fc18ab71fcca5e132a11b96f2ba152c0002e2cfd119f83abe23ec606cb1da1da9a358311525dcd79f8341b10bbf026979b9077bddfb044a4f88eb875e5b81a9b829604cd11328ec4bda6f66e6ddfe68940e394412158534a6f4115adf83126ead046df23808cff6f63927bc0657284473912e6016bc2efcf8dfd57b43c926cd1fca07d32484c23cd425992a2758ac7ca1680e78cd06eb5d539dfef99e35451612cec85ee9b09269d1b445318bf023a82e6bc6452d4985313956ec78eccd435e0d9bd7c589ceae361ed955ee8936da086da7ff0a99640c9962f65c4b1f0a9dc5addae673946c90e5c7336a604117f7845b6dd0a8783c58612ff0536f44e44315a76296aafc31bc775f2f5bec5210a68794bf8e2ec43e977e9a35a124e439288f8767e22f58b1d876c12b2675bceeef01ea4230bee06204c80d0c8334fc5bb677618e78f2882d9954c509bef269fec585ff8f6fca929a6395bc89ba6fb0cbc77b2d2a2b21b97992fbd7c255110349a5a1c613eff0fbe39c90269d7ce6ef0668001caebea1f6a938b1614988eb52549a31afe23882e6301dccbe529a260891a1aa880deccfd2599c86fff00aae606851821f80ddac3d32c6caba72e6871ffa35cdcbeee470a239b1d574ac3bdca5177fcf3cb3d2329be14dc971fa8470b5aa04f6491b7bb2414e409fe5654a5c4d827d7dcb7c057b4247536e5ec78c619ccb999cef02727ecd5d0fadc41c0104627e74844bf4b1b1bfda1579e20dc72e5a1198963f381874851b46c5f7aecdfbcb761edd2b31929a2d7a586b809e7978f5d292a0913c8e0f3133295440127dea799822e9c73ead07ea35989fe964746c89946be9eee5bddc1adc3fa2b4a1ac8e4e07b4784f46adda4a8c83c449ca9a030fa80884eddc3bcc1d0379fa91bdb2ade39d2fb2d37653f8e81a698a1f02b1103a541c95125c83d103261aeaffc4204f5966851302978dd1893f399ae0be86ab94e82b272f1bc25325a371653bd578d6819e656d0da3c439f086ce43e2da2cdd63b20fc6e483d37bc8b898e25fa6e78fcf8d6370f9f63040c6ff1d5a7c7645e0a26df795dd7e3f134601c5ee1be88cfec7b583f354704245938508c340e2376c9f5dd9f46e231d4a7588881b7999e8090915da12055b3fbe4967e19b1ac342bd9929deef155903ae97e6a45055414c682f34d39d8d08866f65305d202ef2f5bd6cb1d1e49a904fbcee93b259dfe54f8a7b547620171a2e5eaac0ac6939cccadb396263c1539d568b64816997b824c32608a08071455ef2fbefddb00c4f08bfff1be643ea092f4a2356dc4eb4dc59d7f4f49664c7b8cd753b24a32d2a06a9873542d56d9f18fea5fa789e76ad85010f7c84081a149ed8a459555c9547aea564a4d4847abd8e1289c20f65e839abb6646b8a5c9a75ab41c3e62f416deca5ddf9c4bb9c404d8b72eb2df89946bcf0021a569969239140616d62d2d822df80b350857523678c149dadd680ce35ff5c43dd826612f869b14c7d289b1e02545d93cb14c63a490f13e1f6b7f715e06405f4376c4c2fb34a5e23493b834b1ea17f0c8b85271483b6d6636a2f0d661c357c84a822ec9e839ad9957fab0330a439cc6cb21ece11049636b276c4363735f6789050deff3acad1d29d6570b71dc23814aac7f362b8a5dda798ebcdd9ce01c3997cc2c14f50b6ce194b264c4036a9e775a49cd3b56031f2e6eb3201a96a7b6bdbcf154fd39240d9c8ca5461900af3a4af9a340f089fbb6d0e278266eff7ada82fba610ad7ca2603e761149de264b6a96d119c07863d6576d073f86de61505d9bf6af6c7c616fe92ebf522fbe30e14a537114396017759a90610614b8439e61030b3cc0894780ef504fbd09aadc01031cd9e57e289008168e7f4c165113c8ad06ed191baebc4eac3930b03602b07314aacaf1ff85896f4bdc6ecca20b6320c0a7220db065682a17fa780e40c5b6b8b627d616b09d4899b52e90877a4b0dafcb3186ed3fbf58355812e1255c9065a0c21c83a67f2ff9a9501820d8f0b07e3fa3e46d61eeaec3b727bd89254a3e8abb9eb3d65c48aab730b016a3a6c239e2a2bce9be8734a514d394358610f04fd6d930449964040996fc00d631c9dc2d1517f7b808e5b0091412a3d2fb7df1d336703d3ac407ce9f9566bc2486ff3ac0f0b95f662af62d38466ab3167d23fa46f313105c0c6915de53e1ab68d1a4be64a79df256dd272f07d33fa71bd7b46ad7872280410869b6c01da7378dbcbf5e582532866dc4b08bc663c4b17282ff6636a75036e6c4b385a1d13f66d579a0c3a36bdce50f252e35caf07cac9ee7becf57fc53e585f8d8b861175ededdcd551cb399f4f0faf04dd078e4c20b44f233bb382f3f23fd0fc507f5cfd0634221509cf2b7af559c555acd68d55537bce9e1c63eeff883d73352269fd5de050223512f7329fb194b3f2a6e5fa2aaf534bbf4b9108855d4d07f3aac9378496bd02ff520d30253d67562492cebfa6fd155e3e9a35a2e0723d6885f626268b365787300d484ef4bafae22f869c700ca0845502e9cc5bd11c967dd1dd2cd6f99c5f8616dbecf35ea0ad818d88c9035e0c445bdb66accf0f2a6372b2f9e1aacf0403f954435bfb8c3a05186f1be98824a4844461bdcdec2b9e262f3da2be4736804a8a968ae789beae1b44d43e22aa122523d3e74ad819c187f9e60e53c1e27ff6fccc43025949dabb1c447935ee90ca044335c964b4b146229afd42f20748e6dfbec50759fbb5131607e2fe2237f4e3f1c64c00e36f7a68be2fe846371dcacec56404d0f4a21ee524de952a65302401d41fd8fedf7d944b483aef4b07f098097490c814227b319abd5a502a317b98ab3fd8708a329fc0981d24e66af8453959cfd114e0035c0ea46362c236130c47db42988f0ab1190ce7d20ae37140ab6d672fc1d2f235c79bccd070d8f6b56d499f99624488ade5f7f4d1c307be4ab8c994cc7f9241bcdb443639c3ba4f7ed382e0ea88ccef0c762a459d114fff203649508fa967a36c508a8004b672d7270fee3631b16eb30736d65cda38eea1dc510f7561b1a0863460737e336cecd7aacad1538ff6b72e2928915824332dbf9a5b0cf71c18369c7d60fce0e734c03cdebce29c4fc28e221d463704cc9496bdb16924da03847c1595be1c0b2695908032dc220c37502304eeae2a2bb45649ad3f1be03af28a8f24866841c9a878d715dbb9c411f7b88cd86c0aa16275bc647aabc26b4685feb661656a7d2ce3fe73b38a1efa2e14ac134a1d46a403aad1a4534e32b22d2e3e8fdf439021dd3c39514a392b51abab1ef325ec5dd1268260ba07079e577e07bb69669e579f61a050f20f13068c29922bad11cee68bca5f76d25fcbafa762119e01a357234b3a125da212e1227960fdb10977b27f26789405fd106eb1788abac90531cfb744f8edd439777ee66681d937f29f9087fc84772c4cd3a670ca83f8827a3fe2ef05ccb6e259dc64dc00d2b6ad41e6af33c03b7c761b7c37d7484618c2c936678e2d18858f46dc0a377c8e876722c5c6569042b7ab08ceb0399d04a13066d289c98f035fb4c5192358273c35b290efd5d2678edbe7666ab0287ee2ab32605c229e933bd82ead7307aaf89f5abd01d33a3763471281460c54a3a45065814fe267edb18eadcdb8ed20c5beff517d05ab089cc8c5e61dfede1ad6852ccd4dc1bb574adbaea73c667be8e86bd5496d2ec131dbba7d9779e9af27099f04cf08226cac89c6adf91b336b7aa3d075ecea5a48b923f3958b5b2f851f34724d98e52642ac886558c789804d98c61bf30d660d164c852b1ddaa6e463fd7267f2652d3c937a5fc0d87f97d2275f4be0cd06be45b440fb66c38c4912d50f75f14d477b5f8004765035b4a49e40cf3884b5880734644442129b42ee3474e0bbe599598a892f5c1db4269efa5a0eb1b4a855e6577eb5ace83f3c1c40b1072a786c4d3018c670b4db44a1fc74dc0786ce7faada2008ae53a92e3ef7c4ed82827c448cb5b213c7bb6a5f6ecb3620ca7502487403f6453b2d0c30e7479099139249cb064372901f162eb5b60202d1c933fcb88c6b581d634c61e0a9636c65d0e213806c9f7081d86e3a58f782da4011f10f00ca3ab4cd5097852c47a3d2a9e0aeea388fc358781a1a0c37169f75e7446e0c9ad20087e2904e5b56bf67d31771c2cf8227779b3a39088406e613084793c2b17fcfc38d6404ec8d5c57286bb91bc2f6d41fea0e14dd1f43f421211ca9321ef41e798aaab0430fe3d4166c47f4ef25633ef3f04d9eac3f34572df78eea57347f625f92502a6d3acdf48ebffcfc2b71bdad042ba57633edf0b2d40511273e410cb9c8d2a7ea8ac5ff59b1bc8e6498291a21d800722170f39a81bef707ab885cc97815d6b8114b79c24bbbad29d69f474550005b0e60eed72a9341c6dac15a6bec5118c02bf3e84e10e821e9a4b604708c012a21156d4f860d1650abc75b8096d3f89c1cbff932745287aa3e7b5eaef166011985f123c301c0e176eda178606ea986632953d161cc2a4675effc34fd85055076c6d7d940928be7f45a0da508095b48b5238d349247d83d0ccd3e17c60dc3f2b3b870672e7d65598dc7a4c3a8fb8279e296eae01c732212be02d2771258c5245a1b5df68f89bc72343bea330daca3707d2ea3717ed773c8617b6b6440a4f325ef104fef547e5fb9f6ef42aeba64a2f86dba712903234fe6affe15df20e5c023e1069df0b517a4d31a7878640d27151644bd7467d5c7e99052c0e0e385837f71465ea9c38c2fa30831b34985d78d8aad7dfe3edd7fd655a17d0856cb6c160249220370757afd469d3f99132d4a9fa3a76420b2d27a1d955b4d32f7f53524bffedf2d360a02b376a9400d1ebd052301acd00183dc0f190ac5793f7382e19185b74de2d4d2fc7e32004ee1a661acd78dc594f2beb10e0deaaf4d48603602c06987540bf028bbdf0d9eb0fd9bbb73d949babc62d96fa09d229ea833fdc3e852d91fac70080e7fb4f0f66eb013e8fd00b102b47921e0360bda9676d9d3c0e6dff6d5e61668ebe142975baa21d0813ae49ff4480f81e71093436083519a1fb4a3c04205c3f3f0b1155d79205d22c33539cbd618fd55f43b7f4a1f79ff08e7fad5929336b25a2d94c8f7c6e5d0e42d3b657115de0099733bdaf48cd460f3415c6a881695a576f3989f783a321a2f6787fa96398f2152047fd4a111703f66c48ba7dfe6bd51cf52d050db4ce7589338a44110cfa946da78813c5f4ea3c04f651a3c5cea2cc132da7a5a4ea48af0f6f791c77143ed7802716aecc41c848bf60344b52c5a726ba2c33fca75f9a5f3134213700318d2147ee9ebd6a8cc91d0871c369423f59163e4567a3f91902216828df4cbe346772b98e67081f0a3dabc9c6263e229f195c8c3f234be1d50c9e4bb905e24917cf3adbbaf79749666763e3756b59b10cb3ea94156d84832512ff12356810715fb660969284bce9a1953192f13c7fe7224af99a1a3d6b0200e4c470ea339d1bbe980e37e8e85b605ce826a49d34bc9b010ce42d5258d30c0aff11bc0c672c5e284c546209c9ee69e183e25e4338949b88b80bb65d87ad00c24d31e89451458e57ab26cbede6b2f5de15bad1c24c788761cf2e0e19b988cb84b7b1880a3c586c4ec8c37dfc0894dd2348734102fca04b8ba6661819f865dee9cc0999dec1be82d7f0f612a9f09bd3dfe4282e15d2bd187b7decbff8dd51f3aca607cdfcdda16d20d30c13ecc85485942d7a7a5fbe35238ef43011e45300a6de8dc079e8e04a180b2a0c2f27e95762e4e85a0e030aec2a5d087c4fcb941f5f83115d7566cad020567f9c28c86055ab321ae74a50c790ef803b7790611a8ad59cb301f2ae902239df938e08c5e5a24c1852adadd241ce28a4bd0077298b42caad3c935caa4dd2c7dd05f17e46ed23bb247496acd0d08a2931c32fce597ff469cbb8935fcd5501eea2dc857f80737fe8f1580b6284c7e77308b29b130730c9e9e4e33ba02bf6c207fad4e7dc20f8e1935807edcc5fcf1992b0f8539ba0fe380a645fa51b2ac22fdca540b2eb48b5940eb0382f3a4b69f79e9bab57b3fce88c98c6cf37c9e0e197038f307d052aa0b72c0638734152374763aad45dd2ead2f2357e899dc697bfdd6e61ea428238b80408fe770f4fed2bd25291b6beba6685e5d9c6bda4c1771f3b32819743863271177686bef20272b360e739e35c401bc14dfd6ffddcf85d32c2fb5a3e47f07a25e7c98d2398114466f2b619d040a622603b67c858b6fc27e1b65f8f2427fd5c667a4b3fb4b90dea594091a150fd1e6af6025de2080dadc5d209d28b705e89148a6659e39e57968e2b9fd3aeb75cab0e8acbbd21011200785306521fb0fdefb188039ee00e4e1b51aadd1265762e8e4e17b0c126e1ea2909a362f8d9903179998e1890f804e5854cdbb526da42e1c7836e68ff998afcac8b2c6543621ce8f6cd9a7b08445b5bc910fa4b1857a96b3ab9615dd5e444d247cd156bcd0613cf7cd220c6ded08f51f51519191f258820fe587c4b1eb1610a6ecc119456385af9ac3ebaababbc02af3df597f7c882f2f264a4e4e4710e4fe17a3fa1ca581fc2cb2af7865db801eb302c7adc80510902415db3216a285821304786391f4b94b7e078d4493dab567472c591f7f571f9b860ef56ea1eb0a6269cfe26ed6da2cf8662684d7da0b1188fed3c5f191e8d4b5db1425ede79f56334b2681cf9eb0f7dccf112b5bc97bbd74899b7fc916ddf8be0d0a703c017d0071b8004fe25b1c5ff081435fd2032ea48f9f79e221a7d1916cdbd20256532c2838d62379208dc1a162feb8e06eb9f906cf21e0221a0221f8c35155f7d9f6dbc49de20a976f0b241221e64cedcc6ccae12c50621f894f2c940bde7cb3b88974646fd0e20574361bb32ece4223c5433fbb051cc8e346e32c01c02ee69f99b99c4d6ce847eb4b50a9d0b0cf58f7b42f2f032eeaf47271ae217ec4a5a8ff05cdcc104c7d646c60b459906fcdbccf2818843f90e508dc8f5fb341d2b4f6364094aed41a5871725a1e0d13b50fb522b2f54159edf0b15016908d8efc6fe65d5639c9c48bd84f600983dd1501b131d0c5fe050a2b2b6c57d8c12b51972dda72dacf5b451e5ad1f0a09c8f56f74c7dbbda30059829624e74b0720ff14fe9840f369117c1a259268c411a7ba08a1d3aebe48e1bcafdfd5b88965431faae3b11f5ac65894066f992bb68b321d57c10ab32fb7299b266212cd58d58e3290bc43a8ff941be4a556cccb8dfcdaccc6db59b42ff2ae2c6dd253da934ad77f8edc9d159459494f2859c2a7d775dac40e2163e2f8885dc8e0da85bc3a1204189af8ce9842b4b05d974768a37e46cdd39fcf99822389413ed044a93ded9257e7c6202bccd1b713d3dbe378b6ee679f973cd453e20ca465c39fa7906c1ff3a22cd4cd04548cdc2c319f346e79d950b3266f565c79bcf57e38622b5ab4be3748cfcda3df22a1729cb570f050f113e3f6b278fe2b9fe9ac10d91188e7bf81b854371d5e868fa199883e215af2e6ad397a56b71d135c6d2b8d38ae084c7802462b78ff8e9f653cc149c88138f3c0e56801bd5c3182e4bd41b7c23db864e28659f4d44fa36eafce40d8b1bbc861fda26bf38a742933c7e72ea44928f2b0920574dc8b3a86f0cff327015375c29f15780a34995001706ea48a3bbac02f85b0b792433813befebed842e6f842deb2ce865aea90ddb12ab73635eccb6d0257131f9e2966b688336734ee61d9ff5e72801c1451a055b46c08c8645c42d2184a577f4facc5b7cb290d6136455df12db14e3912e7d11cae9f0f5507736a7f079165c93d4185594e99107a58b23e5cea7adfe3a46d8ae2122a393b8320e6cda91f8ead2ffb62d47de85181cc58d3aa517bddd94faf7f35681b2ba4cee36d4c2572051eba123ea81e0004dd5fa2efee20e50e16a0d3d26dce3e43136d02767599b97f237d5bb142e8bd3b8e50a859c06672280286dd2f37b808f8334acde520d4f34427b9381db6896392b004c1a5abb19c4420c5a563040de14a3bebe7115e5e081c808065c2f656387bb5c51127567fc8fc7a60e1bb5a20dd74f48abe805f396f0e8d24c0da52ff0569c91d00129b6154233f4170ce03aba4c7d7cc40f37f75f6df81c2c41f9f25c97d4571430dd2e51334fa53fce1a0a3d818261d51182e5bad9a126b0f749bb658073e4f4bc92a3671c4bead2da8ecbaeda974e60a447c55791e7c0a39387f9f5c282be88ae307220371d1e64c0dd35c1d20fb3eaa5ca91b2a180b7aa35e3bf8736bcd2c1e11fa011cb7313770f15e29d9c4bb9d9c3d53dbeedaab6161fe84641f2654ce4bd7f386b2ec068248880a2c1c9fbdfe22354b485104b8330f880153e8d0ab30e93482d699fcea0ff90608a232c2dee02a8829fb7b7db194faab697e66fecffb6935886520decbba307aa69e074f4a762057ca48f28490846ef841c83bb8c8ecb1bd541778698388c45894b2caa28447ce61f5ee9fddd95d0ff847435fc535103018f6c18011f84b3be01d7010772c342d47c1faaeba11687d3107d3aa5f38bb8530a546d50b80523e0cffbe79d24e2388f98715362630d99dfc2c56d1a43d2c907114242b3d73314faa2c5f7c0a52ac012c253e97a3b18ca033e6b48693554c54afad1cfc081d0652f2509921c0f3a7fc6d85d69e76ebf2f047eb47a849771566809c79fb9403f28ccf51b486669742ceff1704a5b84c3a2f7e871d61aca5b5ece58cc05a47412f814e6199d17e14bdbce9634092b022851c6c8db4effede0798e5b2dd2c2f5d1164947066c1398d460590dac084507f41260abe663a8daad36af4d913055d93688da6b18f116a6f521cefb1e7dffec20273215e33db260bd3a10c2ceafa282ee625885a6850a194e3f8f74bd9d7c17b62e2e44af0d34fe1705efd89134461ccf48f5e2409d9f35d1a284d9694dd1ab50c9982724e81f80cdaa13f4886ab4e79e4a6d351f996c8aa4274b53b43a04cf4f0cf3732e758c1ffff188a3e627e852771a22f0e69eb944c4bc438e653c4ee6ceda32d4b126e1d86381a6a7f324ea3436be504c6a2a8a3accf7df799b844ff4b49998151022e0b45659562f804654eabd9c5664b5e3042ffa6a3cc83f07b4991152c6ce3d4dae75b8c102026a45ee0e1ac4f7ad709271275c24e14b6d53ce71f381e165c55512b499dbb4bcbe4105f375b65f72c459de25c245d95823cd98d74950c7cccbc1fc876f2ef9e29e980ae8d5ae72ae1518d551a8b5900809f893451f7a4fd2a4616b312569b42c7ff72b1ee5c6e4e4d1796c1b2ba9899f71c4775c424ca8019be89a543e1e8cf84dce0801b5a9d8a68f074052b7a33f24f61a8b40ed76871d58d83af9ddc02af9a9681e99969815df88a2f58f33e8e24ce03abfc557bf92baa3bb8e41aea2f0d858cec6e7b0046e4016d5c55b13123e45d89c1007a40bfe7532b59924fc0759a3f827cab0ecbd366d6a6139e6b1edbd9fb2390a94a7f7fb77f5adbd6be1b1fb77f3d9966ad3eb0cffd0fdd64c3ef337356246787e1e638d8e9d1e0a3e82d5789552e3a7c8ee1e12eedcf8abaf1d701ee8f39bf0b01a677ee7c7850cd26c3e96443c1261cb10c2517abf6b248ab4126ccf1b4608c0f866131b9c1a48a5bb900601559dcfd1e657d39585c41dbead641044cd2cd79ef4b6fd5746989f31ed1e7f62495bddead75d5e0b05461e6d3ff81b04564359b75e4e128e09f0c2f4ba681dd6a6633876ec19f982d635dbbcec4e227727aadc63c1d938e429bbe7659fdb777af612e7432e11a7b2501986158cb52e40b18bd9c14a754823251eca7da64bd130bff98bae84c73df8ecf7f04d8ffcde88ba1c4e727692c5a3716653da0ccf5c6b412045573cd1a4e05d89b57f51c8e783256e50cfca82c163688fc92315d7277de013819bec34d8b2538e02b7c6a18d346737c810989c71e69b0c0f47b56a7f4243ecfdba5c3990e869c046b8c10cc008a006ff97bfc306941a2debf2024f187eff23fd8bc13524d469afe5123c40b94b395182dde860978bae5d02f4cd9b4f78431b136d111decdf9db0cf9495131ff61c1575294463308ff765d8b9f4fff50fc96fc93d8e30a895cd417cb8f5c7b8815231c9d29a637a47760231713f5752865b9dcf728feb5e6a7460496ee546ec55e4b8dc7099ffa5494b89d1cc8c63b03f559df04ef92b5e54e71c901d4ae54de2d2c5c4ed7fcc89f24f828fd9e884d8cb32bdb4542c758e98ee082cf121a3589b7e8245ef19b88ed5a743010cae9fe7cdb7942efe999d285b0b1b3d2252688e2e609be388530446f84cac65179b4675b51764fd0398635e2621fc4b58ea28df2df17612083bc4be07932b7695a8e4852a186f194a2d3e9d91d4c812088d4156cd158aabbb19022f4bddbde296fd8ddee5509ee8e310a9c8fb48697fab7d7af1318b8371fe738e4706419864e89370a5ce62e4147b48b2d97f055f140b65a3e8dc50bf76831cdff112d17fdf6f9bb654aaa5208dfe3dc0ede3eae320ddc15fac4d8db8a64a7fd509e50357ce15952239e802a7f2a25ce554650d627e70c2e85b24fc04ef050f2d05e9cd91baf33b171d0422cfdada8313c093e6cf37b912540b9003c0ab73559be378fb8072d37b6545b80ca79967628d3c5e70da9d180df6d414a5dc6647c040baef536015c37405a5af180b82741c478f2345953ade29c48daa4ea0e2afe04de985347f302c36267ffc5df559015e13b46e43169f31c6bb1e5eb796edb10ba201dd418b14eb7bc3904243594c4bdcd66274e37f23bd4980d20e9895f0128fba20964c66c170c187c3ec61e6e48d63e8dd512b4d8f3b1b3fa9ff53dba763aad32217f6b8ad614805b64041bc929d896f3269ea2807ca3c5ed9be34c1c0beaea1780dbce34fd951e6b9416a254499a9a090fb92e40893ae288f7279f53a9e9f3f2bd23cfb12eff8f9f930b3461ee7352d179430e4acd12557f9b3d91f0529adc37d2e7c23236b904a2bbea9b35867a3322fdcba01db6777f210b41886dfb911d0b64630510e26e6ba6fd37d22c3890d7eb9691fafafef54b363700d38bc9701203ee526d25ee705669a8ff9252f81f8ce0a157b90b20e5535803f07e0397448354180f3b5c7b86497c624121688aa05da18c6ffb793968f1f18bba557e457a637fa7f768b858a5f3b6f5bf2b39808452ef30455d86afd47f562d69cdf2db8bc69dded61b18498d7dcc7b21beb910ac02fd622f6c0854e6084807f9f54b19b7e507e856e73b464f50b20a9f882c56ff6f49c7065315a76abf6fc90466a6e95094a94e8eea5794f337e9140fe5b4aa0e2a58b4ce74fcad8d12fe5bda71cf279a2fd14ad73b2ce25f83c7e309fed49551f2a3f75f50f075764ffa36295f65bafb847027e219b2a3ae761488845f5ffb43654128b94e289c9b4cfb93b397929e83307e4350d5937dc4d31dbd14c0cbabe531f8a020950ab5749aaa627df8c9a580a862f02607760bd3eb39d077b449d7891311e33bce4107ebccf0d03a210430233fc1648c0d4fb4a688bf3117dbaa45d63e70c1ea533a6aefb27bfecdfb71bb93300f292f9b8e114b975a48b4d68669700371662ba804cd6d64dc9bb5f00f77613bb081cd6983b22db0689aa2bb97552d13db9de5ce1e744807700629ffd48d438b6b8a9de773865398cbc821d10097be0e318b1f1544557fc0cd0d3441931adcc6092fa287cb7681df66b4208e133a1cbc292d33b463813bf4745f1364fd135658a3a4bcb7bf79bf59852c587746e9cbcdeaa683a06a5d57c9fda5dd0c25d2681e5aedd911b56463062bfc50ea3d9bac05bdec92e3653f5c5bf36da871df670cb99d7fbb67bec0b288dff3ccd4ef1bed75a56703c11ff1a3a38a2b1f80c44ad4be5a00f866a3ec3947c82d4c35e89962881b929bb2b738b7791fc498b3adc308e327f1e3295929f45ba5977c2385380744b77cddf51edcf09626143bc0d6f05e9c1566b475c57bb2248fbabfcf81176adf0a296bcdb934e672934e54660aac2eec1390888d103c3c9031654bdf62708583f04baf7b54d3925392dec93a46459f2dd2ee0496fd39b33ef17ad38356fabf0c23fec47a1fccec4ba88d192fab8289891f97309ec332847ca64272d31b324a9ddd17eb50151acf61a26f4edf72549888886ece046d3b175ac5138f59bc9d7af23538948cb840098b8b675584c44825cedd8e78b85e304363bcadef8102c683454896f2c796052b8e299ba5fcbb6e928a9ceab4b5fc9ecc74829c835c02b4153e93eda92381e2b3b7a6bd78711bb9ad811c2fcca4f37d978c998a6f6b83d9cc351a45be27d6eeb5e25e4e69696b00bca0d9626e4fcfaa026b76f1bcbd2ed8baaaa140cf231a5f7260ca5dc3d1bf27076ab559e2bc4ea4a5829c674e371eed3b83dca5083d2769ad7bd0b8ab7b42ae41e427773530157c08625da452b6a7d493336f72472bc7b11eea1c82d156f636b8b5a950778ccd53a30a67ce62935565d864d3b173b35b5ae1cdcdbb8cbc4947f7238604b123d4b0e12945de4bf0d66f950e72037ddc5fea88d22b7edb51c6de3e9cb3eed9ad58b51f056c6e850b3a274c73799fe0885a5b56efecf2a6005aee7dfac2f7795b3c7db582a5104d107fa677d649ce4093f6ae0b9f742181ee9e6acdbdeff9f09480e61645a3817977d5605143bd32a7fac968373509fd97aff113b72aa60a5b7d235ba50360a58461f31df6165fae942801e0df041d356d8b7b7c8cfd46cb85ef83106b4c029e6430fe8d408451884df39a117e65791af025f2e674a8ab0a613d88e8a43b24cb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5197399655f0ba2e7412d816aca469c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
