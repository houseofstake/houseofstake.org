<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ae0cfa63c3aa455e54d6104b9a4f719156352f15bfaf7b5e558b351b108e5c74cc575520e9d82c3d2351c700d28c81de15430b2b1b466545c2057ee1203fef1be019422d44d1381f993396b7ba5162885bd2cc67fe59039e6b97ee3d1357b4235f391c752040e99a85ae5174b2791a989488390055cc27fe8a4d04083e487a1166b08d2506611900819ad1216b76297cf4563e3c5b43fe569795cb452e85bd800ee827ca2a9dc0c0b62540da5aa0654499070b6f1a0e187d5fc2dbce91f774447ca784d5bb405f454baf991f7132dc4787821acf384fd9ddbfb115b93d8f21c0dd1663ac649be3dac013cb71f9f2e2ce67a6fc381ef8852b0a9cf279c46a37ca228237fd00305e2ac337b9fb4ce7559e8e2ec2659893fc30db7423a67a73d419c659b68b24b2f4a33b80765f105cbffe772814b979fc6f79781c27da25eaef6aa0f16fab322e184120e98f2830aeebe8a5290f7d94fa26a7413d58e5512777b4a0576e838b08d9d3fa7f2cd7675f49df52f491c63cb1fa0325c174788a881c8bb1abbf9665857a2d4ecdd94270a96be9f6f2f001297672f2226b26a477a247bc4483017b5838b021f4175378642e3a36b08ed078e9bec5460242282584bfcf39e14368622aa615d192510a2f4fe30d05c70ac4b3b13f5f6aed3cdad7835aae3f38942b454f93a9d7e233233125adb67381fb80783da7ede2220616b58400767c9a7d53a066202bcb94c404c61703cfcdbfcb6a4d6c295daee913a39f594caf5e92db9fb7617f034b12f14a5244b99fa880ee264dd38de3999ae4f3489dfdeb11bfcdf6af84f566793ade0c3913d4af6d476681d9ab4345bcdcfb0da723a7ee97ff00511ef6887c9468275200980a9f579370cd0b486726918a92cf0b0968efdfdaab9ea9351f4ae93dfea5b0b789aaab9d0f1e4cade51cc3c81cfa2473d92b369dffe5a305654afec55083d792287fcc38364b68876253c3849d24309c9a920957ad26d73c5e091c18a90f04596567cf68fbac69f97b27e468d40bdfaa4ad8798020b06da63c83cf125f2c16466663ce79036d6399471ec6da51774928b302c3826a2cab00ee7c2d055e7694a9927bacd818eed428cbf03c80991b8319e447beb6f6c163c525340220f56aa6c14bf4a2a84e7a130de57eeab75ff436365af48b53edcc150570fb266f78f9334bd309a4368f2b9eccc6d3ad8da6904d7111d992fd4d9b445d9f8e6ecd99896f829384b30ed3b1b7daa8410cc79650312cb29b600d99cf5a4cc63d126ec4df47fc97cb4076c7559585ea300033073897857f7db1684409e43a3660518fabff25b5a3099c62e82c6cc98203b6c02cce5b5ddd62352bcaa9d35cacce6cdd5c2a80ef19c1d0357de210399cd9c96a190fdcae719348bce610d58ef0a404836d3d7fad6c0949058a36253deb249e213034acf3964a33852ed071b77921f3ee33ec3295469919f0e4618c067e5b98c815c667bc313a6a7b7a0b13f03232cf17c36aa06a65f7c3596189d8b872fe39754c8cc4db393bc85335e44bdb7a216772da3bd67e375662a8707f8bc3e0bdca58cc24e273c94c1297e17e00df8cc74a8f7ebf59bc382d3868b6e164a26dd847cea221541fb2ee4cedb3ea657c0bf811c6c5d6fbb2f5701999ebd10b921591bae5cee9502294c37261bb67258a0e1e566b7e9681c742ebac97ae39cf18cf11427f0a1eecc2a65e79736337c1ba74fcfb545b0568921034def67a4447d24b3c464af32bfddf7735df88fdb0829427660e5de30a7f4d270eb6bc2a1f6d547c6468e7c34c554da72feee6bff90a7fd074983f451dbade5bc0f2f4789e400f794afb67a64708063c1fbe51097a37ba173016b33663579d901c01c1227a4fdcf43c0505e8ee57ba69f5b0e13d74ebc1af3d251d9ed8961946cd13bf2b24bacf1d891bc124855859dd7a0b6ff5542c663d4fdec78ab7d8f2b090a8e86b076a0220d00a4a0d775fec8da8c3ecbe213bdee94a10e67e21190fa6418094c7f93091cf8fbc6ed4a17a36d7f729349184f1b7b79a6cd1bed3d091b00eca9894e2f8253a8e3a4145bb1108b2aa3a9590b2b474d7173c08fca362c0161189f6746a8362c7bc4d1ad0fa12fab1749482c8edfd6daa35871e2b97b6f3bb099d4aa2f14171f8aa6ecbdc0d2e4099c3d51bf5c730f3cdcb22bbbdc170ca2c1c64c0be90c00ac0596919c5391e7c582c875d42d4549510e98b0b423f5d4535bdb4d8058ab3cfbf6130c791d8ee175ca5a97418c1d82716715575482d49e2b74f05d0212631064822f19b55bc90c1054219b8bc7cc3bcf17504c0cf18c7511a8ef69bf6891e1fa1863b46fa911d3b5371ba871299efe9dedcc83498554a856ca71003e12ebac0e3612953f5bda07a36ae6841e0d7064207c4b4169c219facaa5eff8578845c724c47064fab5551a5d637564cd53bd8f518068c3b026bd1ad6e1f009585e915ffad1e7df6d4643cd68ddbb2769ec7812f28e55ba076c2a1f3562eed717b787c82ff6d58e9ec9be7814c716e5d7d3ffbb23f95d369c4592ebc4d3ecb78fd0af391aa2d19026f85ec8d2648a3b8d5b9a25ab11df591b62a472f6425e5838972a28f3cdfb1e22e53403ab2e2800624a4d7f5a2e1773a8e5f29eccb62cc1f0aa4e264659128ea2bd9593a4b43f9e57a5f01a2d6fe8a41f4580f1240bb97abc4dcbf8dcf542a0eef9164a81d44db83803dcc09469e5f2f8498a135f2a1310f384308ac8d57a3ff94b88a49b8bca1d33cebde998a5e88bd8d44ae0277175f4a1cb8a2d5ac508627a2728218a13e179e63201ab0051336d5ed60e8adde5df940de77ea34a874b85fa098d1b518e57cf2d9c7e734b84f8ed120b31098c9b5470c1970cff32eb1b02fcd52a97628e763591b2585c53c2086ded96f46de4e834850d9f8ce9a5d576edb22437e76407c4d5bde63e9b8b9f321e6978a997a29ba3adbe9e03e744319c86c96b28d2f556e341cdf519caf0aae9ae13982e7f03fe89756ce7acbd8426e68f9a6bd692a1e6eb8c493781476d5c015a01d511f1aad7fc89a07b180f1d8c976b406718db82fea906cbb22f2025029c1da29640b171162e63901a712a3c31c720af0f8866869db7c58e847d914eb353a2dc9a453fa00b302304844b9da1b101b3c2dffe3b52d4620415bfbaa32b9116bbe7f682da0aa6e68c2e50dfc7da709d4c9f4a2ac03c36c995f65b508ff5d2f34b6cb367697840b396f4b9a16f5460417f63ddac7c609582183192279c6ebbe0a49ba66aa3ea857dafe7e43b775ad34c1a71d98ffe160c110d586d6d8ccc59642cb9f4cb7ddd3d7ba4a870e0a13784bf75e06080e39b65f344c643173f4a34e2ce5ddb6b9bdecab7c75bc3ec1c73817abf3ea5efe72bcc1d787e562138e45f8b4be634a781cadcc004da8a6f31b4d365591a6744e7b9be148047c7d04ac8740e65adf20aeb3153d45ae64d9229ce0d05c672957586c4303a0131d8290195d3d774a225cc8afb488c3f796e94f6a47dc2c563cb8af84ff91e2468443d08d8db1d6c3521017c47c55493024fe39d77abf1fc80a55cc00bd838bb49898c469363bac7f00270a929fc4d540a471625be77c182874d13a5547c6bfa7ae8f0ad9513d5c5406a89902d74e0de54cf79ae8e860d2aa8344e6492e70aed784434a5f27d6eac4af70c39036ce16a13538678ad6828647ffbf5906838ce4ec789cc4f8c36add7af5513df2c97959ac4f87c4e717fef3d48f19c17ac7918d2ad3d7ac8e58040323f24d02551cf648de3036756187ff4ac07ddc37b53af61e0f7a357b6b91c3f60247f86c160cb5fb1a54fc0c30490e809caa161c2c7b82f345008847a76a0e8eca4c6dd1c7d20984a9164035babeaeaa504d6c5c966ebdca7ca5559ad58257b93637ded5903c1c9a20e65889738a16730e950fab26feb0cdc4df39ab6c8686e3567b99049bfcd6f1c1dafce349bb6a2f5c050f8bc5edde4ad7691c5f4b0c183559e8de6a1e6108811e4feae1fb8c236b63b6014d975cd66879cff8db8c365c5467b799bbf06510760cab67479ff30a4812042ed2316486d829ed06f198a761cd88fc36a07ea4727ff0b39e74fd47e9d2071e6575212387ad14044019e39a89f14fcb94a11c03ca834b01afaf1cdbaa7dea463ff82c5276387596a89a8f742b61d68b833f3772ea2390b80136b78b516734c4a3143f87b8051d44ef98c9a9da421f2f4dd4ed954ff4a05c270d5d9e10d12efe06d7fc32c045215a70c4aebd10dd191e852da80e3c4d18fceae97487959a2fb2ae836ef7e962c1d3b8dd62564fcbccfb35c1730fcc51e44f872fdcc7b5fa2fb3cc1c5f1f34225655f3487d516236a5cedb98ded8895de59ae39de676ca6814fd76ca2b12ccfe9465ec34859883b1aadb072f5c2c446724f74cc0a5698f096917e8666821433953ae6d27fbf7020053b4406542658b12a4d05d296df7bdc594f7a7b14bfdbf59cda0e920b0240d39f094620cb7f0c0481cbe3367158119ec068088f464b3b86455ae9c0044957698846e78bd9b1590bcceb423c7a3ed17eee1f52be4be0ed61c701a5d6875835543a431e18b7beb92b8bea7d68c91ebeac4de08c7a62a7810b938f2666104296d62ecabf559eb11cc4f877a7c919e824653978e720a72ac33607f2eec62e20af6854549fab8a11e38a5bfae782c2fffd7d0a738e92745fd274d75a25b0da425a132b8b7abde7fd0c87b7d018b60a9efd281e36b6e88af14eb536b9fe3a7989fa286d8c7e0c0a483c38ad56910a5f019245457d5f5c68ebddfe5fa4b2a81eb1be7ee11896a7d9c06d70fca6735fa535df448193431b021aee5a784e540309edf318f21ef2782b07c6c44ccf752146ad51c7db2f13e5c766b6bc839c912ca9f9e3c02449fb45fc6eb9664212cc298ccbb554aaa0d2ea59db25156534101b05fe11b3b9eadcc41276cce27fcb667d22f5a0159f0ddf519f5bbe2aadbdc3bc28a0d133135d3b06a6f00585013f465ce6a8bd2ab9265a9dc10305eeb450395eb05117396dc9c77a3fbe433e0ebe7690616e305f85f23768c4e4da3c594b662f840341efbfb6afc473598138337daa884984e969ce059a966ec864185c50cb2b2cd4030a55131f0d61808e2f21490d3ab76ab4c7519564a1e5ec9dfe43fd68eb440748940a2abaed51b9a08c8cdea1fdfc459e36a05c38aa0286fb0ef959b55417de83472b5609ea796c1f458d518b756b7eb1e3927c1bc57775a4c9f689e21d16fb0662926e5f558bef30cc01a28a6bb915614f568fe9745eae02aeed8cfbae56de5a1f2d42e235f5d82f569606166167e3dd793b768a982be3baea6ebfd784229b2fa42f0575935f1cc4bcc81f18ab93df5e606a3ebab1a9cba8bcb283ef99344c5f56e038bce400809812a46a6766076b7e877ab342f250c52fc12a66cafb64b057c011d8f3491c01940a18d6f1de022e9518c96cd292a81e19a8a287fc9aaa04504854347841568825b7f6b0aa87a44283c6713a4a2a202405ed5825f49f92be2ef9ba034a3034da865c207a1811443223d3e4d86241eaa32a39c1102d93789ef5649d073fa6a20562afb1105c7eeaaa76e2d5e2c7ec4427b86843695a3c4c9c080f5c6323bd394906caf659b81b65463139204621080e9280f03015f3e9bf91688b65cdbc250273f15e86f61df568ec9bce996f21bd155f629fc717355c236c42879090ae49814cd79b1b668a5b595d3db74bc7d57d9ef0b5654c96f99ae35c0ff7810d75d59507606ae728c51c6473654684eeaa04601d88c1bc051d091ca1f4c9e8f45e4c319e001d6d1b4729a466fd8b489a37ec6a688cf43f57a6d64702af5329285827c76da7cefe00cf4c21851efc2d1866cff052e2e0ca4e6f0ecd87fc922fce066655b4391ab724ba411bddab721cb3235ff34abcceec2a509d9adf6383ca65cd9011ebf0784e0fa0c6f2462018aca53c974cc0fe9a6aa35cef4b282ed539a9152f7b73230c5d2dfa315977b801c057c0a30c6df26e392ba77ddd0a8dd5c2232326fb78c682d44259d9cbe2b23d7c3a9ed3d4e74dea54b6c619ba5e4d5b0fbf99286db11b690aa9c08aed80023ad8ed2945b3a6cddda7d5aad9a572b9a0eed860a06e985004b417e14950196f7b848c9acef45bfe84120d4aace0e019000134be4892f806cb30e582daa64e5f0858f6e0b0225517c92b2bed9cf398495750fbdbe3fe9ebb7dea16fd7c9cbb9aa0037b4476dedf9eb8fe85efd12ebabb76dfb291680c7e2f7a7c9a8dd9aea09917cc05cb79c50fe6cefc70345c78de1d0ad2582d453df2d5df7636f7bd923bddc228e707aab0c9019a780cb825810b89ded3381b02f1e658e3cc3360c6d208cd9cb236d10464b69f2b3799a4eeeaab21a8ab4e86d44f9c00a50238bcd541d88157c40c9656b65ac24477fdf719188d2c010dde834dc2c0b9e40504c4dc7578d24e5ec095e564973e0bf285775c0734e2330674d64380ed31fa7c8f954f6dd0c945a9200adcfc3c19cd3231de03d21f78a803d4c39a5091146af9de50c83860ba91cdd39a7024457e2f2afcc3f43a186044593d04aa681b71e44a6f5b6ca7a55e60354e99ffe617cd314100af0c70eb05fe8c696d4547800969f7e702ecb479b743dfa3a7023225edcb1aee76f082e9c110bce4ef94fb5a4e71a1b21caa4efaf8ee03ac7df288ef949f1251ec16bb29570802cb10c9f10d6adf18190ba878d3395b7f370cf86f21f17d901e99bbbd7702cb34f920d8611e845a3524530e3cdb6cde594a262d12097049d30c85d50e2ee7a79401d77230b09348c826dd380077d9d70bb91275f27cd86b833fe1b5137d504f079decff97a818d2327dc1e857edd02da62d7a788c1f5bdd8583ae34e70a179f386d510e8653061b3ee56f4239944ebb85d68012752c0a7e2f0055ec558cb8768cae2a701517ae7ec4b5bc60d3cbb727bbadc5141c60502b790c2fe684b5b9f1366b8c41f637a63b1cda0e1d4dd1c9ced198a2f728bb7c0d27159be312afab6a6b6d66ee0f5600ee8c74c64b1b5f9778ac9ae6e41fe240b9510321bb64b47e0c2405a9f75991a680f02c0cf97e46a0cd3964de1a0d8a058a522ef91bb95a8fecca84e3fd18e8a9300193d4e1e42386fba5ac56702c3b0343096af3cc52ca72b9106181b183e75c1d37364a9a7c8e63b334581a2b1f499d985e0256cba4c792742ce315a159fea76c5bba1d2d9d59915ed1ead5c713946a8e510de4916fb6b8f71b185bb9cea798f8d08136b743ad990bcd56c3ef6bbeba5151522a55a0cc7c9ee65bb79830cf785b52622a3b6cb061e4145b81d025bac92288f088ba2e96e3fffba172de3f0128a00576387405b7590e005ae461e3e2ff5b99b08d3402358518c1ef4e7f814333c470fc6b2b38fcd71da7f01e539db0700f5052794df025f519f3078882151d99d36b5d2af1178113052b00616901ad85d0997664ead4d98fd3fbb2c1f7e82318bb36ec8019b2fe706d1da6a01d56d28d7a5afa3c8ee44f2e6d300622ca4c7ec7da0fc9f3c736be7a8b311cc96f6a57159ef12d476e3fa2abce295861c7ed2e1993f84cc7fa6179617dad1bfaa9d92ca96d199ef4327f1cf6eaf0306d624a0a04b898650e6a755e15afe4f34d9777c4cb76af7c691a1dbef82b67296c892140502d942d49a7edd5167483ccff0a1114fe87d5990c0a27f022c66e23a2c32124815e9a4d29796e63118f42a522efc40cd359c49af0da69e8fdc87088ecb3a52ae8965ccf7d68fc2ef01986757d5e5587a6045c4969b2e658527b1b49660ce6282e0e929f5d6cbf1aca9bdbf36288d881b532d071024dd5531cac07feea1f91ece8fea3bc4623e4b1e102190903042a08758f1626751dc9dd30bdcc0eaf61a88e8e71e6eec9953a4d9dc23f5bf1438fd99c70096eff1f28d4f294be7641c78ad80efff492aa70d2ff1a32e40710a6b021e619967b0ae4c24db392b4889ac08b158229194871fb9eb0ad3b9e0dd0e2fc7ebd2e7b1bb90f71dd8d69c73c770de27d591630c7746e3552251f4456d60ec4858b49ef4fbaa71c9f37fa46c884740d62c3a86b7db28a68c79a9dc5d24ef04610502db3ec2b0d606ded6c9b8dcb56ef5c2659173935f6495812ce7541fe74307a744b2e8e2b3bccdd0aa369f2095e1e04e7d76cce1250f35af01514e7e7d348197e541b95332741aa541994e2849f073d09ede542315307dadeaeb78dbf4acce454b3820545a2345f61782fe15d68ca90495fca6e87067c3c16ac8bec423be3edc5b9e4a2cbbe500d281e6852c5f4c410ab0eeb9337ca3384f3d55404a6528a046531fd4bc3c19d82c94184da7180ac1070ff124c5f55d1bd8992aaef7cd33f867ac238989daac2de016d1863d0eea85329bd7f2dd9f742a1345ba35375d8d544cb972a69a06bbb10878fd14daa0312aff3ef78e0349948cba594f7dc5e51f52c92ea2bc8320e2c7d31da42b5c49e81b343078854a2ade5e63b381f1eac63a9a34e6b890e704aa0510de38ab2dc65bb1677cf8ec4cfc1dd75522791eff7a20b388bb0fb78073b7a7872a1ac5208eed10b8dc4d46c8964be949322ccceb87f1d1ddc37396f8e64f94805c3053954d1cff4d96606f1544458e2fb049842966a1b9222d6ca061dcfc0883e90d7071d2f588dbb864e0ce64f3cc5b976e24b39e81200fd168bbeafade8515502c7b5b34dcab0c0a06e2f5cc0d0ca22ba6840f071cbe3ed28d0c9ffcf2d5c3baffa98f273bf31965aacdddb6389e5ec22385ccfaf68863e9106c1081ca70de5322f220f8858f4216e94c7ae0808ddb87e61115cf66fde23e11f62ea9ae413b92f497beb24d93d600b37ca502ea19e3d69485f607bb3781fb0ac5819bdcb37d73bbd5bc33eef9875fd409e6fae9e8d2cc588d45c2b66404ea4585d1d817885cbfa48a9fb37fb7b484def49bc12e69ea26eef239415f6b89903c728b5be69a8031547e992481cf98db14a75ab4608887905f2a382c3b9a49193ec4ee22509bdacb2eb5b115760709bafd9ccc8cde822e47b26fadb82b59d3313ddd561e58f4cfe418b3da5024783b6fee6ff27f2f7ce2dd0cb84ac91e9faa1fc4f729dd9354e8e5782d6131ff21c4f948fa626e57a47926091ab147abd4d8a0eb7cf0b933428f25529c5137af081e89b77bc98cbf89742352f51e520c81b3f49d26b9a90cd13d5062c41a935e08482d592e421090926ccb68b3d9ba1711c2b98f5dfc2d4cbaac938e4ca9a1a434d59e132dcff42c155a12f8d96f379caa4fab5793e213632953a544a3b06a9975a6433cb1f335c719285678eb5883c342dc11f94d999cbf62e9cc7ec2117fa5a91d88b31956bada7cf04ef35b0a6bceb6d06647f986b819e37b658245d5449b985d2966e4c5d76ddd99b9db233398f3a9923c7bf03f349ab114a9ae3231153711f64d96fa689931de6668c54f5709c87e88ab2c29e92c8e276f273f0693cc4b4e8355de48c423482bbcfd19156843ae73641fe498af54dbc8438d548b56987516b1702e467565190d661bdcc570d096b214889eec80d1186f6f4980f3847dd0b48ab31c51642125ee3e83a5033e6ce4c06f1ae6e02424bfb45126501ba0313f81a878066b461ea0df825d71f6be3d5cd8aca420978cca3718b1da5ec58cd8aac3296eba3326c80ee6bda4d86d1bb99f028765069a6f1353c3628c8e138894527161b5e2564de4573b1d6387f5841d67588a66d58da6c5f35f3259cc66c25faac06cd6d60f5e1ec4adb8310b71bcecdeb8ba411ff2ad9ede124dac56ba87b153f165073814ecb9f7ed07f8104c1ecb0e1de7faee62b8b4faf5eb356e752991cbe337eb02538cc11dcd327a9ce9f80afa4210714bd3e2c2ed9d3e1819d241b0aa4aa0e024af966fd056c1550ac50ad23513469b607d0e4b7220d6a783d0f4cb03e84937f904abb0b89fd6d97ba84c63fdcaead42e91fe6f9d164e19fa42810ad37cc0c99aca2f39ac063c4f3e536ae2b2029dbd56ff7bde71f92924446166148b1ce04d957e2b07b987f8cdf36747594328a2634ef2ec7face7254fc78d30b17c8ef83d476e899b2eeaee059654aaa27621747253b34a78940ac5f6944096b7b72bee72f8c6cd70c32ac6b5db674f8d3f94821854ae7ff316e8ed51b4f6ba0ca9cc677f417b5bd39b9f3d15830e0285b9bf9e42e6d3d41f27600a1e2c74be7f04541b5ce96b49769d106504642ff23afae5af20be80e28ef4e8408a5b618a0992157f326079636073a8cf334e7c0cd3f0ce2efc39f508f016205a53150fe91d9d29fe4bb6fc465a4401f909782503166860fd16bb6a9ead90c7c3590cceaf468ea3175fce7e964d6694632f2b89ea4d47e03030a819c80c01ad81ff51657329f19ccbc4331445632580fb13c15f3d7c8b5081171efe1a206e5ca3ef061fd6e137e75d724cd825dcf25b80719446b9d42df85bfb89dd00defcab37e2192a90afe0228a68d89555bc6666fe104f6e0f43c62de6e9efd05250c3ead8db85edad8daf22cb03e62608aec76b59a62470aac12c99bb5c67e92d2dffa746666a19d7484ca88993bb4f848850e3f2d354246840d71b36781d0e5387757946a4f2546a71a277c0368bf6c9c7fefaea17e1ca4fd98b15a35acd9f8c22809490efd1f8ca999f8a3c609a16fe467ffeaff2dc42e35154d3c121fb22aaa1bb071d689d205583d2207097fc81bcc097d4a76321cdd6e2224d5e01d54713f35e05a2b8de5b55dc56a77ed51a59a556e237aedbb8a32a4632f48af7d2c11751b674493fa4069300da2813b6a0c7d0eb2f36f12df9292a66d6dfba051e08ed534e1d7b7c502ef491acac2f616868f747e5f060b3cdc94032ce2995dd37fb15594ab33d27ff4b933b294a57184797c6534bf9a3858a4dc5e57b6d5ab8fb013c2d080efc5928adf09d691e4b1f1c55701d19af8a593fa80e88358f524ff62f4b1efa5f330d05a8f91c3ca9aad0a930c4b555595df979bbf5c0be3397adbb9aef8d6c380e5e26b4de0bc199731c5f1d11346b9b385455475658058796713ff7501a29e789f5c590c9c7b9e151a7ecd74cd6aad0dab5796b434c0739065e737a114162b9b248d8ee41eaae78f694fb553c4d1dcb9a626c4c2226f21f19aabf78f0d7a5032f7f343647573538a9d47cbfa76cfade2f4bf9b5e89a625284e1ee242cef14ab8d328e7f8c96503274ea11353210f15f8db1bcec2841227c16179109160acc20bf4ffe3ed50f27d4c46fbb65abceb7b09fc076815d91a852135f95e3ccb19d4ff238afc96ca18926bb57a3fcf311e7d3480779c2b678b1ce6e6363fe4e63ffb951b3dcb715109d123e72e5f1fbcae9bba8db949a5b940ef49997b4364b32dc7d5ad40bbce49cc163313b0a16d2138fa3830617886c82c57f3fdc197ea53630b16075df1945bd722e0b6123ea92630a5d7cc5ec7424bcb1efdd749c0ce4e9f945bbafdf717940466af04f8af073e4998f354349c8cb8780876bd08bdfd1adec85122fcfb67036c8352162926ee256f245207e256b02a5eb5b7ec3f0935681cb5c3a15481de94d739b6c577c6a66a47b767b5d83fbb9df664e83a79add2380a4eb33f095bfc617d424a61013a0f9b7592e0e9f4ffd8775a5757c5128a6e73a8945fec8dc645d77a6eff85ffdc0534949b59aeda7c4f77a6252355f29a618d7a591bf7cf56915fae45273f660156d85c052e163f07eb27a3c485743000e3263ed62774bbe1b10c8d6201fe3bf154cc90831c1eb16016d1d1ff5bfba116475c8ca76864d830816ed8b54f5650cffd2b0272cd5a016055f203ab85a7e942f542cdd515e3831740eb7d08bb00b81a6ac841aae0aa62338289bd5da97f2ea212d20c15fabd900a150f2fa03dedff75cfb0aa3e7c6d71170414c068c5d8692892a99b12006f89cb260f1d55be060ebd34642a1c65007ecbc696506c5b24bcfcd01f5bc98300d5171dc4a19afd70428c4f0505ffc3304205be14a520be008d811d5b093a98f208ddb74ce9ef51aa1113757a243410b2e2b56bd37da81a8f25b08126d2d0bfe6d9a530c6e5e571e4b0f05bb4b6e8fdad68609090397c471884d20b479723009fe5434111824523d7b243d07fad55afd89020cd5a37b4c558b5c7b419b88074c737ee7dfab0a4fc8c364c5b810cb265d1750a93383a8ed57d63e034718e4c5106cccfc093151916c94e06b9fcefd2483a1dd2fa9be6f98a1b56d3cb56f677f2adb1a695a28cb8abd6961bd6a36b0f1a29129c5a0c2bbb19ad8a3a0f91c545f77a32c001ff972b88de107926114278dc1ef143d4abad9cf6bd638e7ed93ca59a3543239be204dbc52e1685cc538b3448be2f09b8296dbbce6efc8023ce05379e1a7bc7c6bf5831bb3ed5680e76e74c1be4b59334b0c05650a7892cd27daa8d2723f6d0abda95f8579796baa4a2c1fcbab0aba94b7731f106e721101cda28ef9896dad52daf685ef975a5ece0fcf0ab7ed30a4dc5adb2fc98af022b47f7c30d39456f5c44b3d6619717a467686c8aaeedecafa4f05e0946992b7bd39ea9716e78dbf6bccc39a819364e925167b0ca6ab81dcae5901fb28527919fe5c828885f548baeef09fbbec08a75587a4a610b5edde4a53f7ba97f5c3c0c383f9a5ee9dd5a0cdaef7738709d0f5ad1d7f2750d4479b471a174552dc37628457c2c3339c1ca6d0d5dd8182f8b2cac3404a80c209d5938b7c0f5c6ddab40077f7e740bdc679b90d4ae692d8cb0d48993c4983e3cde9b9735e56f45920b372632f450616af23b861570f0f02407ec21e9568c4cc7309d4b726b7b06c1d35f9b687a49dc597b4e932a63156c300bb12ee0a5b59725c0b404186618d3904fe50e2d4e337ab56bda795daedbd6e2feedea6a03bc44fb9a1e2b65f92d0bf3fbad4c62973938185a6135776e7d6902b245fcedcd957f5554640909f083df5b87dc294e821edb8c00584f20a0cff41b2294f0dc70706d92dc47a3aef001a026e5514ceb1b999d64b1e2347005975dae3038fe11b931df65b8729389040f91fe00f12209744237aacab5eeb8ff803152446392c70e56123c7c94bf28aae6ca9adec9db1d25526c11c10671f516bcaa5e822ac12345e5f85ae2051f85aae1b05342592fab03285accb40523a024e061cf1f82470c2d83ca71fc216c9e8141fddb8505bee3c4acf23bfb0d47f5602b42aa97df2f721208c99d0830dd9bda3e8d59c66fdf8f32f7264f0bc8304906f691f16d697823c28b68e0e90c3e51519d1d39a8432960b0e14c203fb1e88faf8fde9aab9e215be577c9c92bd9ba1403f98f9b43ebdfe306af8210a97941f2ce14f9d5a7ed0bcad1b84ab36cfd020a02f06e1f90cfc284bdb27405b71e0468742aa08bdf5b753f25f8cf3e3b551f1f839381c0f71364167ed8658f801bd4ea82f8db3874dd05d57530b82d3c1e4df25b912109715e92fb893cdb4f678554c9470fe99120e9fb518a4b8543848aefb6f54c405e19b1b51094e0c994f81865b95eb4091df801add815d0265dc16bc83e69eed28d901d5bfb6bf95b8f3f9eff37ed2e13b717d8b52b13732d2521145d433bd3005191dd1de7f92fbacb4c9778cc107c86c4bef7e0b9fb154d2cc623fa6f784029056e2c061c0257ba5d3900c6a2e7752ac09474cbbcbc1a20a27c54e6e770093eae0a896871ecd3d78b84155531028a5cdcc6344831f9f1b0d8cc17c09e6d831d931cee9b86ab4a06a116ae1583d807e877628130c68f113727dd12b534fc1eb65f28b4cf219e51dc3063e228df6597154ddab37d28d6dc7e02c483d3eb2a3cd9b5f21e487938aa4218f2cdad67e2a2b22646955da1091d98fd974d5e152be3e45f02b43f42de6c1c2186ad4bbf7648ad39bc19d641d43a4f2bb3145cae449375bb97cfb627213c11085cda49b8fb02b2341e0e539d04acfb0ada93abb63553a62db28d64da8fefb21dfbd9e9932fc2fe5573902f917aea05892ec511a28a2fcf9671f1f68a6ae64abb7921475edc73e42f018256617cbdaaa5d0d56057d42fbef17e4a0ae12928b2b2e245b38e4ce6eb55c8d9f46e9e21da0b026878f6e7d1542604398a5425df79d1e0bad03bad6c1a4a0f40b0a4ef9c95e40e844aff5d7601f254bbb1197c0f6f548f866eac2130376d9944c452b7ae172cc619242e9ce65b65c9d5f713204f3181af4b572be969a5a1a7f02e0eacc213bc3e53727ed8cfe983ea140b357b7f7814121786ea5f4ab3699fb6f095033ae024ac2cb0566080a2844befbf31e75596abcc0a7506db76318973e663c5a0e389457d936169090bf9f349a03135007df5488ab7c0ef412426637776c8608a7ffbf849ce3d5b84d1477b835a7116bb32d61e12d40e68c3f9efd53a8b40604823a71292467a4c8b55e7ae2eebf65bb79c51281764bfc428bef1f100efe8a0fc693e8cd19e34c9df0698c80194e13cbebe43b295481b76f3a67f5627c0a2e3aa876fb2443bb132d3332930b08aa09e032930d62e371b8855651e1b277cf54f3e7057120e43110c52ac01d91fd0c8b6c8e950ee4e946f5d422e79540ca99a68a8dc562baf903e60d2e087e64822b62ea865f585ad40f425482bf789eb29ce88020bb986859912cd3fcab6394a765399728cec491d9f37f4b79586debe5944b6a02ed2f555e23dc6f3a805f9b65d4c539bca59d985a67b689c459aedf414dd970890b702d0bed5bb5a5102168e6532e1fba292dcc3b454df3c1d6b5db1dafce11d0e59a68176b689515a655cfb5e7c3f13c467fa5f4009876bf84fd2a1e73f44a457b00812158b80489f0adbeb835f82347949a885ac4ba62db25f34ecb6ec434db8d1fc8621106261cb44adb68be00e84aa1c7aad41ac7f464222d2b81b3a5225da44b4042ff197b795ef321fa19979295c67d2695f9e0a2a642b03587876c4e349e6af6762a7efd386dcd77311f691a5c4ad509fea4c29daff9fccdef3acc83d27cb97d58a592e45687abb1a9b5c3045d14f43ba97550c284121fffa3ccd1a5b92872b178c5a3c5ae399cdec48f1981432665bc921b316740e53d83e09fa09794bbe93960ec45074fa275f56db2e9cb10373fb263ee8cd2a9d86758a62829c5aadc076e0200758cbfe0fcd14046d50b01231058b3b6460cf66e9ec952a4e740f5ac3919b22ab89360d2a37311480b01b3de8225ee594de4f2fde043df65cb9708a19bb41fa3c4a002a2fbaee13dfacb83a286882045ba2c7ab469352204c62f15a6586cb971c5d7f3068e1771d0e92f2f3fb668b96dc12bedaf86b7e92bf4714d9662e08da1a2e260d0e543f21be90173ea50eb190370b7b902d1ccbe33f68b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3be029b79a81f6301f4069e0a77bee15"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
