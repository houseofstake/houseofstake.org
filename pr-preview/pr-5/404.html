<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4c764db6a389ad0c73a22ebacb201956db7ea11e786edd8c2fafb2d8fc80248c8b259ba7ea3019966b4784e078a4ee0bfcfeebb9d76027d5cef083bfcbececb73784a12aee1de83168507dc21972a2358f33000add660a0cf5b55c2e54a5180d6f5c3af5d9c7f598cbd9017fb7ffaae04c278b4472d03076ff20349c7b5f94eac3ffcb7fabf840f70f30c99167416f282c80ff43554bf21c2184f9feb0ccf1f35b5029aa9e293487cafceb3601040f511f736918841baf03e17f259788119c65091b59496ccd50e1f6ac92cfaa3369ff52de78f5042d7de77a2b1dbd08d521393f4f53f115f641852f1cfde8ce0850b6323f5167d2a78c829fbbc96efc0bc99be74ff27ccfe4dcee1e767bd3a84316170884329255ba127698009984f954e7c1fb555040f791290d4cb498a7798fdcf9451708298076f58abe771cac142a194f2196f8eb13e3b9c818ae392050e5017b3148d6e68cdf43280f235354984ff08479285b913f9928fd5477903b9d96d20cced4df70ee111175e99a6bf746177a7dd29052c8373fa035b5367fdb23e96846676840e4c0411ebcc61c026a0e6d6cdb89754c6abb4a8fb27ddb832b98bc83ecb267a16a5d8eb4d948b057aa80bdd38d7d5419121e693ae994ffaa5eedace99ddbeb37d8f95af628faef8660a614bf99bfee8210a2f1817f1a2f6b4d0610559b97c3c856eb1f938bea3e58bc90bedcedcd31355845ebf303b35a5d7aba1c6fbb401ad7ff0a2077af0836c5381684df85979a98fe7c426af38619b062e6bbd52f2bb0c4e5e247095676e85ba552a68988092890de42f937095cdf5b55e31dc285224e879dca12f128fc6883d89f2efb2cf8cf8aca11b25628d039dbbba4faf24aea0fb8af20031794f06b3f08abf984b94f691d471ba75cd3b01d19602f669b4f79a8122bd63a571f56fc8ed10e221f6358aef297e6998e63235ee2419dfff97ef1f0939104ee98aeaaa7fb88a309f66a082a25c780d50e874033902314df8cd24a00b110fb7b0e62847bb87bc64b044f049f1b0722166df77745899dc476af912c74a6f3ff528f338049530d8d279c937a328e1a68a5e644ec36ab19f6392ab34565cf42fb089772c60bf392b52aca8845d27f444d02b7f92341d83c0bbf7265ab374aa3ba6266da91c0c5312c409317030d65e2889ad9ed837b35a31c3de9d4720abc874c4388930f648518e3b873af7f11b3b0f46ed9d793c2ef3d7cea77a99aa550d5da862ed20c5d8e511a992e7a79d2499b976daf2d66333af3e5940a8da0299feef32503b74a4f8af2cd6d1e934a178fa9072be21555ff3ac3a7b3a307aa349f9a343dc4285fc2b9b717ea67bcfaa38454cabfeb23384811350c02a97a1a22cb39cc2df342d4999f586ff31aa40aa964f8cb27d54db20f69f59624f06cedcfd08aea829e9191cdbc4c16fabc32ab1c80d35e59c14fd353cc2b154c06d359d85820f00a61e044628899aa6b003643b1abdcaac424a5a72519bfd4882f7a03f3c5f8845f52d0373489ab7fb6bcb8b035783c4bd1486a5d5db044bf47ab0aa47917f7cbc6675dd7be91f0dec606f8e7bfab1db59c3fb3db29640dca5edc094a53e6a3cad4e177c5ed118d27a4f369ea3224e394bc9f061c3a29678cf4762ed3f3d4f863f663311f9bc6d7924521394771cd826f574d9788a70ab1d0fa206b599079b85e290e6ed63ed2d52545100e189fc78acb794c89624c6b0a75e368b8e54dc66653ef2aed5425e5f9b377f2c1bb434a1e45f5432ee043deb2f4c4cb58785ee9e43a32100e2ffae52eaaa020c4b8f920ca2aeab02cdf6ad3ad115bf4ecd41af228c904f8d8fee6a38b38558101b32080aba6e992e7ffa14f007366736623edfdd8b309e68f336c084d5c3f4fc7880ebe117e54c2db389243d338d7b9580b48d873dd0170156681697487329dbc5605b1558bc85fc8832b5e13c7d84b88c9d39b3dbd167ee06d63bbdbd68f3e6fddef1662d2429b4bed1209c3220e212ddd6fa33164b8f84ad8d41e957c45a3c2064d1149a5089871b253e0671d2fba978af4ae11a4a1acee3f90c3ba9cd4250a23e8a673a0c64c3b5b1db9db1602f88b4b3b4c4a560711cd85365a30197323043a34d27b9e55b10c7cb1919e634ab40c89ff43d97b1b630d77f2c8c452efcc0d407ca1b4851944873ca13030a4c8227edea718f4d09b65d6d9cb3acc81e9a986caf8e26ebfd0865e3239715197be0de01efbe94c553a8d8dd1179689b3711905192ea35e9c65309b24aacbb4f10d6c9dd569fdfcc6d8871133645ce78df9d9670403827814cc08e47044036d0adb74edf95ff2cbc16bacde301c795e1cfe65453d6fc3305362f26e8c00aa27fe9450fafcb3681e9baeee6de797d7db85b93d3e6262218f5d464ea53252dd482c019d19077b69b54ac0890f75dc6bc337c5caa43ac3a720aa09f5214b972365b534fe75e4466ab1b0eb825d2ad2ffe7fdcc7c167566f9d4721f71a71ecda2afc5eba72cc6075b06f73ce493dc6f2a62237dfc8256ab3d530c75b59346d01cf5a3d8a4d6a5dbdf675905fe78c13cd393b009d6492d23307d7bfb636ad82b9297c3fbeb054ca48c6748fb946f6e6f083c75692c96bc98c38f88d7c5d092a65184cd4761e8f8be4427fd32def0d4f006660fde1742411523ab3e1ea99e1647c6660411b605e70a89401f53b166b00f105699ff8d6a1cdfa794b089d395cd98254ee24a0dc73cc7e3f4c053d7f1091c00ede5d0645ba4a3b2a735ebe29c0adcb1afd955fd8b55496852bd3885e326f759db4ecef2484c43b0dcf6887b200fe897283937d892b4155df135277253ad0c7aad1debcef3636f01df069e0b92f98ccc260833ad0e4c739dcd65c7c8e753aa2dac491ba7f5d64dd70b66ecc8b5706bb6324b1d5cc5d8d7e1e8e6bbdb2b3fb4eea17a2b0bcc32e3930241e19a5d436f7cb9fae8a4b59cd893b4acf0186ad0a8551b8ecb323d61089be5a927e77ac66328ad4c89aeed3817456723c445188a9a600a53de0a32a4d21d4ef6faff8eda18bf6727ae7500f2dedb7dfd07f42efd548bea3ac33d33b1b742dcd6acfbfada845a2c541e5cb4b1106de02baac4402c2c9e6f47836a283e86a846b24e15fa55e8078423406cb3d8f80b7b58a4adc5a772fd92d12305b754e505eadcadf9d8ef97c95ab46a7eee1b7cfec7d40ebed92eb69899ba9c15431c5d6ad3c2abfed1784df9aa5713af76c54980a8446d28c620b70169f5fe1c4cdb36a7795869821eba9630a043c54269998757fdb5b329712c03a74148dc870ec474c92ae6a5030ce8ced1a2c1741227f5019481e701f34553e12c70991d61a2e04384a8f68ec21e99c9678fd373259055b45f094561497dc939b10a8776c90b440fc8e87810b947e3e0a2dee6a35fc42986456aeed4e58309e33bfb0e32db13a6e9db564c2038c4dda8f5ed25c0cc54af54bab8409406b4e435e325c6ac273f5fb18608689faaf26a20054eed3bc2073e387bdbe64083f0606ce1772176a4b9abe9814b0e8fa5a5a2bcd8e8a3f81f8b7946a5dd593718b842b1f11c99456bfb3997fecc9cd6fc3f5cc4d2aa5a6e8121b0d5c2b0c57fd56ca8499ef0dac523a79a423cd3e6c432063b3606d88fd08c6b9f272a2fae071b40aaa528af875addecac80fbd0e6fb3eac65012807ec83ebc715684fb65b7053caac7c2a5089ea8f05edbecd379656d828ec2bb275bcb9d18799199e34b138e42289fd407c7919423aeb5781484a9880e8a9fe59508410f6015e320854e281bce1b44c189c7ef4561d93df1444cd2f68f74e0f9958cf8be445d68ba9d9e70a8b650b3f847edb337d26c0922155c7ef62277f4c545f562e3a66346dc4d58dff9fb2a3545af1630247ea0681440cad0f155afcc37a15bce4af914cd659f129daa7dacd4465bc65d9dd11c2020232fd5e06729282eaf67f73f9557c603f677074282ede7a058c8e7fc3a3ca8c2935ffe2891a85d6e9de12e652d59ce17493f5fcd29860e9a0fee9aa99785f8564e9c1984098292f17818106e97a42dbd2037deb4a3174634a1f36698b4359388d325428488955ff88a69cc27b3760b88310d106d935b0a84740dd92375db300fe25b7a176ea31a314f6ba036504dde0a99ee3780f42b58aad9ea1b1bc3beb7cf5550934a4652bd81e485a71d3856ef3b592189fdf4fb255f0c0e48108d53f7768fef30873f21471652d2c950d16da5abde3a4452ba29d631a245e823be986b5156aa1e226936a67a96ccba3bf865bbd027c120c6f5fc1fbcddcbc39963c0e8b524c56c4a545b8db9a8acc9521969b86cc661f4029d9b04ed40aea4f28c52a4ee0578adef524d5f1e3a9ae68094d651acb8aca8cd065ad697123adb6d23dedd26749f9e6e64502cc19b390ea7ff2e75ec1b28853ed612783d31bcce0828dbd2e9bd94b88c291d978d968be25a4cec4516ba9fa6ad720b30b6003c115373c1279f0723272825f373e37e30a0d8b45b17b25875bc46b9cf46b0b71b34182d495c452b192ec92938814d98329b155a823ca59776f3eb7f2ee4faa8694779b774c8e1078433eaa2f55879e1ea0b8f03e0646477f9e86b3a24cee814b3156c47107f1d0b9f14112f642a86e7c1123441e2239ab467ba8a703325bc121e3be0a7f3d8abfa06ebea95257a2433dc041dcb72f0e59e57c75241a5ab85c3d27249efcba50fcb14e734d1b9f47a782ec8b6ee57e0082ab64ba93336099cdc8b80c5085a6a4ccd4787e245801ffb36cca2e57df17bdac677194299392fa6d2d9757698e0ee603cfb7dd5cced4f0816982be4512906b2d71e335053db1d8d6c48c6252ab67be48aced365a22feb8f1b76fe1ce376f156dcc5bc965bfabc7583bcf82356c6fb93bd237d9a4bd613172bb1fbf26bafb74a05c78eb04c984460694972ad94bb9527535cce74764974d20ee22d936287bd94ac9b1a30a93b17b67d66a72175e77e604654c1e09b49188878ea2c68c92b754b60772b0e6d2211bca55ad586d1ed83f83267fdadab72dc2205f2586ee20917217da5b736d5a97cdbb9f93730b676525cc6b5170e2fd9a87ede6eea66c4712b3a917a027b33b8c650d684824ada799b9ec6ddc3cce65bc752af9aaa639d53151f300fbe7e9aa735dc5e98bcfdcd83ec545487ae3460f0afefe63205bfb70aceee1730261c3ba86e2686a8736577ce085d4cb2d9f1c78f08799b6235d5c7719326e0c3b8728c747e0fbf18d2a77fa2a5add5451313204559e2ff189114bb2043ef3db7ede12a121b6705255485bd987b9db31df3e814a96cd8319f553419a93ebfa19bc6a24cc08ecdc9c45c496fe2ad58c1348dfac11d4c0372cfe162fbe08a301167fb1867219ba8817818f5fdc45ff27034ccb7a67295be60b7ea31a250e1627c1b4d142088e53bbb919cb4bd20aec9c6b25e6d17928cee0e05b21eb3d621576fd538e145c16824868bcb9791f65083a0918f9fa480220c65b9d0e9580713dfd65eb461210db32716dfeaedd21fb8308e8d5afa1b684f9f49d7a9f16aa7c925d99c2c1d30481af9d87132d16e2a4d4308bbeb8e9bebe7bf05be7f03f3f71861ed46bc272f670a9b93f37100e156a69781d9cfc50a90a3f228d4b4512ba85df0c567f8303d18f2940ddeb3d1d2d819be9a97be624f86963434b3afe9541c884602c918d2a90daa3a52ce382bd327d19dc59bb7c372d99b8f50ada408f59b9afd96185dbc536229230327def97509eba586573aa33ee92b16f2bb194c417d34a9c455859693faa27c1ebcb1b0e9ee9bc5ce08a7b03a8f3ac0c3159ed33f50bd74be43f5a146f7e3f8b70999d498834b294dc0b07956e26750e4d7f6dea6ca53864465d6a0b8f4b9686b685ecd49c77c478299fdb26c2d53085c838efe3132211c6edee690c73af4928b83657a2ad15b37725bbac10fca7b6de213ac474916dfea47b582f6117d6d2827b65b97a3b9bbd9d90eecb9e72ae71c9ffe3f530b6ef3f97540251ec6b7473b92f76554d4789ce89e72ad7d833184bae6f13a1d28eeb63acc11ab0faf7decd092f6b8c0ebd062f0d0a0e22528aabdd2071990381b59db458dcfafff724a612b745c8cedfde129b64995c0975f88fac2e34d1fe7d3d538e71958c980e0ca14c6de865af448bded3da473b9f4b720e9cd97e50d0acf6d5dd018e55e74c9d36a5d645110fd424c8edbeee0bc93929086d27613a34a71dfcf022c73b3fd80eb4148c917cbc469205eefc22a58c4adc368f8beb50b836e78b4bdb2f4420c8d553329e0dade896c2fbfad107f8bee10f76beb0259df716d1fef600cfafaa82498fecb57475f23bdf94781c9472a1604ac89caaf25165ea8d38148e8779fe7af3e2b695b9af81b76e9857642861059e221838ee1b38f09bb2692866b96d88797eab9e114016b080f994337a91b64fdb8d880c021c5b59bdf694e332e479b8d5a566dc82a942726806c08691ebadebaa98781ea96d7b1add333db54d3d6b014e823ed3432feb488d1a3095e75539ca45fd05fba4e42a2480ae55c62e1af0b170a81065163c1ca842f5e1b577fd80b767dabda0219b5fc07e277881558d2f3c46c5c4f927ebc8393758e9ee43e5db329ddf3c391c10e3b71073c21898aee63ff592777cf2996295ef28c71a6cd2cc935bdf91d2d0ab5d04f02364f064c48bb666005f4e25d2ba0f3726db4fd5a875dac1b979a95ff4e053184c5253211fbeed616c8fe35e30396e9784a8c08a82579698bc6791a646897895aab0b00785f62f56104b6ce8fa2ced8e8a140d7a1ff626548fbb0599dc2489fb46f4468e752b810d6503ac3d21f2a84c2b50fb9f0aed5fdc0119259609b37def1f67dcdcaac5c56e05022a284a37d31981ff7073dc68caf471c36d1c50f8a322747a9d131784d740b8bb86b2fce084a2fd9b10bddf13a5b68826c18e7c38af343d52c06998873eef1d5a26232e714ee388bb6e3968df8d909f9ae7de5d78e3e2470d38ba5ef95f944a658f5ce5a7227699bad26e427a556e0b0c980f89975cfffc6b9d95d02d331f5040928815bcce3389d76e2e1c7999a042a34e1a72fe3c12ba3ad80d329ca2cdff3ce879b3e16511a773c10860f8cc75d8bdc52be0dfdb014156ead7ea733b46373956fead2ee9fd5f8e2e59d2b92b927816ac42b263e6b696e1fee5097c2e5a38a033f52b934dcdcd49c10ab13b2165f0ae620ac4f4317161d43022a20f073da0c8ddfb04425609fe75a5991ff0c1d9ea6537380c2df3efd0b76e1480c15dfce8fd11ce5914a7f5f191c573d4fae9c176df852c51ff141b688c4795ab542c76442c619f1485867482759124735f79aac165ded4b775e20521d54199376d73933c6464766afba979533c505689cb2f6b26b8f2b926b8e94e47cc8ba250bc0fec9eafe6854f01db31284c4793adfe8b9993ec7515c21e75353797bfd141fc33eb3379cc68bdb6958cd12b0da1b30fab12fba9d84dd3fdd5a412793e52a2205132f1bbb2389435e080cf67c9c4ba0cc4ab458fb294cb42a35f1dae11ec486065a2656152537edaffdaf7ca68028494bce9459740bbe973aa4b73bd668417d937050c24eb8232d99e691a3c7470191eeab962e8c4f01a3c77a72931cc75330a846027b8d275f79e4f315c638c393c669304feae012a9fbd1a57794b7b90f23b42dc6b9238be067cbf67d6d6690805f93ff321473b0b4dafce0ecc78b15eca5fe365229357f74900d7420cac26492252c3eda1b49ba324443272c2341014fb858464b725a3cf088e28afa2413b35a37b2e29aeb034d3e93f04b92d595dd3064d79687243a7f5bd5fa18d56efe550c886c1a10236e6e09cee9a0d4b1cc6f5f1aa8438c80abb0eef75005b634bd1afcbb86a5ae60ba0afdfa82351ee919146805091aa4931d5aff13d6d95a86ef19f010fba6715badae9a3021007e5dc347aa94494e42bd6d0586afaa1d71aede723b1c89cef29d6d119cfd5c919d0478cebfb713b4ee21d099af17f05fcd068c26a004c18da7d8ace8a334cfc1ddf52bfb85ca481fd07ae835697e3ac6822e169116d07292ed02d0d3207ebde23b8730e5f62ade00556ef069b8d03e3391c69f8e31c9990ad456259fc7984eae8636b48f3eb01953a8db96870a66025348f8a3fcb0de978c3723273d2bc2f7fade1e395da81c639085749f53f1b4bd3b05a933550b08ff24514bcc67fb9e0d9b940010e43371fe204f9e4ef33389aae52a08a6346c8dea9e44a60e97ee1b1eea29f867b4aeeb1e8c88e4ccf2727e1981fedec1407d8d99d79851d6aa804adb7b7613a6548c67838737a44a79899976ef814e4fa4f888e7cfa9d58b2c5c954405679d94e28b7f23c8eb514d7acad10dd4e0622ae9d661ab2213d625a02ff06efe3f1275d694a6c26a0e387ce31ac7b3c65cf515c9eac03b4eac412f35f949387dd91e98dc0ba42583cf4cc8b71e9ba4cec3d5566cd2b050f213609c54dbc1636b6894f2f5ab38cccba96ffb2b65b19117e24bca50e6a7280877f7804367092cf5b5c4bce9eea60bf68890e8313d1829eee5587edc0491fb82e70a2776b50e96e1ca2cb1d5c3c5bbe45cf9d518a415b0d56fd18ff45a39c4aed5488bfb4755be6d1d95f1c3745237f4c44fc80f4ab8da10bdd736eda04d693817b321894c0ae37ee3aa72c813dc09d36153a758bffb72bc9c4d07683e71b827c905f974f303102d703a36086e3beef1cd8bb84bed277172bd4bdab7b14e44faeff7c04576b603653f4e24ef801d7d0651c19fe3d14a07c327298db4b911de00acda0daa690ce867a94dc01d4e1cb4ca1f814aacec78df056b49c5d369b3f89912dddc68efee3e88cc3a30cf756f6dd7ed00ec4b973a14bfa43b52ce71ecfd8bfb47f4774f5fc480e2af77431939519320f17afeba172daf87b5f67d24d166ab89ab939acb9e03bb261418de509f787e971fae48210842102614922179b64a55725b4dda57e7cd53509b06ff3e01975ce3a7ae9aa6c7cdf27f46c2657fca5fb88bbf0b1060e9153d7a40d6eba53c4958da386a14500377f77c138baf3fc1a885944015b61a97b00733e5d52ca49ef8ca1ccc3124ff550f26d202ddf9534e326c0385b4ae20fbefa3c44b0c0c78998da4756a072330861c238c7782bd8d5ea05a365d48fe006dbc32ab26e0c473e32c101566b8d5dbc40e8f56e52a747b2407c94a8ad4f1faa0a8ba2fafb9301aa53c852617d2a4efca667dd92bb8b7c3f86f898e6603dbd99c14a53975e9a8d8d00f2a2c30a325eb6b62f0e11151cd0bc4bc0850d95cbe326533c9fd5a916ed72f08c66eb22efbcae5eeb19498daaa77cecb218e97c085accf21fe84c383f2224465c00af90e3e3893403f8cffdaf1c392c4290d6bbe6b521f12e6c84bfb02932706037be8d89da66dd47b6d193277a860de9eb9ba51cce14fc820b36339f472f09571a7ba1c7ebab5b0f2be1d0cfca1fd56474be548985a0775af9c5dcafb91e33a4cf4e8423091dc361cb711426d06e79875ee17700b29f09ee463738c6113c8ea58fb48dfdffd1f65d714d762e602e0199e141359edd8d5f157557bef2f5efcc702ed5f4c6e8980c8e820b712c58c2d5863f52c55fc102d02439e73d2b3cf13f858e36349fbec11ad820026469f14398b044d7d874de90b79ad62b336b6ee2dc661e5329a10db329caa79cd217699deaa18150acd8089d8d9a6fbdac948581b88b12a79a9c3b4585f06f80ba7bd31b6daf7fc014a9aab1187333d41be1c985e0a293260ed4ae22e29184b1308b98d9ff3beea882eaa776ec8aa2dea838ee653bb0cfa5beb643c6c2baa93820e95f65f266f0eb57317db00067233af8ec08b3e08287b58c40f2b7f623ff0e2fb928848483b3a036f149c40e3613f1e995c9b2f0363a4db763525267a87f31715fba5771319de6162c728d602ac567d8c08fb7492c6f4534f4eacee77c3b1748b5974bb24d40d5e4ec7073c9fe9e55c2ef8f21fef1b4396c12ce42a237c0778db9991092f03f75c0d4e0240380400fc7e18129c6b6eab9974e3a0fa4b14fcb4db436bd2f0ef74e9f9e096c8f1690c9acf4fd98dac5974b3a72a2d166f086eee68e7c4ee3c07b276b2d09c34f672697a9d609e6d1f734a9f9c8570c17325826d40f3f438928a14424f82813191a8ff1b9de29ef429d57427c6d209accda28f9e4e1dd18bad6e403234976982d9707510f46016dbdd04d16c5f41e281dc6d6dcf3abcf6420ae0b8c7816ee5934a6b35248a9b694f8ab5c8197bc00277b05f958416d8272e2a77e63478a1bac6cdf207d4cf832e5ee629305850014710f4d5323240207600e43cab865c8a20b0f70e386c4731da6ab22a9d6110f0c9ed32957079c1a6ba45b8919d1c76bdada432a384d4ff7c49f65cf4f70f158d6f8f1ba9e00a0127610b021ce5cd2cb67a565a71b08582abb2226bc14a2906e0e640b5bc0f8672cac9759d4e6431582ec06d4e12131faedb4fa09ae2c8822ec173165cf5a0151a1944181c6324a74314fd0bf22628b4253301a1a9e014f0729466e83954e5f0889b573b0426f16c871705bafe708a3da16da34d205578c6f7ef2f5b53cc34fc187d9d159df55bafb2d6e24908482ff4fb5150ab06da0687d6e874dff4a334c48132fab01b923ae7aad4ddc9d78adf8e2afdfd609dafdb8874d9ef4d6313aa753fecf168223ca3e4a68479c7f6003c9a4f0273d287c3d2b2d6d5549f52447c3c202d440f28debea2bad4119c790ff68bf5ea9e85f1685f026f80694e391364d3a907feb0802ccc490d0c57173668eb7bc718782ba96b02c8f09e6eda4b6784e5a9287581daf2577417084dace4b20687af1f7e5bbd5e377ca22f42074780b91891497464e03b07f482e6c334004419dd2abdbebe4ec1d988ae441c3d75bd97756865108933e65e505a2550107f88db081a645ea96976bfc9221e205ca936bbde9df0e6a352c333d5e6606dcd8c42eb788a8aea0788e5adf8feabcd55b3a1c35211d090e89e90a311e6e1628b6d9ade6110c3f313775208dcecaeff6184ee2df06bacdc0286ce762eec783fe2bcdf4af16f8cda9352d9c20107d7caedcd42d37c50bd959350b5eb6b73a64cdea34809c054cdc39ef0a5ab8f11c50239ebbbce48aa2b3ab2b3e2fcb4957e462718fcaf13372b180a71c5eb7d124313fa0899bbde9815d8433c65a2f3951535c24ee693ed80595216ffb73f3e3c7dc5e3c2eded830e17b00a98f3f568d6f535f8259ba22e0884eb004b8fe1d09c6941d5f84c71858bc7e72eaba56758647c0491e23976c1624dc2c9391012f098e7b269a3922f19904e66f05992f822e89c427b7aa664d2b1bf71a39c68d22ff5a766b136f449d38d29cf0241d59321a20dfb9c1921b959161dc7ac631699cc08d241fa79ca2cd2e0054fc1c0d3eb963b81a732d6d9a56f57ea584e5f9d0a11b241a61b14421776b091ee02bc206bd203294b21da7c8e6650d29c733cb64f33d75826f4a161b2aad09dc73d889e5f0e44fb27219d1079958c910b5e2927c1d143fb4e996c1e3f56f58570c79c2a279595b6ba7f057b8ba25cad324fbd4da1c832b216e8c30f2118b56b7eb7542eda6d68fd7960dcb9d76b2a2113d56a746100e71482a9abddfcbc57e0a25c68fc0ef2b6f2effa5a91edab4587f246744b86847641789d69b85bbc954dbb6304ea8e576dabe09f43521af9f9e4fdedbdc7b4ee782ad44e0de1fbe42dd04b1942a178c0da1c1b1ad2ececd5d93412daaa234a70c088fa5d2354c9978f55b928af494f83eb0732a30b60750c85063270012efaaa9e038971f1c968c6da778c4af9af4ca2503ca79c440641b9ffb371da65a14df6256d963b4e9b543cb4a2f0e2040ce32419467fb47b2ca64e132419dfd28a79afb97587b89274dd26446edc58549f1b3683af17ab6204c136488f8a9f5cae798be23178a6cfbd3b76e3f2f04fbd62652da081e6120d47849d02103c34576164388cbb7afc365016c7487e0a74816b5f059ff050cde9db58c4eb739ae78b8d1689ae84f68f3df4133397b3b85eb08f1214cdfe0f23ee3b82df66817c506ceeed458cd6d14471ccf006422c95876c80275ad7ec6cd1c1282a55ea9338c6fb7652da90323d6ebc8d4cbaea7ff97103b1669764ce2466cc19062f1bca80367b57910a78646884335da104ac68b7f6e93dd908ebc3161d502d97bb4d3ffb37f89a140968ab31dc3ecd3f06f600d3c0f1f9f1e1f9302b3970f4c9d34fe9d999fbc3d648313b75a9cee37807aaf870d5cfd2bdc2c61a8cc1cf1f8f8ab917e65c763c0c462c57a11439f17a2959d58726a50ff5f11ba696c4b8f11ed5c2cbc422f2c5fb72289c6ce785d15316a09d94a40c6e970222b72822817ed85534d1f8d95110c27c055ce5bdbd0fef7e3bfafbc9d2c73e016436c2dddce084759c25cdba98c6b83766eeed36c10ae3ff25e3095b778138bca4286f1c425f1eb13127811758d5d69037319d003bc08a3ad9c35482937d2c8a4050764e990485027e720719d5d54e5648ac96bbf21937660ae1cda5b720582d720aeadb6b34d8d4cf6f56fe1a307cecbd15a9feec0bfe1753c6d78f3b239bf9d17f6ce5ab62e01a589b4a43e4c0a34905353624f3f0f0e3e30c34f27df600b952c50fd1571d55504687ae89fd8757d38e6496a755c8bb9e95d68fe062178717ac6cd777105f263831aec6df040e5582d21f50da93af55edbb5d0f5010b8d4c5d3c613b4a333f5c874a1b8beea9272c79cab24468caeee0190ae19bcae8934b0456f90cc973e420649ffefe3010df7fd20b2dd5fee5ddfaaad00d525a02fd4bceee04f4d6c1cea53f4dd577327387eb79c9a5be91a686b037c9bd8eb18b4a4ad74e1eece503e0a54ce33cb2d28f6a21fef0a7dca47a794fd2ad748edf1044972c786969066d9db0ff8e367c8f72ea89cde452ce04c32bd221d3afe1f7a2d9db5aeb74ab687fb6f3222298474bd11e4f75090db0f6072d1952e2c1512ddbab8876390760440df6cd4c9303764a2a933a283731886439b1c0dd931f8422cd7c5470dece4214cc236c200047db7bc153e6e6f3aa6ca6793aee113faf43b5515ba73e0de0ed94ab71a6ba86f8ba5581b26bf28d003c69bd36d7ef2712eb5cb6a72a6a72ebd59e0c75202dde369b5caebe4a08a5dcfc032ff5067bac6e5b5e4e39376f0746c5595948a8c6e6d7c93d750f18095c780c267fcde7591b8efb273803fddbcbd3f8c8e94ddf58595ce0ef083fd3d78fa9d4f0a318e0f17c7df9c79d0884258d6134cd2762f2ac0cea528f586afad9d802ace952ef7dfbdf77f2cc8fd17af6bc55d80f4881cef257d46876ff7646ff8dc133edaa25b2f44ea4b342c2155ed4d55fe408bd3058fe85a2c4a84d15c2f7de455ab3842f30d8c2b4236262746fdb0402cf64bf3be98fc1bbf6e4dd1eda74ee86e26cb18f380cd68876aa1eb4d69d490a0462c5f31aa73a87646798b0d32d9a21ea1e4e4219a8de3da2645e4fbf220735f4b09746d82c7324c60d93ea1fd8b6956fd6d7ba6c6a37218257d9eb706dc9ddbee38e45a2a6285a4fb1f015c16c5d8c9ba936e7405d9fe8695932066773c92c35b00685f604b21de205a68cf749c05334a218dbc3eab4eda80b299e1e098c10dae477c022ff96f9b13ef352f360f01953a75701be433d4973a7b91a7568f2fda451dea57f668112123d7cd93d237f9da0777339ec62a67c58c59fe28af1d3291f56879df1eb622855f8f1caaef42043aaca91eea42f7f9b5d22fb8fdd7f76794508bf27d38637255494e886393ee8d64e038d4cc317fef63610408a22e94dd2780e1c2ae5222ab7d38fb9b89119542e4d3d516f8f8f29864fe3f461850b375b140dc1cd447072e7a6e27a62281e3433fdf8c6f8ad246e043fb1ec56b2090db886f9ed5c7428d8dd2fd0ca95496324ac0552856e873074b4c94f7606b3bdcf124dc3c80422dd61dd32412ffb69d76ddd79b59721dc53bb6e8927ca280144230aee6f8a8bc6ce118378d67ebd77194391cf903f0c749fde532b6d7b4fa5df9aba2fcb58479818651707ccd89a0f94b38337d1df0545c071847597fc0359c7a010699021a24d1c7109eb837303b8d1ea931c103f4e051d8fbbb0a3f0e0d26c84072c2e3faf4983d5ba65f36dc00242d13ec494a211d8f6f1a909ea3eb47d0b0381724d2a08432003d4cb63aa90bb5f1fe6618cd20bffa747dd22a2a33cd1361c672de8e18e5932d98d767764efa8291a4ddbba1e22dc58ad99c54be2529f88efea2e6b6d42af412201a3dc2fedb7e072117b27527c2f2f52c182e06cb785e228a00765d6aea9016aff282753bc51c88d097ccad67b879e81c942968ebb886e8ca60cdf14c16308b31e243314f9079bfa9d3d28394930f96a68a8ae499d93ae572659172cc1b0af66fad9458c0ba44bab5140472056da86a9bb22d2aac4b8427d46a0a45aa4c39d4f98a29ad337b5f73d6bc59cc8eb65413819f6b7d2372efed40b60416a4af8d9b77cded9c7ee6e9e6997741bf56a6000ce924c3ef44c32e0a3cd0e1d6a7d0595242c33d19ef69402ae0fd0d6de6e1e257a4093f678b2c7b8728dcb4b5e7f9ba416c758eee054837e5c41a5df7f3b3263418a369333d1ad1bf6d61f5f3ed24dd194e50b94e9f6edbeef4f5c09f8aad6aa50e96525b359410d9ca313499903c49d1d64b8edaf1afd06c20d4e8edfa196ef809a0da84ed23b67503d81d3d3f530d3072282c39c86ca900bf0eaac957f5f7d3a2664bfc5b6cfbd2883445c7d8b315ab6328536fafd9a73613f1742d3b0ef2479b02418380487037a58c5401f78fa4a90dc256a4bb081dae2e2520a30f7f373ed645724303fb9b69f4ba86e18f95b42da42e0f30ce6de782d13b61bf8f1993a590d746baabc4024284971c6017d0bcb7483bcee8801bdb846674cb355396da42db9e970a5c7f27e68ded2110d8ade6b4f75c00e0b11e0e2d93db1c3285f8929824243844b1d5153fcd75f4f04d1d26d441d2b7d08bf568647936b21963844c0f22d9beb4d10daf6cb427aa725133d0389cbdb70221534400629a404bdb626b62d39e7c45f4194a7d883869546b0b82b90f403a90a1721d8fa93b2b621a3fdbbec60f5e7265580b8bed06eb902a6c9ec6711ce3052e62fce7b8076dc8bcfd896da69835848877a12eb5c560ba69003f2d45a85e82f84124f16ca8a0268e19d9a769051374d33a5d6411768de2da466e91cfe64da80e85e13051bbd6eacde4a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"09491b0867e61bd0303e4a7186b8bd6a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
