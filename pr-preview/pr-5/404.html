<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1fc9168c329c7676547eb7341d6bf34d9e5067ea1909baa1cf0a4b07cb44d87aac2724345ca697128704347197e88426370876ec042adebea4733893bb036524baedbbeabba2defd16b7edeffa5abd0136709b79e2a0a97a7eb98535d6ada646335548b5634ff8c6a6071592d0c41e7813065ebc7f641cd07e31143c7aee83606474abb37944c8b32454090633647ce55601aa89dc780b04679b275471051161fda3642056a0c1b404790df402918782040400231186bba7c043ee42418fa0b8c48703cbcbe988ff5a90e10faad8d89efd66dcccfb692e88bb608f94e2fada238e371e5566bdfe6ff5e0233a0017d000a58f95a04c19666b06c6d25fb3c6f616cf712832d23ee112a38c37eb7351f8395a67a13c8a9caf649229eb83cf975fe805db69c10bdea0f9a9eb51f0969a244811cb1a01699c8efa5ebb323b2aaa2eb437e34c52d1cc4226fbda9e48fa779a4156969b6bfa856a667b7cf917e641c4ec155ff770ed63a9d951b32d63b5a6d4ad2689ca5da7447089f4a182321f40254b8d04f1103a421c55cc4539ff9bf20034ff449bc42354add64b1a9e70f70e6fb7409a7820389e80bd07a58ae3505a2bb9e51e4c16c8040932ed0da615ef98a0172dcec020a6d8f3cbd3646a503be2d82f5f9ee514c86c3794210b6dc7cde337a52a10be7459bf769b92e49afa1e6f1a4af16038a78969904b2789f94cc352198ce92944e57e913f7e844d2deff67740d4050b42896568261d88187a4c798a5318204ac442eeb4f4c89864fc198a1cb3984a61fe690f18a012b318d196929d1a92c92aa42f74b55c44e6173c3597d55b9972ae0e0e4934b1ea65fb84ddffef343f03083ce2a9ea92909bedb1c8b4c446a17e941ab66663534cb051dd0e729b09089b7c5414919dcb468e1b1e1f554a63227ea73966dc7fc8fbba875be1ba9e84cbd30456ef653ae18f4b236d30ae0fdaeca50dabbe9edf77e38b875f569c532146336c4beeb63fc22cb3804f4ce271fc4e9de46e1d36f1dac7b5144397a1e0a19234525ec56ab26a2f8c439a20d69734a2e46fe6c1976f571bc360e4986ecc30311281fc723666716955671df3c2c04fc652b3fcb6fc513cdf2286a4e12d185286944de43e566f759979698514dd52a35977d30af91b6311615df5403e39570a21fe48525e29fa143886dcb2ee4cb3d59325686cb8cc4fb79137c1b930992929d9e85043b69fd675d9f095f906d85e5e0537eea95a3e14df462276ff56b108fa874bbf999937f715c6bb5ef1f7e97ecbb25aeea9589893c801d47e05b6b002753e9b0eac1970e5d2fb574e5d8c3e7b5fbea6786ebff7d891b760dc0a2ac98817e98ab0989cfbe0de8547afa818b6ff90e591059b325c7063c1ada442d2c2068efe926ae6955d9106b66f20a59ff84f085ef174808a42a5292e52e0182b23abfb663f6f7af74f65343ced7fd683811d1b4deee66b998fd8a2197e01269f6faa01836b96872895d1cf064fdf96049ee6680498fc0ba1295e63e1366fbf4126f456240bf0623d5d73622233a2ebcf13dedc8425b2d6f218209dcf2a1c860400cc95eca5329854ac24b0368791030c977c28ce7822d0e59e9ab6b2e42ddfa11d15e36e092b413a6e1a089f6f540d2889760902c12fe585e951d0e2ecd60e7cee0a3e159ef3822da12a81b489370cc878ba4b2409df6194d07ee3c204ed2bcebe260932b8411ea09d5d9ae95e8ad20e2e1889a52e3afee0aeee1a8731fd8c07b1e148aa9f77b21618c5cecbf794b28088d6f8eb703506d656a72ff7ada3c3cabc8e226f1780725f91de6a885760237124b8f6d84df6e7ebff3a58994d4fd838ac45daa72279b9ca4d464d42f993e08dd9b8d2e914ad0fdc7a1dd934bbbc9fadd1a1432ddcb6b827646fc1dc64007445a869c1b2aef7e1f4a5c6cf12d8e69fcf37588d1458c63d0c4b164b267f9843370e00cbf161d16068e20d0add69150896960cb7d8cb52b46d77674cd686e6d0bcf67445487d2bd9e3f828953d88e3da5266851db8d906d3f54b65805a3fe66bbcdc516736595f8791c6a0d5ea293a944c2886d5c60016dde3beeb777e03239a1c88bf2d2eaec2f9938c79dc7c6b97d673e8aeb9ca8d550efa46d2c89b65442ceb618e41ad174628357d9afa1299b935b32e2cacef27a5df240c5d5eef612014e33fd16fc56ad8e30ebc95f68df006d6d33fc9823027c98f215c50a8a520d22ca5535739b63da0cb47ad53c7d2a316c8b7a00e1f37b53ed647c50965c9e446df29ec817bad3cc845c813d940f4fcea3352b6b8edb6c7ce8f1c3c7aef408eddd70fc7e4e0299a12fcfaeec9fe56a78f4baeb9770957b5075eec2bca80f48799861307d826d66ca771a4cbc9a0728765ea1b5c0d89191f893bc0d25a5a9d30db269f92750ea07379e77ec243d6ff4f4f60137b0da9a51122317a6dbff508327d41295305f252c9970b403976b58d0b03b63e2627c1ce9f9fe4b382f92fcc87aeb0f75421d434dc28efdd2ed071b8f175bd513d0084fc85dc316eebf762c53af7fa79b2c60367fa953dad3ff0f15db45ec925430b2b51328169520f96aede1dc82b6113b20bd6ceaf6492a0d118702e6fbcea108953c3162b22da8581da3fbc5977e0ad9c7fd77630baa405bae6976a0a164d4838ff97175aaaeecd43f296c4f009d14de5b5021df7417967c6ba5ed2418cf77b539cdda59ddc216f1b709beeae1e4079d65986dd8969a13db78af884d2ad9b4c216851c84cf8dade27d8486d8a8ea420484c9c3752a0c43ce86f37075d26b5fd68c2d86327434f0ef4fe257ae870b273b0337b3a4b233ec88ad8834828f1cb3345ca91436e67423a8cd19ae58e34bad300d2dcc0ef1eeea057e7de573dbe98278eb244b490dd4d720de020ac03540259677ce6627a6fe091627c05dca12648cafd7575b5ac0a87a3f79ae50d4cba79353d4849cf781d1bb09778be06f90cdaf25db97e9c1f2df73100715b2a5577cdbf99c6e8e2f8e1bddc19e9d7117d6691af4ea801b81e44dba22051689f9ee4be263f86bc03efb06b33c6a865050ca300237a22f95717328239ffb374389037861fc97cd71cc9da7917dce43043f5b612d153abd3fc85347f1b12c583c2e8015d3a07400318f6c0e010574c1a850277c7211aafee5e2a9b7ed6d3dd4b16ecc39a85fa4ba94cd536e1177b09361909d73c446f810f301a7a17faf864aeb5a1789eea54db477f64ef654ebd929e18052962abfd271271a4831eb4fc57deaa10d442e3228f72b243227d2545e783945d7f6c723923f6a38a7e2738017c3a3fcfbaad657ce2974341ff3ca3b548cebc8a610a7c19da03e3596e063e0e9575c957ed0e70de296699c8e7a7002ebf69e66390420b023dc433c2bfc95edf541d749aa214cb8206131dfb8534de55dd2f5853e7fe4cf860d0fac2c584ae68a37c76c116d89b7fd167436c8676b7d6c5ff8920285a0d6a780e8f4d6fd7ffc29621a6d1289d693018dabfcb808188aafde576c6c475607a55f61809ba79cbeec409efdcefce6c15465d634fd12e887bea5f341e2bda01fb62a4bf633cbe381d5d514d4bc243fd7d07543d5b32007471621a406cbfda35c44fbb1ce42b468a728deacc8ee3b1f113bc53ea026990f2bc79593c331e4df5f7ed93c1f6a68b002e79262194a265cb078ce9aed675eff26b88e71b393de069d44b436cd08e677e5614970f9af9efce08cf5db959bd0353511762ca60c0a138c1849772d99a6b6ecc72fb909bbb1e09a18a555a32acc69e0ac5416b99ce80bafc0b761684b06ff4182fc0e5bba111d7332272c685fa9652f5e4481bd0f242a33077f1fc2c1b141c335bd5cfb8279b1e46d6c9772e4c1ac1d0c41da14eb5926800883dcb245cb58098e5ff361a13c42a3b24d4495b32003bdfc29a9344ce67dd973c3623f24601a86bd69e7756a7ff3e197074cb4e33003a5c16f86ff07cc6f557ed1aff7e558764bb61215730dceeed494d17e76dd94634abb101c3a81ae0214926c1a7e9788c023be4a0a0ba0515e40d200213802b8e13dfb6b5c13593a1a48004f5dc367033759e39b9f3ef8fc4602a9e620c3b9a03a6a2ecf09101c8d1159691e9ed955ab6a7d37c4c1b97f281a783ac92022c0a8d7eccd1586e37db89ad55f34ad0395dd47d43a5af1ac7f73a0d036b0b775da97e81faa7b73ef2a59e7ca22d62505339c5200f7f08e76c92975afa7e5c5ecb948a4ae7e29992b4f35311c84bbdd9567401006d7c54e5d24d0fb20fdf5fba92ae8ce210e5a4375f817c7d258d65167e54c94cab5732c9474c1d924fd936682bbd5a8abd6edde43b05cf68c6a0506c8009370c33034aff5364b231f7ad78b4b6d38a18d51485c41307f89cf68bc9edaca578e6397c0c2239794dcc157c8bec0adbcf8d7f29e85a709500f808980877950a6c4e22b1078d875ff320a0d3cb2a73d8912b0e07610ab246bebf6a9bcd09234d8e39adcf944a71d74a916a7e9d13c79b5944f3fa3c28bd67b7682d2618d0f634ea9dd9e46ba5b78c6fc101f824026762354a46c316c45baa11a231f9ae4d1f2e66f1d222218a2f728cada30e8946e00df60ba72278bd7af606675c881709dc8189d7df41d90ae4acb52300b572c6cad9349a4747ce7ef6ef0eb937b59d8ba429d248127eb57fed5fcd9f7ea3b52175c5885d7f061a647df53ab01c6ebd65abebb6cb4a2289024576a38b4ef3af0f17d2ec7a5e070e3f4fa544051e859d65216bfe5828acc331a85c0cdde8270528d5bdd7bc478f61f7a2955070f009d58c115d48a952c8c2182f83f8fc85c471e7ee91623192aa4720a3c9ab1214aa0c2a6241ba91048eef677c3b5dce1e421ec94173670418fd90f987e36584940706f059a0532b390391368d9adf3fb44e86db7a989d19dd642fb04a99aaac2488f41b171ca343d4cba7baaeedc41e637bcf89d39784544d5dfe981acb3524c48e287bac19915389f4e1750322d39285dfdb1ac8be9dedd22c1b34ac66ceffa1996f1f011899e02ee071f7345781f2e581416ddba396c612088d3803deb05a498984f5fc9586b4440354acb220008e3aceea9335c02bd57ba0bee350c778fe8292196440d2c679ed6703119c7d8513ad609fe6bb275b2c782e27a7d2fdfeb9dc7ae2ca4966bb63f1493bf205ad47ef9ea2d2825a232ea8a67071f8faad40db1c96958ac33595d557b3de8d365121d28c2cdafce98bb8e059bcf43dec477f9f9ce7fcab102da7182bc079e2d9e4961a1e7298c35af3d432aed99c3b736fc1328e973483fdf7034bf16ca098b6d7331a1093329b0984f11c823db9f003c427b0be351addfe843c0d758e890dcdab9b5a5af5aee9bf8254b4f2e1b40bc024001598db5205235941cac9019e27f73399eb64240bafa2b3f61e2465cc18504c11457057f9c46038a8321e992133d3b20232075a27bcf2027bd29bed135bd04af598a0d5be12c44009c726a251adb73fc0f1f38b7b8fa102d8882b3d01e3d6a2bc9d348e8c1bceb09f97ce6d10d6db0db04fd8605aa95db03b2bbad658db5ec6469fae868878abc64dcefb60f0c371407f0052da0e98291b0bf1ebe1d40227728e43b308e3daf6964966738b25c44d67764d87aa6d5153062c369e148e30c0fae00f4296ed33e2d26dafe968855dba822d09e69c284b01c91114241bac3e21c299e4ac3b62316f9d0644e61d83f9fd1b98805f14112e2b050fddf4d7f7957a4fbcb8c1fc8f74bf9bf39a5f088099e6000ba7db4c51b3e9f3e229b65be8ffbce3c8eb977daaf5cc2103bc56403c683135de081b6cf6da70864847a644910fcb87e70749d976042eab89148fa08a23f4fb5b880308f7bf49d11bf98ea411856538136aacb24079792e8f4e3192a94426a5c3ed0cc3a0f7a14154893a130bb96dc58474393147e7308d45167aeb6d28e71c0a671cd8696d3f232d3b4eb000ee323e1b455e7aa446d0b7d8ea1922bdf6221d63fda04e4617bcdb49928984f181fa126b0bcaf00cc7e420f8990f601469f58319a27167ff2c0aebe48d69176e30fa0a0a0f38b89666c8e09e9a65214e4de3a6792581a0a5f098f6bab7f0a72a2e00c65e3d1f937cdcacdd605cdd0b5631c434441ccf25ab2423d402d5b9b90fdd33814f725fce5b66759125f99f4f8aa707c37c10b668f61ef5b0a1a3b3b470df78c75543f00f98ba4dc9187a4a039f1ec0c80101752191db12ead1ac208a82e0cadd5a8b6f716bfcdb6fa84f718a777b6c84598be1266a9cee9c8a1f1c84a015cf261666d283b4e22d33a1586a71b6bc59a5847d24abaf9201e2d20568eb6fa45806237d2435d27d2b8cea6531317cdc4144f8a66c2ff33f9b97bd636197adab81c2a8ba43780863799851ae08fad51f7ebe81da32084769124923f0a50f2f91c07edc37475ba6919808fae2f5c9feb7a46bf104f31df7d290b7810257a85ebf480cdd46c0207ae8e9e4d2e27841e9f38e6dbe09b58c38480699b977b4898df6e87997b3b3cbb23daa3cc3e8269ae365a914972c5802ce37573b083b661021a9ecd074d953a44137d63690a58cf957e644335202019c033279cb96d4a2cbd6c3ff31f34425521ad2ed721de3e597e7d05be62803ae32a1b3717c3da6b2918fb6cff1c5d31f3329e6bcd3da70f3d300449c67d4c3e3f625630f600943f5056324b93ffe0df012b797adaa99d689f3ca68575f7a7032c12b30248c3bc28f04f536ff74548c2d41f8f60926f89ba9d8da793c950c1f3c0f111402fcb10661c827b9d619b9327e3751557e95eaf1efe43d036550a7abd50553750712f68ba26f3fec4835392670cbe3b46953ce08ba56d44be1b6e302c2d087c60a98bbc178bd19849b0703f09f387a11a84f75db8e1cc73f43bcf7f09fdc30ba944d44b2f76cc15e4b1681add7a8b8ba830179820f0bf189499b5b0dc6d86485aaccd712c3ef5d4239704cbffd93209c871aaa4d2efb18bbd84ee41fbe6ea6f19570326372d1fffb315c9d7b81f71be0d18e6865885c233c71ef570791d79ec3fe202a720a5db35357adf725f380693d0be992b80480fd4cbc9c8b99806169be1da7fc91ee0efa0295dd61731d1a774a760bc3823121eeb72e59b282fc2fdba551b06349f1b11b2a8e8d65405b9e41214190bd9b6ce0bafc0795789f09e7fc6c9626e83ca816b60b6d849bbb4715e3a9cdb6975eb1c26505caa170398b94184637e54a8c05fc0d1bf3dc6342d4cbfe2beb6dbbb39942c84deddd80b897c8890b2a7c2769739321624095ec0fef47ea6e912b23cda52ee3915e00bc793bf8192b3cf4b98f82f3d4386c4f18c3f4059e291a2a9deb36664428bbd6e9287fd0dbf4c23d4fa7ebb88b49c23fcaeb950fa622f8d69602931a776462a696607d9df42d8e5685092db75eb76c7a6391a30cc30a5a2fb2d4fa20a9b0f815bb7695591bac0d489c93b7b65b398cbaae76cba66c7ba9ca38f01b86d5cc9d9e30e1e10d3b996d041ad499768f8ee08b02118c98a07428e76849b0755fc0cad73a1126ba1daccf353178d3153999936a53fdac37ff1026ba081014e134640a7f60857432ecf9874e6ccc337af4d0e1542ae717344f5cedfe5117b4b1589a13f4846cbcb50354cb3e308478dafb719f57f5f4264f8c90312364bf1540691615b66a81b0b9c6328e2ce1846a2cca849a9b9dcb618ae9f0fb42c2db535a28201bfec37341b6a1bc76cd0a14385d0c52796ed81b7ea2f0d2dd50db22b3466e8936b2ae22c67ee141556518b68bab0c975225c57990e0016365ee955fad6f0bf811c08b651e9bf07667e418f6e83a6727b0790c5b1ad42f5c624eb0d1a96388f81b17096747575418267ae0a6f6a5108b6d1011218274dd54b6c54c5b1ae8f4e5919fd20eac132c014ee3ef683de4489b7f8aff49ef3d1b04fb6d33195826cf10ec36c80c02f1b20721d49255f0b068bf67ae0f91a2acdca1576d33f14d7c484954ccbb488e8830f81b308beb692b1816ab6f8a65d04794a67d4ac9a68d25c02f501ec1114d05c05ce282c911615bd3b53aec01a705d91a571cf2dd4743625533379d37f4ac39e9443dd66f6ded3f76ee1337ae867a9c04c87e77e4ab300e34843c9c4ea8d25742ecb7622c5e87afaae393b5a823d03e30460c9672ad03637cabb65863c7d71dd031ae9950ce38559bdadb328c4fe82978dd1ef77ce537db9b0ac96835bee628821da3f524c0c5ce51c540aba35741ef3c9397ff10a61871893b429c5b462c21baf1d435f7da69f73f72bcb09bf796ac7a2afa16a6a2617ca006d63c870be4997f1081a1ef016d8a57949bd783d1b724e0664060603c2370f094143efee4c4e346d3b845707b0dc91b25a6c17766f1dd9ea1275179b101f71052c5da682db3874eece46be80ca808e05026a4cb35fa4e171e5f021713bc606c28210af679c0f684ef2b17be1eb2c70322411fc6cfbe0adaa74c778f1cf38f110c5041ec158eb54fbc0a1d8f6891465ead7ad8c10d8b5f26998b68fac2f3b92f61190ecc95b86e76a343a6bf9aa73b7d6d780dc113bfbbe9977e7343dfd4820f27337e3e78ff2316bc752b67cdaa1c614698f81149a4ddf779d486db8744defcb3ff1ccc5c9151091c82bd2fd322fbe996eed5bbb5f647e82914347b4699111b38f10fe08f535f553790a170f1a30883944dce26ae959adabcab66ccff6079d04e4917f2bd4b532f051e11ca2322a227d207a5455fabd563ce298e346cb552f57971b7777775624759bf9ad9d80e6f8d1bb387c8a547cc9affd2dfebe02d2ab13ac178bdaba64c467f6a09c865c473e6514d4f7cf34b5528de31217e9e83415fbb49e4c9f0b6a2342671018b5ed91b1425b17c9354f44d01192a4508c42608754091e76d4e70f3eecd605fb5e3d6f68d5364ca194157f83d3a9405706bab44fbf510dcb1c10c110909b9226a80a84e12ccc0f1fbbc5811d227c8bef53e96f4d8e261cb513ba719edb2ae375d5d74bab4cb89e95fa581d473964181a54be55839622075ba66e719cdcaae96646ebddd964b6327fb2a0146db091ad7b5d6c039aaac14eaecb176f91e468b1149501a40ff6ff8fcf14a3b007d8912103bc57416de431387dc6b41d8cbdb1ba337724ea12ab6fe4434d7aaafd758e21ae9a938527196de807f24ceb7529f3a28273a8579f42a5cf4019ac752279ba7c53c59e64d38dff38661e11565c8eed7d48e078e01fbe24e04b18c735239f31073179efbb86297070b6d67f72f23a62170bfa2aef492918764f60997c82aa198eb5f3f7494a9a1f4c9a11e0db71afa79ff4fbbf97246afc0b843c9f501ce5ae07fe4ab38d2e8cb2d8276c7464b7e25c0a846d585fbf343a5d6b0b523ee5081aaef645802207215bf2119bd49eaaba619cef721e37db60183876305e9d12f0e8f0a6bacff67271e50a8d1ac8a9c998a1065d359e710ce3abb7f89fe14c7e7070c14140878814b4382c85b367159d25b151d257a2f27ee025e307ef67f6b900d4888382f39d186b8fff9534e50c6b7765fbb6ee16e56b112f441f4818c3f70187df2ff94bdc91f6d92b74422c37d681088c57477c717519aee3d571ddd492cc45de25154d5d772e7ffd8e83d520bb36bc2fbfa71f7aa890b60646f7f7d63e10e8a51dabd15023c1cc47b8b231be86dd9856bf03589aa6aeecc1231c7d61d91ffcf0ffe6fe0013a40181192a030423b0241c5e787f4d74565f30c9b8c235d5d9026c03818efedf3ea42d98597ae002db1a99521bfc277c0b79af259df3de6b19250c3f2d1fbbe128815068fecdc216b8ecf40e71f0f748e88490ac5941cfa938c53d486b9804b8929bbbe5c2670b08be20be5ab76f7971f24923ee7e1c58ad5e086f9ee6c6c0bd0a24657f10087a260b599f0209b3666f0094341aba81f4c5b84af2fb9e4bce0424eb52ab659f233c2e27a4ba912e7cff5e2aea0bc0f99d719772ebaa97cdda4138a377dcd0ad0c10fa182997e08a259746a5279939c3e85777d9d667b57b1fa2445947317ca1d302df72d4fcc19fff33c7065d68d7c9a616e17f612645d8f7a84bcd1aacfe4a190e3f6d087b0b81ca21dfab412aa8f96f268ef96f909a5480b55338733faeff53a3d7b5348419e915147f6d34f418beeb4c91ea37f77fc1b3a43abab74a92676ac325e358d0b9782c43a583245c70035b4a1b56490b9ac1a294c559a65f03dd12230da04dc184f41024fd9f8274220c21dcb8de1fc1377267a9f3bcf2949d2995957d30b37b5c0d23a646fadd10078c34041b2867b2a1f7ec8cc8612e335f843b728e11403004c95fbb426d77cdcbe0b385d21207b26a6bf36e953cdc2e191c25508f3c90d9dcfb21dcdc18e7c27f5abcac1866fd3d1d07e2d96a52dafc8e6ea3849fde5117494f30705f377021317b2165a8a505d7a3bda6e22dd3f3d53e019a423cf8d47742c0bf9291946a47dd20c5ddb69066efcb614875fb324fbb10cec16be47526d49a3ecfadfebb2756f3871bbe0722b7247a7949d741c20f5c7a5bd3cf5a0febbfc9a8f5cd9880c1d0fe76d25e1618ade47e39278e4e42a00de975560aa62cec9ea6e563bb20eeb1f6e84a523506010e6e10bc3e7eff59738513582b78baf51ec4c45f7cc1c1267f1499471649065580fa29c4d60ec07a5a014da03ae3a50437a7e2f1c3ac3cf9e4a783cf7ea95b93d01faee81ed4a5a3abda8e31057984dcbafbdb70170147e9baf49ba1b3ebb65277cad2085124fb17d856d410ad969ee0eee901dd2fe0edf36f2e183990d517188fb11a79a02cc501806df460fb75581b6700e614ee2c36b8e68ebad080ed456a3eb512091a84d330b20093e1c0dab03c4216ea4f39915388ddfc5486b18efe0e1fe0ab486321b7e49dd77a6bf6973cc0a5fe5b30d0c41ecb1a010994e1f8972a50d0cf9b5cc34de28fa648e13897e9e441581265c944c31d9fc800b69b3f3099ac96e8111da457afa54e9c9e690593b258211f8d7653bb37b086a7cbcc8139b2a123a65b15f6a94756328b9851799e3c53921b714bab0888e2f97aacf41802db652f06e2516ed6164eb8d2bc40902c5940fa8074fc4318f831a942d8e4ac44b379f939814b50ed512766749dcb9d806757cbd2460f91d75bb7da2f8d8b0b294b6e3036941119ee24523bc6dfb6601a3b13de7ee530bc59867ce7d3ca0fb491921173da5b98a6d29c690f1ecb29c4ea0383894d197fda05e24eb0c9c77e93912d77ccbb252e6c04e2b73e243b6420968b2c3abc177a83fb92e12c01ceba05d5431ccec2d3b4a2defc73e60382cb810290fa2d6bc9d967f76637efc1dd6d6521522812c29e58f5c11c9d00632f09eb6825b2390aee98d71b93c2c169da64269bbbd7fe72d59d84a1cc8fb6f9f6acd58252de47ee888ddcc2c433cdc30205db0584767f6717ed51d6ebb2f6f4d742268660541bb23b2cdbaa04a2d9aa19a5928efc5d85b927b2466082e004c2f56a60d7d8b3757d49f0f647435d4e9beca9ba2f215b4ceac7623d49ea11534e46d5f9ee994ae675728665377034f364c58c84198c61dd481168f13a3863791fa877ccf4e9614801521dd4ccf32adff5fa8dfca48780e385f4aa0f33e4ada7628a6c462a99acd5b6873c3e12f33aa9d927825a0050e47c03a8985d195c854ea1fa658dd95b3bd7679102e29e58277166f89db90c2e81140d6553405c58059548718a185372c1babc7b1a620134cfec5464577208bc299ef1ee876ec116039bacd6b61c5892410675bed5d0ac1fca66c8a970e90881568e20e1359915aa626b370476aeb82c1bbd9b5832cd64f770c925f7e334e71522b79e6701ccc9adeb8cce39e8108187129833bf74edf45db4c20f63289202e9f86f8a1b8b9992a90bc474aad0903f7281c8b42b19224d525732065b124b80c71af8306f3b7f7f4ce11a119d45d78b13289da57df881c4f9830ce60b017944b4a3d379fa734b802e0d0caabdea34aa895ab95922ddff4a0f9fbbc26cdff8c131417ee43960bb9dfe0bdb30396029e1d36cf6c34a7b0ddc6ef62056941e2e2cf25672dbe65896e131735c6d989d12d8dbe82777c30a1d30a31a53446b147ba54526a4afa3b8c9eca79e1ef7bf9cb761dc6b19fde62d1db4a8a7241fd6c74511353d90c618123bcd2a71a27973e249afa79fba9e137af0f4adaac00ebf2d8568797e6678c7a927ee5ddd48dc9b697f3d43447ce57ab3048b9e9851dc3f8d06cd04e2cc7633feeeaf34631b1fa149dacab70812dd904823667fbba1a9182eda4fb36bdbcefd2b73d9ce80e50ca540e762c322dc50b57f47281d8848dc015f22c7948365345d6a76044153ca237fa0e57e8ec81cb6acce2fa6678afc80b856046b0e99bdc542a9b1e13de27efd84e800af242e4baf44a73260ce87dbd1ff7c303c486248198b542663164f980f7322645f9061f49e1fa6b0c92929f3f16c6474bf54bb0c57321abca51319b94d3b8802551e7c6c0ae4f234737ee7ebb3845b8715a3d2d57654a78adde2feae530e8a346032e3437e34617331e16387f964873fb102e93bebe85fba2ef7541116df21728d798fbe130dca61a150e807ea239dd078472e80d04628348019e42cdf264a3b4df2ee14ab42e32371ac44deef2e8ff64a8e14832a78d311580b98c4ba7a44717449b44acbcf7b71490280a19c85e26eedd1030d59d79ff3e9a3114c42cb60e9033888d33fb370bece057b555eb1184ff3cdac2fcf54a221664b7cef27fc63555f0bd162941d6704dbb44151d63c77226af58260a86092306a5c53818143dc25fab072238700c0c26415aae7f730c1b6a3058508595ca852b16f41001daa0f3ac8b260cb1db8ea68a363f3b3f71a28b563f73158e6c86700dc428ec542598e0f35489d4130a12f18a9f3a700ccc01223b1514a43396124e549a9a4bf7949066d172856981353fb984dc319f6bd2a3924a1795aad19d9332c76fc7a8ed0fd338674a83aef30e5a83dbe5c070b7a777734a7844227f4876d81a5c06e4bc6a740dce0735b3d02a85d4eb1fb7b94a88231e440c602bae2d69f8a166ffd6eb79ad16130e067cba8cffb538fa677ff455c040054a81c5a3f0c53a232269b4488ca1f3b70ffc022fe9b5b7e351d46342e4fc8dd701e769647175b09661d962868c73a9010ca81783046c4f233160c4bc5209b081617f4b44707a532c49555165e10d5230417219feaf090906b62ee9d763baad50187c359e8f4b8076a7accc2819fc56667fd9b03e2b217343bfdc244a6eec3aa848bb71193eee9396ce76d96464f95bf9f0fb756b729be1ce21d6b524bbb20c47cd5005b286a9ad087a4d2d8dc6d45c32fca92194a22fa0f165b0d3346b737d6ddf0549ee44745b4b1de4b503d33684a2741d9f16be1b370beb891f2587ee3107fe62765b33aa3d4c8f35cddcf691ecff7aeaf851d132aaa90e8766513bd5e1ccde2315a6c5a162a8b9c8b1c466f18443a005f0f2a04a938214507e496e16a258b3c9472f9db27a8d8364bb14d6d5875a8380634f3c9d855f09decd3d23209dfa8cde4a24b126b2e79d5cb6468129392b2ace5f31439017c0ae32d07d17c185df3b0f96513fde706dfe60dec66e448382d8bc4e42794f4dcff8855f841af1edbf0590ca57beae8d8823c68cb5ec0e84356b23540c5c234a045d70b860b2cf291876eddc60bfb290c4d66b9500eac1f0f821ff9ba6a491e23bf501a03f54a7345f4e29f75cf5cca531d16c346f24dd193227ea390812509979191d4a78eea49cc3a00f25f7832679246f05f34eec0b8035c5024df681cd07a17eef8c6592486dc7d766bb3f2d0fa8ab05160bed19b41142fa78fc6291a07aa9c137f922b5a46ae61e8b7069e5ab36b98048c084e3f7a53981b968a0977ab58bf5ecf8e05be85f7c1827815ca0dce7c51f94a5fb29da634fad1cd0844318d07c1268d45cc081d88a9f062588a9c110fc9c2326542d8d8f382acfcc97dfe5e6865aca9e26b86ad28048153922c28394a9c47b68bc76154a1823bf0f8f6af6c03ac17ad3856499b52c16822095e158b58be36c8e28eacac541830883476543b3dd04df142ed093bb5d8866958d84b8dd3973d5bac20ce3977adf1d4dac3f2e22d5a8921bc07d64862eaf9ff1a0e95e47f8caba9fbfd53423aca5ff10dc9b7cba5d116aae43fac922ffea1cd44848659900dc103c17e354b096d62ec4fa6cb93f654643357d3ea7d89ffa1ab57d44a1a9de8632303757876b7a52bbaa0bcab72906bf22ce3b527620b8a1e85cc993cdf7ff5137a2c859da7fbf4a2e92eba92e1b01dd63a724f207b150d385cf5e9b13a7d1d8a9470d618d67a181dd3815db8684c6bf18259858bbcdc505c71f75e6c2f06754279735690bfa633da8de978b0dc986fe7c9c531b0fb49eaa0eeb01c3e31f0685749183910e5aecb19be6de2ebe7b98efd59d4d40491a489ba2cb3729ad622314d253938d324ec64495526b1636e64048734c8023951c0861714374188baca92adeaeb2b699df5b5dd21d186699c939e3fc7de06f176e3bebd09804d2a537222695790fe393dbe676b228d33d533a4be9aac1dfa7a92ed5bd49a5f2f45b4d53933fed6f101fd765e374962c27f0717028631b15a4db581caa074bb92699c009a99b2f50720b9c31560c5f5f87408266190da64b9f1c1d1933747f2cce8ebd0108f012cddf29b62bf77632f28f4c2ca7c6f62f64eecfa9e61a5d948be8a996c320af4241e75d66e9d1400d0688c1d3f7b88f44857f55146589db4f03bc278deddbd4c69e66b0d2faf4dc44666de0f3d2e57bc739282143f9f9d7a7718bf30ae6600aca8b2f988030bfaa2299ffb869be992992f121bedfce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"dbba0100f462705d414068b345035e5a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
