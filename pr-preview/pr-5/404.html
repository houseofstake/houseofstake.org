<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b2951122149aee51c4a22ff33a7ea80f03855dc0546f2b7daf147b48bd098b0225d2be46aa3d9dc118dff33598199bdc6deb7a31e5cb98f09d60f5142613157dd191cc9e0f10032b479423a1b0d2d9cbd08d2fbf245fe5d6b40d3be5f4e7b7160fa6e80604ebfa52af30076ce4151ab428237a8df60814cb1027d38077a7ef1d641e52f00c7e9db24295f96734f5d1a97194e3ca846a32b9d53b6457b65327b454caf2511f7704078160c5150a076d3d9b9f6df0fe94f447e584e6994819a627a28aa044a52ed7da567de9ccb3859fd010e33525ed0cea94cbc1a9399cc41b77555dddd81fe1d4e511e5024fc81254febe40894e1a1fc5b2566f94e66f6da207dd4262bf6fbeb07749772c3c051b289a9d9ac6971033752a8525a540b13d049da3a18dc0500f33183082a316e2685028c210efdd315d427776b2bbfc01e124b5156cbfdee34a68e515473ccb5eb5edee4f1b783879826d49d0737f670dd2d01332b22779618afe195539833f821020a2e8c39a491aabe009ce9061565495e96ca1a88c2e74fa491ce891c7e5774541eec90fdedcee9aa7e7f25635a7383e5640f8902883030f88b193eee8c52b2eee878253931c5342b9a597e541cd0ceae1fe000b09882278f86008cba8f7a4d2f40827d366fa190286fd8a09728ea654f51e1f52aaa998ab2558200cabb83503c5935fcc49780fb017e5cf5b66208dad71b31e396703086282067255240ffdc25884890f0421759e6f63dd24390856715a0c011ba7a1bf9c87a7b9846ec29b2f1feed33a2d023222183f83fd11fe10c8619ee21b934f1401ed97c753bff00bbb9d581a9f585c8a968e049e6c042a26c3be9489fdaa260230ab9614d54576722c2480a0c707c3f7a24a8aeefdf407a68ec9ba2413f692cf405244100c6ac3b2c37faaff189da42ee0ddd3478c6e09db3e62a25d48c877c333c48cc5e29151b94547925f19ec1db8e016e68820db64b14fb50a84e37eb452b18032387a6361906314e2e1a78f1e3d7e5c5aca4ba531bacdd70092399bdbd4f4581b4467fc5bc1e4d5eaf94c4b1a86abc2717bae541e66e014131a8c30f69334b3da484c4959e6c48b2c5f8017c865aefca02ddd9987b1b25a84a7f155b480af04bc2399b050579a502bc70013af5535f1ab464e4e32ba96c9f04f76ab530ce9bca819d3af2bc9d33ee628a38289dd839533a978265598ecc9327747a4cdae71199a490e248655e4dcbf6ea87bd5a681299e2bef5341ba2fdf41f090faea961c5caef577f44b34b5130db5f5c2531eceb52435553893c3c114bc790889fb074d2081b0dfa5ea5c840c224bbf9d4710ae1309604854058a055b9570f12a591c1224ed40fc1cdec54474aeedc790fc8f46460184d0e0a91c678d75f5adba0140aa524a89f86fc3a53b2da30a58378fc9565f76cfed87d64f72b633e6fe3847c4cb932dff4a2ee7e502219ac01a575c4f1341faff6921dfc14ac5b61f790f6fd4400a6cba801ad81ab7a69ad315db17a7f3491bbc8aa56d09350aa66e26b5f3244b794c9fa71bc370d30521d4c6b4954fba88f0ed84cccbb8402b4df1acddbbe7d6c1d16249766cfa527b017017bb1db015fa8df51d2b6f301b12da2d3231ea431577266bc7fd4b06114e3d04eba0baa4bac9bb3a4ee99a2961c3513a880eacf8c46e6255b241e96efa071485a2305cd8f48135cf714cc11f81796319a9c5671cf40a30cf5f9f3953cf66585483ffa616d352cd836ab423927c0bf2432b1dbf68892b3d4e275b5fdc549d0576639f4ad4ce8ad979c3dd49b9508ad3f32b4f3ff698ffe757c373f1d587718342f05ce2cace7918525a3c194b3025b1bf15659fccc7154d5409b3b2dd8912a6fee8dc1d516e01f4a5eac36f6e581f905abfd97248d974d7eb43e853d6b3a7ff412a9a1793b960ad9abef220931460c1c2df4d14e709cc2517d4789be8ce8fb07aa6f378d48ddd85ff938572b2af156a4c603e5dd25d36d67b6da7f108f20a525d90c3d3860154fdaea9929fd93bfb04f8967d70127317a5c15a5012e91685f4d8487d5f274f81afeb92a1910b9d05945a2f5582febbdf43c6c5e5495c4a38e3108c09489b42a41ca8ecde8c895f46555f683e9f780cd0707637e5df376ad430b8ae946675e550e89b557e2104fe8b0352762e02ebb014941e438167457944ca1148403cd7dc8d7b018666a3d08faba924e4b6fa30ed0828a8456f11b0fd67d89c16a52aed2213b142e19edc92e5211fc41f2f8a83160da84a6ac4c42fa8e6f8e48c10f56c9d79d997ead30a29f733245ff80b1cc770d816d9a07f31054eb4b8e030a27960bd3ce9632120496cc58283f1477363cabf05e35b168f8cad1a03595c13f00051e70dae6b09102612950ca77718ffb7dcdaba33e5c86057b70caaa92dc6899e20333f33bf58ddc98e6cf489df9151650bb816c383503d4ba22f39cc1c1c1a4bf1ddde684d586561c2dac8a825de85322f172c7b3f49412e51433b3a79a4d242374172fe31d0053f25db781bb05be62db037bdf14470db84ae6a3769aee29541161986623251d9ebe88170697e26137a4ad51eba5a825ea111353fa2f6d230510dbd7df1441140bd15bba27ffcde04dbba311e2ecea39521b290f4bab7eef4fe66943207e19675ba48c66ec9937394002651a2771ce9da589b8350ce64e614e9e59cc3777ce47a61b6d1fc04f53788a002c2cb0da21ca441a63f8158d3bc790e8a808c874d6716b2c007148ddc3f8c3c3f0ce7db70e75f8bd36bbf5f472a40c139273787105db6b7612c2c13ce2cc9a8417dce1e43b6f7233cef0c5b0db1ab49b3480f8443b673660685fc58eb8197c375952a95ec8d8650e73bd8cd6488b0ba16de99e89a76ed054185de69ce7ba77bd177c39743fa383e5ae66e99f5e2ba4e0ef1edb1cf24cf8c416f5190769c6a0cd70509d7c5aa05b00a798ff465b5245b86e5c8467b7d0cca223bdbda11c9297944201d0a76c8b2b64a9260e92ceeb574e30b5a904809c41ebc35350763908669d785d64a011e352cd3486c6d53f5b7d432c3bb565238b36aaa819e09ad253292c0cfb035791f7cef4f9598ee428d2dc2102c54a27f51c2f5d43f6a258599a96bf9f811c2a7fad71c5f1f39052613fd8d9e75fc57d858f1b0b1c5788f56b029ba7b7094b1dd16ac645cf1433afc9387701ff9a2a73cd48b5b1f6140a6d05c903e717d1ba20f5d00cc66c6d8dac015a17902d65b6704f0355b2cc8f8ce070c2e38199416764f1ffda469e8938d79a293779aba2632a1a7ef8d46c8cdebdcecee86891447977a16ec1c93dc5db94c8729d23dbce38b8f32fb9feafd45ee80f6b3fe0e44457e6f6e45af48e04f716284a55ec75e71af4476acb1c4513004e995947493e77518b9e73bef769b9c52cfcb0a761f0e81bf70936832af2e8feee5876711235883f81a846090b7d595f7318cfe4bd975bd2124d700c8cfee04202020ffc0421f9b7d288d77a5c05ef9ac06f591b783565cc29936c6e411c266b23fcdcec3a5a22627e920ddc6b880fc85e5b9967cebfb18e66201e5b063ea276d81585f7af3787e2bf5475abb35accf8aa013b03817b3033d5b49ca95e82c9a3628bad2ff6d0b855e52f3569fd59361770d9dcf767e04aea77c715e698cb7b24c42ec6fec4cd9588f25a0e273c1e7a36477b4fdc9b7a3ba7181eef7ce3f0305da4a9ac56e5c1de90c9f2c9085563267dcad69dd867975adbf4f3a19bf1651160496f2f088ec61ea4749b78d9a75974e512ef40200ed1e27bc29cc9dc8e496fb47eb07da993752f029dc5fa2924e5e22a1499beb46b1a2c1f13f3094c56cc3b229338f361047f9e77a3da007218aaf7cc6b920602cb021fb37b9d59b9a9804af1f66d336c2110c67e8441dd0a0a175a1f5affcef8a3204dfc64928c0943ab4f0a5d8d890e1c9b547f16708e8d0597f482edaeecee8701f712ef5822ad945f9ac007ccbc5e87801861db11f62c4e03e8da74c5416b3269556fb6159948274e6747189ea4517d77f97866cd350cf60b364ddf50a29a13cad55867f65949f07e7fdcb64fda1910775dff661e2c85fa9fcf1b3027cbbab05b2689cbbc14843abf4e68760397dc5a6a58c10d8e8cddaadaef7412fe946eb1e4191b4676c0d8ac54e652769349610d7a57adc2d28b5eedf6569e88fcb591ff48d70467554fabacfd04025ef147de484f6223f0906ec5f92992aee0b66e7557730cf4aa2a4cb92468ee5dc0c6f38920c95bb631decf29762027ebc94e377820b3d230f98e9d93fd0a61241df3129bc3ab5c430f0eb9ae3ac5a07322641989f7e175a5e25d8ace50cabcb42d373798b39110a56a491e5d74463bb0de358710821dd54549205a7804405953739a7365e287f7fa06e4ebebf81d506923bb3c1c3f6dbc60b5c18d780068a206abc2c9db8c5474d1421ac4c47c61d488511256fc0cf83bfd6990f5bbb7e20a68178a66c4548f9edc71c2d8185c7ab6127e43448d9ca72ddb31e269dc7119e3c5e780556aa4c11d1ccc31c65cd94aadb26bd2fd526c33226d26c772f6b1b5ac01ff6911480cd4eaa816882f5517bd5fbf0d9ac402a29b4dc8cf8a496286e0f3b366d621fc403207bf87f2de25dc44ddcd71dce06ffac399c6aaff4ffede496d632b14c258058ea060afb1e1e1dff87ee849232b061aec1b38128e7f2088c284833056a5a9f094e7c206f0d9dacbc5836d5a814d729c9325daa585c69bc0bb1410cb1c56890041fe2ce55a5f239ed9d8cabccdb2750f6af85f088ceb1da5c2a7a3777ec2879641ef44182623b16b2d2ea2459cf3c1fb7029be85a19569fe9688f8c59cb9abc6c5f2af1e2800bdd7c280e283e55af3c08c4257c7a7738a7fd25502b7cee4d834daa6813135896d110707c315436b357bad3d674c820c7bb2211b8cfa9aa1d76c766450fa092de22af9f1f2c6471ab3226b215357987f77ba6b4cb0f078610d09bc55635d5627792c2b073f258bfd428ef6b80dc025859122be005bd309fe3a996d070037332edc29f324f97371e42ec59f782273f4e82434ee86496522b68c8efabf99a8f2b7fcdfadc99725fbd2e878a9579173999c67a21bb7bf04a84cdcb395c7e216cd5099eca8d1ef36adc7b68cc7e26cd8055a69c6c5f56fc469ffc4ee26d0b0dff00b866e09889e060d03b1ba5a5d3f7332992dac23629143279e90ddfc519c04e68f9fe0cec21f88e08996da03a973b93d15846d4949012ac00d0385e395a5b8055c7946f6e8f40280ef0249dd1b7bdeecccff82258aca9e713450e103d5cc2d41b99ac09a6051aa1569d204015fa6943dbfe01302723ba6e20c7f52078e53682d6db71e65faa8a712afff20e2d12d157d53c35443feca79a5883cfa4f30512844b226ae6dbcb2ad3e679a6c4bc3cb844d4b97de0ff860cfe6306bf7a8a0991e713bfb3be601cb35b586e21848d3abff97fadc624567c1127458423b3949732a6b3137f3c416164a1e3ab1261918da202a0df466f57a17f40a107b4b8782a9be7d4ffbd6e20350a319e3058990f11ea82bfd88d9e56fa42a16c32ad523827307bbb86e94310569fd6fa4b3e9a2f1e8e4013eb48a1cfa66ebdad81723bc2c8ff013d3680c6b61db7651acab969033c572bbe6b6e202d4da7dd8aa48f370cc564c63729ea799a5f2659c0ca97dd771b87aff84bd29a22b9b14c308a8413e4cffc92d6cbc37562e727106a93ef06dd14493077facfc664eeec0956435261df197ad9a3bd4698ce985ce8c47b28ba3ade37c77b47416ccf1ff0a36a3737456fb4549ae77fc139f3ebba540f47258b5366b5929f4f74ecbc63e2fa89082911cb5b5d4a2b5db7aaee503a11043607871ef1a2ec3a06af57e9acfea4daa0a3747e94f37595271e163b8103584530dd78bf5d5440d7716895651ed9619367863a326b6b2d106d377eb0e4b8a0c513da7c606a879ce0f2e496d48d628832ffe11a47d060c79f378301bf34d1e55533d37156fd1185af867803f5b6dc4926532892e5a461b461c20f651ba96f2802d0c59ff9a32925334958fb869f8563303edbd64dd145609aeb70a56cfe896d4cdd5c13d3dfe82bf691be1973fd5480683cfcf83a4f28963df5315db9e0d377778932baddf7a85db8220775dac3843cbfaf4019ec75352cdc0a27eef0b788e11eb858720f0cfcf8530b505fef1b3b96bd5ffc984345f2b0544946ade84252ea92a4f2eee30e350d836e3c8bc10daefc7eac88aea7486d8a4c2363e81f01c9367865d41a77e5bcea28fed3e2f323a81ff7bf2eabbb83e9fed20edbfea3a05894354a04fa1622f7ac4b5d3ea900f5721af159da5fe2fb98d637734c119c6f7fe3b4c9c2ab59775a2fb024e7601a1bc992648ebf5d13e053e2219c52de027659cf0f88ed2bea433c442377c46b9b23e1eb754ee16cca6e6048c1da942eca67a852206f168587d7e38956ec094f26164e0477aed3f027ee3409c723cffc81fbfc19dd0eba9047ca12052ac88d0f8619c9264c992eb10e5bcc4551fcdf5df96bef0c084104a26717cba74297b432d35c5bb56e392175c3cdaaa1bfcfb5f4e2151d27058661c0fb19048c2bd7700994490e47dd4ad9fdd0fd8f54c16f7332eafb2971aab7058be43e98d630acda60ccb3487d0facc063252bf98dff62e70067dac51da9d49580fc6cacbc22afd18339d0ca7f8000cd31eb3dbab80976a638529155a708cb338844ecf837ef5a0c90bb91cae71831e95bd1db514bffcbd9a701fad152598bdc4d8aa363c0421f41b8f929019cf0b22eb5bed504d8409f01f5ec4d6f6990dfa8a3ceb41278b90964625e89edb68f3ad14b989e06a71923db1d62c4417ef3212ba7a233b5e8f89c4eff914fa31e6a4c97ae51d54b05de52dcda8cd131cf5645bbbb500c8c3240292158427bacab8f044de2ad2521046fa5fefbe95ca90d4d69b82dbe982a1304ce86f2ee9b8bcac85eade16c6ef744d781493723fe6f98e1811b412e11c5a087bc67eb35dbda46ab17f9e8bfa86aece19950b07a4f30dd97eb72f70b902e4fd8b45dda7d44810ebee8f757240bdc456fece861f64dafe61905c46adf3656fe4c4c02bca689109b5aeb1999b5d5e6299f4e462dfa7849c7daad7dea08764511335a8d136b71aba240f640b31e9e2d9cc5a9637c5937b8586789ed567d90b96b0848824381157d58fe9e8270680b63de95677808c1011e7099c6a691c0ef915cef829166a0bfd9d83c6fe9d7c4eecc964ec88e54b48e3e4222adab365ef5e48e6adc0dc86e94162d20a3369ea43d259c256e0f7db83370819a88cc66b68b02d9ca6dda347502b8cc154b7bd3c1c605544b3f580c51f28efbf67ef14639aa56eec70079eeabb38dd35106e6de9acb92f9339145c8540df36c86b9228f47a6c68470cc2f61af912b0efd8667850233372a0bbb3c74835638681d24ff17bb9406b3da79693aa3bb0c6cf75f9fbd9c937d45b43e6267912c02727acaa539f1de4050a0b9b70055c31e372e5ddd9b804ff2ca554b7709a635a7d1b05d3c2382c8d79f0833dabedabdbf3691b4e3a64b44d3c544891fbcdbad78db8b2f808c0e58cee4331f3edd1452a264cf1a7cd916f41393c56dee5ff34e6f54916b9d19372c18833c2e7a66b7924f91dec639f44e06451582675f810b56c838781b9e1a8c1c6b93770329e5a6c63d165e383f121cb07c240e548305b98a6e686ec501ad8540d0e4c5adc0664b3abbdccc4af77fe858cc4c9c546f8d92c435e6ca44f3b14d45d3b0d4df6bcc79330b859813b60055aa26275b30fe9255ff7dc461f46cb737c6f539795adc15ed8f85a2f04928b75d9204991f26374442f9c24b0e8e8f9968f238e38769b8683374875bb3dd97ce368aa5379ee1412392524ba5e4c157525531b2dfde6729d4f9dafe1fb3dbb8110719a99ff381a3cf00bbafaa55000439160634acc808f45c53130a8e0b7521038b075c87df7b3d20c6a701fc0687c21f910c2dfa1c2ab9cbb4d34df70cf328daac12180e47a7903f89882c4a15ee99a51afa4b258c0ff538be7067e932b780f90012ad65044176571d339a183ad852d241b5dc4f45b4dc343dafd5b488fa29fc1cdd6c404e35847eeb6608e08d474a2e7c90ffeb6bdea362c41481eee34899beb15b2e93a6dc3a9b0c4f75ff5556d32f381e5cd3bc0777780c5fde58ec270504f4173a10863238c0bb37b347efe0b5edf29a378a43dc434b1fc46e3bb8a5671e1d901e9729773ae115f3b3acbc3d03ae436c2909e439817893995048b6e2f693b3977d2505c07d20702011ff3f7ab61803ee1b4856f5a39d650ce3180f836b6b023c659b018d1e0d1cf785718e3f5ce3cc0ad12e68c1948d58595b812436d1e83cb9388d812f335b3f64b6586cd5359bc71dd1b0bbf1cc0b6591bd6bbf2af29091233e9f91e45d04a3c85f20a39b4a3b051e2d05fb3394e680d2d4aba0de2ff986a41bbf8e4d8d045e877039178cef870e75bf70d5a00fcc861dfd4dfaf9eaa2d5c7c9415553b0046204d7c7c4646483706062772ac5274e7b626f7103a47311f9e6359b3868e59c935f3df88bbdd198ffa8c5fcef0c15e1b3fa1569c07756b62038e09bcee1326d8c08e22e8a664863e51391bf04a4ca393e92181fa1e561bc218f2f53f7e99eefc73b4b5aa3b8fc368272e1c77dd0b6c2f275ce354cdeb259388cd2d9886bd154e86f400cf824722a5f16f3c0ced08721d8d3245d85c98e031e457fe13d4816156014df2c0064ea27a9bb5882b1d20943e87e09f24d62ca0a005fa855f31d0ec74dd613bd507935ca8f2699fd95c2b40ff8509c51302c5bac312efb24673be8d11b10cb516334db793b0436a42057d88eb2b20bf4dce61d7f2ee47d149c1ca388beb3c5ff17297805ff38f5744b175657a2dd763cca4edc49f9a1314599caaab305a62a4ff00419fbd665669695f63aab8717bfe62a8d1ac564917d10a4a52058411b7ffe5437e1bc686421390e6bd06c9165ece5d23403fc2e0a409419aea21c7b3d9bf26a0b181ac696dbc599824279a693d96b57a0646eabae52a8c1d7dd78831a49fab6d9b87910440275a60099d39ea9cd6b40f00028df7e202d4a6b46c20b910e2d57e00a7169747b319b7905b4d88e83ab682b50382d5463b2314b6999df4f094c3c95b5ce3d4f92cecbb5a1c6271753822106b6d67a2918f3699e758907cac89fe59e339e0d4aaba6430207a347ad0470b0c5b646392564ee6e231d31a331238159d8c8fe71ee0b4926b4a3eed94a1b4021b976e3abbc47bee018b29d2911526f7d9d0a30fd291a565afd2ae8783e5e4ba0f7ee42f1a75eb1e0fef95f1edb812daf32bdd71117477b98c03377862d6e35cd49ffa56572060425c2a1a0af59d4582e7cfb7ab7e637b301135f60e361e7de9a096526405a481ecd833e8973ecaa67aafa20716b702f5a17797abd7e94e4541856a57e007c9936fc533375f2d063cf5a7b2b6b17e76bf5f7592000ac8c37a3aee9c9273190568dec735e7844e558dd137cdc65617e92bbafbfbb962c9b974c3270da37191d2add35bc481676d36c829fda284377af25ede77ab142df4d7445dc54d17fca0d1d4067c8bd3c09fbcdd8aae090cdba9c6c6ce73fb1ae4b1e69e584ed9750d1f02a9a6e1ae568f7033a600b1ec346b72040b4f47d1a81546ccfe1bc084db8e46da6e7ed2373fe80458fd73f1532bc095136b66236f050532d3aaf17c12b9b88cb87f62c2c8ecd54c72aac03d4f11c3e3a8c6244f9b081060e8bdfe1197b5890b9208c753e0031575a6139991a1733a0bf00862124b621a9ee87bb46ad428b2e8b7293d5182f868b6a002384af0b5e0e6dcad7c39127bb9294a1ddcbaeb33a3c75c09312b1d2c1c5ba9ed0b7ba7c013d6194b8d5270ba4264b99dd98a51831e4429388568584913437a3bf763951af75c8cf60e07f67f3f5bc2a49837e35609d3500baaf942675d1f811dc9fee2f872e3b3f5170277a59e6ba3db460926684e924056d9bce3ec0a7f07bfd7aa0679da012b6b4972b02e6394d7ad7491fbdcf6a841aa92dc47987f1e7494c3e0276dcf67e44a06eb87a5abf82e8e8cc9d593eff7eb3bf522749a5d3cb5fff358ff28b67e9a8bf87ff2e705b2493f952567b20eaa3b71cdff34a99b8e161dd07b7567f94ad7e18f33fc6b92a3143210c4a2c9d27ee53328c140e32a84187f5044c648f1c1e7391f2085f1f163283507ab446939d7394e8f721c1030f437af4368ed1ad5db68b1ef6921d237365f12ce760bd28231d335f62654ecd72da448b4c31b2d6a9cc756e1f9c5f77ce70877498ea90a407360a54ab0496ac939e0a25f21203ad40f0a350f5713b45b7f75c5961f339dbb36cfdcfc6f64464ae9e9b0b127d8e99f61a2f81592410cf56f46596447919703e997747514abb9d45b18fa18c9582f8fd135bc0564f9b593315731293bcf023794a60a8e1447ece2a18fdc5291b9272ca85e95d79883ea91a139b718987abcf61ad5e9bf4e90b69c69e2edd4f841a03a4974ba0eb12d61b76653bc47ab3c32efa634b6459f9fa53e789a47269a82ee04b691bacbce3853f8297835cc5db2c687e641c773b8b4b28adea3fe0d7ab063b14732e8e57d123c2a95b27eaea080291ac7dc6e82270a93c347175d1513bb36c911137950c47dcf609f5095a1905285580caa15d82dd5349209e15e40bd17bc3ad86a2956473b6e7af780970675c1e935a44b5bc79719a4e75682d9cdf39cc502bd068da1cfd7ffab7da5047d80f6324d8924a55365ca80ea09ead32cab3e5e4d9707ad9dc9fe85a384ad948c6109dd4b140434495152bfda2bf3dc2615e0d945dbb0a0442e494c042e5dfedf40cd034088ebd1734492fe00706f80229970e5419125018fcd195c361428d21be7ab7c9c3bc00ccb654d93712ee518c0887079db77969f02b93428472d9cc0a843f64c015ad4d639f88e6433cc9f9bbb5f59d66dad0b6f06a939dde295f8218b377d7645ec567ed1d02c38dff5c9debbe82a574301de4864b020437921b9f9f2cb583615e17ee0e55745004f39d49c922f915b5513cf31ed5fd77b2effd2a3d4d881db31c216d4b5f041ac343b422f75928f832431d21314ae6a28625929274128eb2ada92f0e503ffad7b2d406e4a4a486ea5780583fb3d9bc6781c93a8f87748206a2131e8eac09c0f4789a86f1195700aa26f497291f6cc6014e0a26db2a221a99410bc30613dc615ffdce682afd71b5d9bcf6ee9eb8409dcb507886cd0daa4d685341c9597d8b3844939ab65906cb15dacc2cb7266f8a042440eb9a2c86190c58d059872e164cb21d85149a2f186fbde6112c8d256c6640b06b5b01122abc8c5a13ebf01b82a9edde97f69294ea3b2c3308fc423b829c262c95990d907f895cd800be03fca6e66711772597651c2b19efbb6b020870f3f3eb7ab8a94f89d100d01dcb1d3f09c548a3a343668cd7ba9811464a4bac092b2e5b00ce1e7c582048711bba5f982e587781e4f4267b8da51920c92d2968107d180db6af03042396a57b82909f1730a987f51a49c7195f845bbcaa69e09fbcba7ec88589929a9476a06d7b75e226dd872d839350b97cb1fd5c401f2dbc81c1c46e3ca668a33aebd3aa1e702b088869510b1906f12f8d612adb5467dce99a60c5f8c22f1892fe1907ac73bf5008f20e7c648da87cc2d30b1cb8acde1141ef6b1caecbc2d3e13b8f79331dbe6b760e5cc8bef305ad0fd3dae5e90ffa153cefed9a6f815a1dfd98ea2bca4365896d456bba87c587363e7c60be511990c3934f3d80f6b9dae6257fcd3b350fc2c026406583bdd699411988dcf02ba342d373781db64c602969661df4ecfe505749093a7a9a46f04ba4cad6f6089caf974a769bb643befecfd71b3724df7a493aef6e5beee511d013ad9c23655d48bed5a8abe81e9b374d728f0698ea9927c145682c9d527c750d7db53abcafa62a970fcdf4d35d7d5689b441c5d66e72af239cb6be3548ae22eecaaedba3174e23a6972aa219deb2605512367badd7821ca29576676bd421f6d441046004feba50f4c4e5a9801f66bdd80b6beec82d5f57a7bd947c0c569da286add8ded5b938363532980409cce5b636a4c1aac70e063e3c8a075574ba962cbe314380c0a880033cc85de1a3e8c8b92d130f5572c4cfacea51dee424abd986461e8a3bb7183bee9231a1c5b6b2e7f152e288ef696c86497dee218973bbfcdda1af63e7d75b34335d1bc8013f2ea739ff417c190187fa3d9e4678c656e49f5c038765db6b7b333654171f7a27e4215baa24812735aab4de3b26d961c2ab87933dfb947cfb58cac3fe27902831c58efd4f976d6fd8e2dfe63d812626df1f1deb42feb74401ea7134291648bd31bbf26cef6b49ae8b26406222d129ee0ff40a9466f3c6af5f1d08a04d2290eb9fc34002b89491d28ce87f720231178f61ed44d808832d1dea24799b2bad62e241df4fe9b1088f29403d9bd82299836c7c8b6a8973a81d06952bf439c51717de42376f34085fb48d5986d3c42f45d28a0c850040b13e47381fcbea8c93ec7c881263a3142cb139c268df0eb1b3ff9148edab1404b24d11076858f6f925fd4e984823086200abfc31122f6163e287c2c675db5cd528ced2490e0df3562186e33b8aaf1c86473e6eb2111cadccc7d0393f3fc7756d3f2e92fb73d769a4dc1b33b7e273d9ec0579f9c1551b563268cbffef48e86966717c019f51b21c04ed3bd59f59e4079db07735b091d2579741ee2901f92b16d4af41d614cd698e689f251f04e0c020d19dd3ae689cea4df8f0c087ab1b3637e30d7e8d4d97680fcd2cea9a925bf3df7349691c29115babfd4cb5568b9537a7fc16c945f0e2c00c525c0728c1e5ebfc71a6a931d11c5ed4721f887ceb801c23751b90a5ba6b8962e60bfbfe62834794bb085d0afc66e331d0b7fad25106187bc4df1b3382f5512915e5bff85526e5f25f217907eec32cc52fb4defec55d97f99a23942ba416c81a656b8c18e9e79988be42ab4e6d593017a54cb0ae71de8545af436f4909cfcaba72a3cbf334b83c26ce2177550989f75d27f74e564c1a2a5a60305d8b1bb32699c27190ae877f698244de43b1928d2774883aee168744926fe975ad79fbf37a558ebf91561ae3daa927ed7aeb70fa3b18c8449036e2adf54fd5fdb3957fd5f791523468dccaf00b640dcc2cd927cfc3f3801f08001ed99b635e13b9a2d11b8401fb4afc42400462fa0daea007db9019caa58c5479c523e22f0787c207c4eacf0d3fe75df83f88014d76bcc87a223327d57392a0369d5f660c3aa052245780fbbb5d021397893ca50c5afdefda39d0c6c32554004d0b7598fb77caac4ae62740391bb5735a771f94e28669f6a00fb566b0781d25609b337fa855859577f7bcc771ba2786443424cab4a3acdeefaacab1951da0083bc52a3f0eee56bff90f9306de870664149a68a4d3b4384a780ffc0531379bbf17087d830970418ccaceed14c0ebce80a6c7db3d14c5539285fbc408b3ee245fab4a30489061f50e4e8a7760759fb1a0c62fb02f5e998c11a982b685f1df0f917c43614b5c3d6bfba60c7677a771888193c39351a4d1d5b01e2d3c11b0b165a544654867eb29f4c07e705a2ac53760df1b76ae85c47d8141ff6f7e85b574788c42f46434739bd35c84e99b44d5a74be36ea241939a3346a74e9d69bd49647f361e39a7fba445c07743a5bea32bd8b8cafc00c98daa05d9f619e15c1bc2ebfd6966063a6269f32c87435ea6b3b267a8c727f8eea92118787f6a79401eb1e37b452addda0799af693b582cc3e7fbc34f76d11866d8fc7495cee12df65f50655e8f912789df53d205aa807c258c4e705ac51696b84431b59cfa4df8b13564627dfd5b84bb65108a4487eca8d7ade92aaef4e437080b43ddd66a402c74b2febd7968cbf3f077408774f674eff192d83b99c03b57f3d3afce4c576e7fe84266b51b390c123175f82e19870e0b3bf7a83875009882ebeac7d57496b4c0ac68248ed04a378b803f207a9f8ba6e84c8164e8d7e0bf6902b528ea70627f4ef03c3b44b66258b7467b2eddb2445bbc9a7c9eb9cdebbdc98a0140bacbc1e5f4ec187f1be60c7c4db1b3531586287a2511c9a67b8f33a174cd8c717af52fc07c04b521a2bf37a7a5d6be52328d7454d7d7313af69d93e79cb756008498bf14c3e740ea2f455cb47b2731a3c2071a076479b3c3973fbff22869df1bbc2d5d36ecbe87306a9b8f15023bb0e6b98c1423f80d24bb06134ff10ef65daefa5af13e31c786219c5659909ea6b1f3656ae102be224e2e173f26b12a2c16483420bb8c1969723fe2fd7f7adaa6348ea5b98d78fef6bb246937f7a214bae76edcc9ce45b8dd12308c9713d1b438d38ce2126c6eb9467fc558c145c6cb7f40dda37f87ec8f434dff6ef3b70d1cfc9276e54f8cb2df2749da4ee68572885be97f806a9801c182e9e9a1617533ac82742684fa160595225bb85e606baecb49926c8ebc3201e71b1052f3fa168e69b383dcd7c90dfadf5e1a7bb9b870bc83a285786d489e626ef5c6019d991c52b6739eba62de7b2c31908e5eb8cd1f9b94cbd128ecfe5ab88c61c1a2d96cd600cb58495a7f354e1ecaffe24fcad5f5c5057572d37ecc2de40c78049395d43831bcf15f881a15fc60c35ac5e3d5942c55da2649b191903f7997a0cc8846dc24273f8800928cef63c4c8d398918e2e0b137ad2ff02c1c54bd2ca5e815e1d0127a4f9be06142d52e3910aec9fdb5545f5118523abec75805f7a484d32ae581abaeeb6b6d21285209a54c13485efb30c0b546da89f6a82864070286415f4a053d45da894c8d59ff2749b97427c963a08a5ce5b615f38ca9636f68f1d2ebdcc027dfef053bdababd1f5ca58dbce97b23b173fb9f931f5672c6a7b760e9852d107b39d4d56ac152e32f9c90d9c468524c211337a7b150950dc32604b4634a6f61b5ec1e9d8251f447c94c0384514419edeaae508aba75111c2b410d1085569c49832499f5a35b25e20b9b962b21d034975046b5071a821043f8ed2c8c70249f2905b86057fe3a6e307ff1ec670b893f148713ac1b2d98662f181e7da8e0fd6287cfdaa5bb15fe049b62c132e2bb74e0fa11fbdcb6145a5d15c2863d18f8e14bf6735f45c110f01d1c9797ce6c9563946673cd643a9f978901467d437e5c23558dd33991eb332eaf19d5dc0f413b18f7928fdd0554d44dfff827ac1f7e233c88fa3fec7393797157a91f9f92ce6dd7f7dba3fb91de25fa6e0a9fb267fdbbd1d162ebcd6db80e1a491d7ccb8507e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"54862202a349af85077d1830ad1e6d11"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
