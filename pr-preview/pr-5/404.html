<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2e8ef91670446d987b22a72a410eacc863d9c57e2184799e3025328ac0d86dcdef2cd7301f12db8857dad38c3fce2a0344d77caed148dd0a189b0123329c499b4f78bbd9a339a570f76e6462d236660ed1e5c0aecba07b9bdda39742baded71cc3552806b6e0ee8f040c09f2a75789d346d7a903cd1fc34e82ea72e2a26495cba06ff63570e7f201b761a555bb1f7e57dfdea172ee69b0b7761f85db92c85ce5e7cc091508c0d93cbeec1d03ccae6b458f21e5715b031c336686a4b30712aef63b991482442858add0ed77a55913e0c9272729d8d07db6fa1825470448591e2791ec3aff9ad898c575610828ba6b89f1acff2ea39e1dd0caed0dbec4897c1736fe6e84d0734170684b4abc425ca54bf95af7be23ba1b82de4b8c465e25659d82332d4ec220387cb306039140fae9bdb67c925cfd8bf6460e4302f2b0181f43653b8bf7b4bca4ea6d4f8742576a0edbab3215a95a979d6e76880af2fbaeef5d132744ebfd243075b4cd3dac969eb526f14ac400068fed9f099e1a0cdbffe506c1961e31deec23b07491b94f2646b2ad03e9a3f2bf6907584ba37c265eaa5c24dcd40f22414bb6b6af79c3ac447bbc0c990d5b01a00806b1a67e7f673e5da8189ae5dc27104dced86203fa675a9dd53c988e9458b8eec3baa7dd42c8f22c2d4667b952013bac0f55f78edb2ba363e2a4e542f5db1e816eca9e34ddfd1a12a580df7c8e651e54acff28aeb6ffd01db89794418b92afede4663b262b8d24e7ece886f351d3dedf456d3181456a1c89adfd15c6a8bff603ec4170c4324dc1592f768fddfd0e59d9b7dc6f0733960c8bddaa5b87fd9a1d94307e8161729b40211e7fb0313a313cd7a8ed16d0fd6ce78cdb40783b43d4a46421e5044dee23037b0b39712f81fba5c4644deab807c39cd729771e269e96cc9dd2cb1c6d5b92735cf2c28c829d25962dc0aef277bf3f9e45d0557c0e0d5b318800c264fbd36cf71d38068bfaf085099e7ba32c5e1cde03f45e093beebe9e77a999faefed09bf441c0e885c998c11471891d172dcf30ee8c6ce0f8a05532597542020790ed537dc030382e4baa964e531e2a1cd421f120c1443cf3726a946abceb34d2046f1c69f2a5060e364ea082c66eca2e5d4a94c0e5319a9777b71059f7e09f75379736017690f562d47a928428926a53bcc2dc63edf14725db5537e31a5f36f98155374f3850baf9056deaf8e43daa0d6f3eae90f78373f1dfb9947f6c929fe9d28f5a3bfaa0ca2878531aa3a6f1d085964868619e3d8da914bf240f1a9b6e83ff8f58bddab02b4fe5e54e4688cc3ed59d3559f8cde89481f8fa54fafac7c82eecd2e32abed00a860d98df02b27021f874f8f84fcd854eed41ed34441b844127d15d94a925607becbed5b9a90a2818a384338e403b399f8e2868123d23494d8daf53c965538cfb50a5b8a88744515830e721d50bd71ccb2d683b29dc2789a9234aff2f7bceab9fbff7513bd713fccaf31c816cb397ebc8a9df494a96716ecc893d496c5dd5d6730378cea353bd5fb4f56fd0615e1a42b1949fa9b6001c10c9a32750f75b4635a454380bf0e121615d08bba96881347d931b5c78e5afc47ae20d8ca901ba815f9286744af722deddb5ce3eeb787cb687edb6da9b8e58ed2d9f79deea233dccb404c5478bb18269ab42ea8f58a3e3c2e1f0489414d66a776a3039b301edc0477469e19da21b2cd9f3bbcbd7ae47049f73573987138ce92d9cb1f2cecaca537550bcb5f35b12c1de404c656f896027ee9dbe43e1f9bb8125529b91834490ea9a2196bb08e4fe5eb656177e2b6bd61f4e9f256deb4575b4ffac696ca9b233e49e54ad3a9e45b3f313437467f6bb3ae886bdb5d2228ec91fa7a6621c80d74ff9973aa1f805c89b6aaaa7d9ab00139c03a7f58b8dbfeb82f324389edcf240483efe3eae20f731a229e1b297ebfb43e0726838fe4f2656de41dad2430409f429ecf1dd3b90ce63cb6b13c1e57c1e0cafec2ee8b2201020a9491e7699950fade30788c155a1c0105255ec7792edd77dd4bb25c81fa3ae20f12bf3351def4cec12b9aec243b89adf76002d2d9ff676d4a468b4bfad8a154a656676077be2c0ca62f1748d4736abe2a78142554f6d70e08022ec25876fdd7379721b02e25c79566e70bdd38577ec80715deee8203d1d43c4f5b103cbe368c1098ce3ed2328c0d0aa174aab1711d6ef44634c0d9d075a36bc4afa4a8bcc964cee89a2b270c0f07c3f830095fbd53da428a1702085587078e075f805eb0397f9f41614e2fbb68aafbfe58138c5b28597c8a9bd99f3b092b80ce866739740018f2a1ebeda075891c4b5515ad67fb9bc0240e041d43c8c021a213ca96347b314a416e1fe8d20f0a9a3478ab2692729e0449232a870dc67151e8122ffadea0bbc16608075fa4ed8e74af66053394405f2d742182562ecad3469fc0ab15e6c54b3c6790ed4d06917d6f18ff81c1e955b070bbaab5b21e60fbdbac243dbb2c8e109d689945b936921cdce732747f61a91fcf7916b1202a457f23872954c23e07b6ca3a5425ecacfa7a62914fd9739c092f062845008b69fb1b2425552d114371c39f0befe56799d99001419b6272e6a470b3c33a8f5cfc31a7ad5e70d23546c3067a4037d3bcbea9ae8788a0ef8f3d4916aac263eaf83a95138becc8431eeedcc66ef11055ad383d0547e0ef73a5f0a100c80bf26af0ef24a8c16158d9f3de79f16582c36d0d4e44c961706194959b0deb9bb400283a12912ed234945c4ef49585a0da0b83de12035915e9d913d196b696473a1be08eb108ae355b86741a1c875a4da1a3e0acfea406e5937146a662c0177a49ed69b609c699f1ab71f6fd19038a193fa2aa41f25571b5d91c5980863932599a2a53acf9a688b5d737681e602b3776afeda30fc5d5d880f4e23f0e3b8221f5fc545d132151b640ea9cf9d9629ae040fd7437b17167bd3a2d0ca4d6a7d444632dd54554d33fa97d30f48818ca59888097cb7889140f1c1ccb167844af475783d3dd1d6b3d7e944e84a1e18065d105af05d0fefdd6927eaa0280cf253d679034b8ce6093e2c844bfb54b3b3f834d0bb54ba211c42d15d4ff9b31782220dca22672b700f05c3ed8900ddcf7bc684125489142b101b9645337976cb1be97fcc2a62401728150a02293596daebdd44e47b931838a4b368fc74f49397275020e16782a8e5800e10dc6742354da3d2ad9d6dd83b4f5a5bbb7d61fdfa8b1d188f9b192304f81df2f0dc9c46e76ec74f754c5d8fa6690929c54ef3692e637f33addd5368a2179505c92369229e892f60ad2f7446e2e8e65b32cb2e451bd880879282c8e1b3316db3d2c02a69118b69560a86407f568919cf147dbeb50fffd33d3c5a70beb9acad1105203ce21140d40c76a13e33e066b760ea4f89f7e0db8a42c9dd8733b387eaa27a5a14fa46424e1f7d58f809f44b166d0f035894a216d24347c2097ac44b0502b8d8a72adbf47d57b4212dd61ceaf5c3afcccfe7d30f235f2e69324f17c35e2b9e5006846aac36203dda696f0dd3ef1d0a5cb0683f686b7c23b9b4b0a3df3d691e42ea218ca57d54a154ab5f780feb5d327635421f3f0e4734d47e8ec757573e0b8d7b311dc160a73e3114ee09f0c8e5cffd5a41a55520ca024525fa8f4630ea92a76c63d4837137271948c04474843b8a21ece4be607c9a36523de5afce8d9321450e46902dc6bc01d97185720060c49559fb52f4da91fb8a05dc1a4399442eb8e6444cbc4355f619bbdb2c92af8490f1075cfc96953d09b7f78da04677ccee8dd67a65f05cc00c9c47054441c315089fcbbf3b8c07a873aaad34df94cff2b1f1318340b535f60920020cd27ca118c38961948dd878753b1e2ceb23513c24997f472a79df931a2bcca52fd9703e3de96dccd192b5799b384494ed8a9f9bac9e815acbcc9a85add8fddf6c71ff153ad336a93b63794f06ece202664327b2b9d06f0b6c08062b6a37d49f0b84698b742a413a277f95b765fa4e5b89f9d81c5144491adac98c2c5a46eb965ed341da747961afd432aa7a1a8c896fa3284dee0e474b4548da739cf341fedb865dd8e290f150ed20de6c33e42fc03293f92d6a53156dadecb167e4001f209c095ebb14e1d48c068d663143c29eca87c8708afbb638c8dbf0aa47068d041e717e05f25a750d00017e32d6ab70e5402104d6b26c507b0e31a558de335c1be1e742b1cbde1939def127289b5db0ba256004cbb0c3f58c4dacfff05f77912318d7d4cfc4316cf2845b7567cd03bf13f25d224ab758f6961e950aabb1e524f4f5c94c9151d3abcd469905c647fed08f434f4b61211c70c2562556aca6fb9ef1cd83f5c7f977fe4b22f99d94ff290c5c948735eead73b014a279c82feed1ef88a41d696239635e3ece4981d153ce91c3e5139d0d36991b93d8ca5dd444145a2e8711bf97d47972507f5801f793e4d0ded5281444e3c89672893a09df890c70877c168b222478e0e0cd65d1a660f0f329fed99c157196e31d77eee292afbec20950ebc2cf922d4d0649f91ad059b4cc319f0b941741c46d04d8cf711708c91f59d96404a67909d906855cd081a4ef0bf5e2a96b20d049e44e4767d61bbf8d0d71cd1004e59a1f1f3c1059d63d2ab7930d3bc2881ff6de7c2a89d8abdf8f2d414fe80a9bbcbcea5f9faa8d1023e328d9ec5e4d5596b2e0c551da3225d4ee70a12e72c48feeff74b0e3da9261f3fa9a623cedc386d01611c3594bee2f86b3a14bb5ebad8ba9a6537121328a7d529f523852ea9ba6122a8b5422a141655e95ce08831669d1d5070cc1931eb092e5191356a524b04d7cc93966c188e63cba775d5268ab5880f7dd59a730e10f09b9ab17a9c6698643988f385ab1284f2ccb8c6cefc27e9cda544f5856d3684fad1da49b9bacf9471c24e7749f8ce2b934ea9d46fd22bb02e6f4e9f3800a803c79ada879b16eb2c6ae18864cb7150a3773e423d2dcd9c138683877f0970b94e2cb619d717bf0742cf3ff10d863b7ce6381c75f0cce8ceba4faeb772f99fe7f945f6f08375bc625fd0118e5fa2d5130ed1f679be12dc42d8aaf22f3a6ea43c6458aec4bbdf8d1b93da0b7162dd45f7cfddf272429ec70397f451bd07047db02b79a3a802f5b39931481a07ef0c291a9f57103244518b655ef244a706e793b4609b0484c708ff03963359e590ab5a746edc8da976975ab7e170cd0b68f8ebe9264721f67c1d9388974df081241180d78fbd5afcde60838096a4ac572d1361e6cc8ee20e999a6c8e5261233ff8379f07fbab5ab7c60f07766c135c6e008d5e729af531130be609f37fde862ff81da58f5e6d64a979ec2b57fdd4bb3b72fe1ce55739d363f2bafcdea8db9514af15ae5757d6de92f5a7f4f8be53f3f03b22b51c6c71aa8c37165ae876817f4929ee159b3c0dadb2642c89de3e9de178a55ab53fcdeb283b575c0cbc85fab6c5c1772de3220979bc8ee934224014eb7c6aa048d8a2ce9e50f4ec360b46bfcf8743eb1a6ad21f3ecb2d1c4d0886f30b6cabb6566d80f61d20e7e0e5c3a02bb910f5ac40aafb2bd57fa9ef623850a40fa0bb0cb37fd598d80550c849a10d7c3cc2f9decbbd2fa76ccc62bb3247f072097e92b5e24ae155c5eeec0acb94e7d13c3baefc94c2c641ff3c64bc6d6961265541b521fa198bd41545f33ea7773656639df433e0fea0b26a75e8c0e4ff001571a3d18aa445854f77cf3036af83bb4046b6f5eb77482668111fa272b42b7a083a8327e67f5ba53937127fc8e3cada72c1f696a2f1155cb254df43893e3a0cca98b7fa543ea8c4fd2f0f22673da58e2b5a9a9df4592a20fa32b7e8c3875f54fa0278e1246bb856166b42c679a68cc1de8377ab83b5105182a15de56a90e84d7ffad6093f89196f0ee096aede28f2055afb1ecd46c6d239fcee6d3b00914c854f4a48912b8e690559fa113d90ffde4c42dd1df8ceb44b2056a9ce46c209349459d9e13ac76b11f11617d2dafe24500f822a0e983417a3a4b0623d918d98a3adee936e8157c497391261003c8ec42191bbda9f0103dd2c222520bbe1d0b0e7748e60e75163d35248ced7e591155247a19abcc7e3f107136ca706bd885848ec43a2e7c74af6ec5041362bbfcbfaa1a8a857a3f1df18e0bb100d08e055f70722a9c1c71a761b353ed724e3567c62c9c588a1567e79006a8a409bd0ae17ff450bc5d216f34e2b71ef2e0d66da0e78ec6f690a6eed0d5778faa988b62d6d8e0dd5ff6ba5d6876cec77c66d380ed731c5e04f8e489675cf8865902b719a282a8562d8ae111cee483dcf492673a2b21b51fff75bf36ca3b59cba110a6e47c0d48afcef24cd2ba674a8942368841757b8ebbbb0f6f6454b3bbc4b9a6717138d365f1b08b22e16701c5b87536ceea0ca7ebb503ac06a76aaccd9856ed33758bcca559a7dbdc1dbc07fa2fd47e1f27dcb86e6cb76416a4cd136ab9348e7f705cbeced91c077cc1ab2ab03d37267724f62140a7aec4d09f18a5bdc6da7261eaacad199a3eca0a2896980c688dac4caa917b69425ff18fcab6a408c0de4e0a89927dabdd4576816b7460abe81cb8e91904a9cda303b7be4c7377566d5235cfb0fca6b67ca9c8d16c7a35004ed891c01e42689a73f439beb0c488d8a7cfa6ed667167a1f319395bbf73947763726939b09b26af1a6b2e2ab7b94bd87b49d508fa030ecf795c8530a02a42c8a916606d900d396a458d3888b62548990d92cc0b45af2573f68c9327af106925062b121fda0c81f84dfafeee4ce80b25579f95712daaa2c0b19ad926f8dbf58cc95340b22fa6cee257edf6db9cae95fc0976f601dc4cc55b2f9797937bc2cf4442b6800f443da820e99ce8bc290a626ee486aa9d16bb5dd06704f596cb8e5fc919f9df14d64ee43493eb93771c4d45def1febede81c0af31793daad72bf5ce826f06a6992572d37d5c768a30dcb52428f96b1cb33b328bdc457d29f8e3ce9efeef43ce1fcb35afce8ae934a76a8ba64094af2fc2bf7dec63cfb4c7b95412e210d7c84e1c06b6c2143867f50bc528739bb7a59d83385eea5e5c615d79238b9a3675d67cb276130d4b477674643bf16b82f5909faed95ea306bc0bf0ddfc22e5a0035b4b51ea84128ee378576da77fc912ec810eef7436373f31aa8790d967604350b3740f33d882661188cdfbf23ed5260f51f1010f310c152b42374e8addc4e7fe2953492632592c1fc524433da5ed1e21ee336775d70a085fbb60fd8ec7a4ac62e08c796a0d90f3f69c36e6480a9f988a9cd2764266e568c4abcd3dcd7f5c6461ec428ad6938ed03bc5754725edaed3ba3d08eb96f2c6e31082717d911d0ecedaafb3369f19ac0241d9ae01895743cb770e9a57523616245321b9efaab0562f7e42dd2c29b537d7fc9d981585bd4cc209eeb0a5c6d660fe36b55adcad37a62d94fdb35f54aa993fd61f2b2a3ed8bb0387609bd91ce62be3f4a6d61405e4a46a6751a71ca1bbbc743d8300f10552d6eff07799e4ac03ae26b72c02adb2e33d084eeaf8d8c5a70cec97678e8435f5e368cafdb1e1b1225966f7ff20fac288718ad6b7079a4e2c50bb929ab4c1657319b83f5d48d61aade76ce4939bc00ee4e953c5d45a8eee7575b9efc5cc801382480c0390de7ec8b9b0e4aac601bebec31dc35a5e57b73b17a9f8e95f8e48cdcc34953d1dc587afbafe48b766c6a641e2f3f486be87fa5b3acc3884f601e67a444e83412083ffa07b834ce425cb2e3d62ba9d45f1407917bf495c3bd0506c0a0e0866aaea09db225f3e575c602b1fd06009cef6a96a67d487a12535494acfe2ad92ef7a08e729ae0ac63fec6cff8a424847387386659cf946a98666f484b66040858f949516b2bd5c6db15d4288fb46d345af01f498dcfa919bbaa6fd24f1d04f8788ddc195efbf229ebe1daba65759cfb87384e3aee8128943e363d5b9cbf99b6748c00f3e9d5e4f7ea8a1df09e35b9446624f7db842bceefea47eb11499a97461c81a2b9f7d800848e1973079cb097650d12d69ab44039f4851c04ae6a59c824dc678f95deb0aaa39819c406330ad15b1413443f2c9769468426a092d741018133b6a3d7a727d9774f6c2cfbc7f66fb44ded79f766dc1e9543b8182878b7fde7ae6d5d2368fedd5a00bfa9cb5eabcf09efa0cbeebadb5fafb810676d680d39ee96c3c75ffe1ee2ddb0cf8a740d0ae47aa0683e3ec3cf77064a33c9729ca0a9ec0d386b9f8dd7d15a563eefeb86c60ff1dc5c2a11d137285ab9060a31ba5cfadbb9bddfe049f0a2f5416ca0ce3a74acee160232f49ca37cc77ea9226630831f232f83eccda6f74789f52b8906c80bdd36c52e4c877dc582681b9f15a6f0aa38d6cca5eb9c7938364e6711352f12e859f137885385b56bb9333a892fd088d643a0ab94896edf8d4bed26c79b69a8b79a8a7167726bd62aad106609a121a7a82d00d01db42cea7813edbac5940daa49ac9e2333cd601a329d63b969e8edfbfb2d5c8ca5aa6e72d8e38ed1506e021b218cbdb73c183e3e24ea4eeb3158a7322f8307ac2b2c9c0bf9a52688a9970ad4fc2061872f9ff5cf3033e0b049eeae7e928d375363d799ea210b44d476701eaa58b1976f6f3f150a1e00a49bd547884bd9032ab97418f2bec322cd7bd40cc7142f025d10468f2ba414a7a93b3076cdf9e6610a6c130c548437f65b6a053fa8559617078421b77e90a54da0b489a50c1f7ade80455befda6720baefbccae5a845ffbd072958559dad8af8a860faa38980b346f356f6495d0940dd1f24592fad68778b656ed14cbb441715fe33820240cce74af6fe28d3bd8be6cb05eeef45049353ffcfffd3846c0808835f0a9444077fe1004099717a2a606b54c4ca88e42ced0498883a6395728a9b9db654184ce38c9d0355fb5ad918ec6a266a75de5410180aa4e37c6d0c7441548a0629c390dbc7bbf2675a37dc59ff7d813a74d722537d71cc051ffa5bc83e9dacdfb90da4749095e707b8fcbd176037772359f58d1dcbb8495ad1ab5ae1302094244431837e5f01cd40b1e3624f0a383ce1d694171650fb32cc36c90dc223480e8d82b12fc367b5ee68bcf9466705ec18e08f1edab040022aefba1cbd4a8233b733c9e4704e064dd2b89b7f21ca8a30f79837a35b932d061bafe4d582b13cf835a9cf82f7dad52a0829c9ba753efd140b9ed76950236726c9d24de69d0fe2fa40aba69e04f229288bbfeddf065bc65a1443ecdbdc088c44dd734740428d0fb17429561f153de81934aa7c76b78948d8d48e51072804f41112b677a0a9c0c19521f147e935d2cf710bce2e5b6ec64d0ecbf9b4d368ddca1343f354666c456af1852bc24f9216db530e39b387e2fe815844aaa332a3d4d12883b89da2655c7b6a46219c069744980fe32bc9dec3ffc91b3dccafa6944c19d7e556499f86c1295e948015f5c2e9f47436553d89f9f7464ff7384dc052c43911d789edc738c0ae60699d3fa0f606265c22d57012c0793d49e61f3ead6c4ca2be4819963d40a2219fa7f588e771165360e5fbd7a3c94864e4eed8b58f4a28cf41866a6d91b8f4d6a7daa082ddae222bf3fec3efaa038a53247f5f9392c2b65525d71730eb9e4e7564e88396622408683c1675208f492662ec03d4fd28c341b8e9efc36eb036df1984627ca9fa62e779e8ff5a523b4cbb148220ea512cc336d7e8f593889d0fcf17390b84cd88a1adc6996735351cd86286ac821f72bfd2783ab106ebe825e2e98ec3f747334eca46c026b6f762c0c3289a8290c11c3e82d9f0b4942c31f54f41c363957de60602a3273cca702c9826986a2d1c74d5db2e558fece10066a0a1e82c758169cee2ecfc6220dadb859f020a87b605a859e7b6e343400ce7fa4373da8df3245f5b625a3dd022e45e69c9c63b7c8514fec366fbd1b492cc7cae5b70c3c6add140b237944d86e5a741c88efe50cb6fccbcf428d23daf3b95b9fbba7bb7a124e2ae0c8ace23e8e21b46e4101b4c0fc0ddb60627cbd50c1d75b0f214df76e64b946dac976ecc0f35df91947e40cb165d5473bd57b0ba5a94312c17e594f5142edb8e59dc847e6a1cb710e8d8dc4a3e38e00e912ff126a4f5771b4e92e9e9396da4d22cdc06bb9e05f6f95986e4d01f50358b149e82558f6e7e2803237b595ee9064aee283a54893a64928a7d2b3cc901f3d53866356f7d0f6753de8a568fb4a8e804887a7b2b48a39de282d06210d3405e5cf68af2adb0e859f293043adb94d06997cabbd79f7b2f79ec2ef0e79386efbdd8bdd9114221fe78803d71dacaa65d500acabd518f5424266904c1f2625b576ddd6fbb7f62fb2abda19f6cd923f2d8b2fcc76c688f485934192110b0f6dacf83b821c4fdaa74103f777b5687b7ac10e7cbde6b1e8c7d545579b3bce735229a8762784f352c1a6eb4db9fb8df725faad17b7612fa66911b7679913f9a5cca05f9d527de4889162a6941a11b99e9849401cd50960128309e6e0d465ae633c66ec53f0f019f00efdbc950fa85c9180a482937aceaafd27ad34b716a6a9710c811024ecacfcebfc9abafaabcbb66c3a7bde4f9587fa2d044708fbc92d3df992e0430c75313711ddf71fe56bde59a5f3bba6571ce3c95b37deef8871859626ac7421f8a41d8d3f84552b8a28cf80245ba49ad4ec0b5fad01b5496a98dc85c22aa74c966df45c71e39bcbb4074c84ab7064f70872b1f4af6acb3d925ada35c5c4f89450546959fcb763820df720f2de537918edc5b7ee2761f28a4eab756ae10e5e1e9af3eb2214f12eecb53269581e598fb0cd5bf4d96b8a1b7fc623663dd299c34081541ebbc38af6750c939dcf10ce912ce1396a764881d036c74a12eb82c69cd37405e022c36a60536d728a691d0c8e468a7b5114a1bdf5a4cef71c0cd3e4c8078e7a75b5f3d7fe0905da9948b8bc73e063dfc32dd04bd6b875d5e3871af6997f120ea16ea6d40d1d2a5884390c24c2dec729225acaa13a097fe8517d070fc1dd3f0515ebae2a4615ccec6f629dc16271c3850977074d6999d97bf139fa1f38a8194ce77c6d7eee2be1dc018b59a93ec69c80f342cbf76962d70d0d42da2fb71ba4c234fd74f5039b603d393012c81977a5ab5d227c59ecb20c347c8447b467321451a392c6cb7e4b9e2ad29694d65f6e26fc265f3980cab17798423f4a001f1f0f0850e1966dbd024be48e24a4c1dbcf04cb10e9241666b125e4ce6ca50c3349b38c3cfcc94aa80a002b60081b1644ef2875521b79702031db41c9ddd6773078d6cdf795689cfe838c3b7d5f8dec91f6a0e5e35e453238a7cbe3f3a2951e170dea43d9c556c46ff197c4261f469a545814bf7231310e0b597d50c7960c2df55435afc3e6742812909bc48834a6b11d040e166759ae0e6d15ecdc4c77334ef77b1c77a4ef765b40e672be1de6290df6b5f63d94153075fd9e42f689d87eebca1ee0339dcb550e1924553fc46e3657d94b6773b7be1b9699aa0797db5ac373e32525b9eb5099bba424690ce34dfa06cdbb59df1f1de0f321bd867b64f39e8e9248e6e17779dc2cbd704f7ec3fdadc2e7caf69f028492433e1ad831e56700788309dcbd3d1a5b751d9a1c43206c07db279d51e6bc8432a58ccd846de7b7b5c0217f6d0932d008a0ebf8109cd64a57f3cf4d42b1803bf5a1c97027b7b3b173f979397050df73b14f7e1abaa97d49661900f09fd38963996358e677324b2b294a67f9508fa810b9446c0c45e9855b818ca74585dbac6279ec5f012545cff379adfcbb81c53c8e5d3aafe2d5ec28d9ddccd3d647cf65f801df7e8ac81eff0264a0d049a17e0946d503cbacf016e935590690f969030f11353cd1e6a6cf16bdb21975eb9f8d47027b2c3ec43a426079438a09f2d732d3c441af656c3fba9bf379eac94836404fb69011665a7a0dc0eec1e80e28ea807c7bbcaad8a0d87a59aa9b2aee6dba8d08e3605d265bcf23ec9a62d5973fb4f739e956fc435d860dd876a6e007cf3e24875fd742447c5f7156d27098d065b9c6288eeda06d0a98e1479d41fda08bae2d4473c21e1c24149fa46c91de669805b3d488edf1c049be83ef46aacb858d8254941c2755f33e875aae5b453b34f59461c82a1e012fbb0e2e3d55139a8e016baf742a5dabf2b4658a83d4346d491097f62c16f4c7c8860e5bd83642cd2c14bfa5dfaf289c956a2995e3a589d56e969e967a5a47a369f27100e40013e3321b68cd933d1323fa311add2af943c81c536b11e7d09b62cc478a7006968428316b3eec5e0f70dcbc53911b581fe31d1d750c951a29160a4a9fb4ad9e198047f90e7966526cceb9da5e945bb70166b0e3a037de40f4906b6682063bf2f1ba0b471c11bc0a74ab0aa061e83dc7401bb9ca969f71d65a8e717ecfcf84d453943ead4bc0245bae261c2d7dea74449089aa4315984ef27c31384746e297e18b70e037a01892fa615abc0eb4ff9a3a74b6b48ba2279e6db1dadbc583f4defaa09696c360ef154e33d1c85a83217cd6e6516fe6d8fd2952d838621d604d9c5c7e34a5ca24e36256dd227dc6162753935c271941121613a6f4098286a6dea055c3c9b59fe45e1706516370770c8dd7acecacb57a9a010d32a8175e5ad3faca97d151fa390e34e17a9247e76a01cb654c3f134725d5af8e883384eac7ac7e7b4e685dde3828a8115f0143c7ed4538dda06be54327bf08bf61d6fbecf0de891dde3fd3dbef2f2d92157bdcd0816fd4b7303f5c9b29fb00a234311c0cc26a74c3d5a607a883ad275f1dba910c4ee825a7ad352710f8cc04918f88d8f46c83d240a5f0e2306c623d4a9296ca67e30e55dba6663855321c8ddcd6518feea1fa1fdc8d89cdea28e95f3a68aed6ecf734af4632e5cec4ed0f47542b215a2f1277632c927b1d38a3319884775585f8f535e386fc10bf7c189146a511857216e1c8f4dbe4ad523cf1b56f325809ae7ce7b66587a720909dab27c87c0220951f0af9eaad0b7d52ad9c2539f4ac8ea42b41e97e819c3188eaa68dacf59218713f3764f7acd44c03f646dd298771bb857e5fdc0140d24c1b6611a2d7509a94c0b9776082bab58b6dd6435b131a34853f90803e3aa385177c8cf71ac40ef31d6c011187cae2d871375041ef4e9b04a9dd663f0969510a8839bbcafed83214d550a4417b7bf438e9972bfce76a8f855df95fb696eb2d4ad4d0bf1854689675684b01fd1de9523be7311d72e9845300a8fbc30dc9a2ed6b187bb932f6578afbba97454c50e0f265b4f6a1db0cb091770f3fec2a44afb9f92477c2017e848b24a9536de0ef5180d4804c6c5b05ce2fff2ba0d4476f83d7015607e7b96b5bfe95d59b195cc2108286f1b39a3a0e12538f6feec073df13cbd6e90a75100b5f6ab47433d12b1a9050012413e3e0a966a8ceeeac6b13c51b2de6ef8863dd8add8d7f7b94e543626d733f7980005b7f4c5f7da506751857e23c38437637b5e66a43f068e0ed62253aae533a906e93e7b77e0c657e78a5ce73e1d76b2a1ab06287c43fc715c57ea76b5d1b07f34633c98c18d948fe79b14b95f3406c3ea1ff643a744693f9cca3fa15368c31df2d77be18088ba84d61408876ec54f7d054a401f04f38b0c358d7ddc1d47ed83ce4a07d37aea86a12eab5b7c5b6b361ebd1367cd8461285cd42a64db5f7523cbf7fbf30d4a4ab112504ebaa07be754cfc3058d8a5793fd8121341fb9d4500e9cf63dd191937d3543cd0830cdce7c316ca6d548f57c3b6275841443c609a27b24cb8b528f20ad0f0ae50457e5dce52b62fd37808c863fa7f6829b7693ad61425fea79017792e19a7b4a82c56d4092b6231c6af23cda17586f6d31de88289a66d52f4dd7eabc90981a99cdb5c9aa9a1a64b0c60539ca1bb582cdc27ace9f856dd85c435cd76ee77a6e632b4b47756d2163db90c3699c4b035161cee4fc2d866f369b34e529da0aa809a19df6a287b45928fe109325406859ff7610adc857901259a5b5e7e68c20b69e2431b8ced24106d967c7cbd6efe17f3a4915217dac278d0517cf087c181818411b4d10755ffa39cea77f29ee6ec232ce5573def1befa708dac625a190b9bb91f3b9ea1824e3aa4144d4fe98b06058a862a1a17e2e47329abc63b67442c3c92acc96c5796cde9a728d298ace37637df2e81c1a415e8bb02dc17f1ad794635f8df2d98f8a047c92d5a943584fe842b65259fbbec8503a601a79e0b0fe1c64d4da7d32d6b87281fa1ab3736a6a72631d8f777c76f14c9d875ad6aa2e210756c50db7032e2464ebda732a548194bad70e082035a8ced37a0118be9cc84cac6bb4faf0566e607d1f8fe55affb12d1c862bbf735828d17be2c025e127e3ea0d5513e3589ba00c18ecd40358f8604598227e155e5dd1e5dab79b8d618c1cf7b0a938dad66566edafb1a2ea320fa741a33ca4ac96375852ebde67aa8b1682f2478586a42b4edd01b0445510d3b3a44b424ee0e2d3ab541dc86114e913f29bf15c8b82e9ee8fe6b0118a64845d87bef392148852e556ec61e85d9cf6292c141ee3433c9f358d881469226a05506f33e2ceae42189cca001f091e4e430084ab39db4416790ec0a221bc2c1ab4d78e97d6b66e81de0e759c7121e7f27fce891ac01874e9372bd7fa862e654cee6052a78192427912719b58a5fefad85b242a96a22b3012914df49b6894a9da5b9f2d8ad77f7e1db88dca1159403f2d7e8f2f313c3812655ae1a89d4cff4de48f3b63416e341f2385a95ade32b41d7c76d8a124137afa986467b9bf72d92cd2bbd32ee17671ce920a3b83a68ed454bd5e3e4ef39cfa76a5220ff7610252c159808ef3fac1a533f06db0bc85cdfed8c84f9bc0404bcda45ba2ff80b98ff37794cb7a96a1d595448b25429746b214f7b547810f4a42233a5536ef6a37c2c26f5f7626781ec8eda32212169274f244c7ccd8f6fe29a1cbab229a2eef9645ab470cec52311da2f6f9609a9942bb3afc9b462756309bfc40ef33732f35582de959bed4313a31783e08c6ae29aaa102b5fef0d6e9019b3229549ad22cf2f5c54a5b99aa181dad0c871298e349107371e72847339c59f3363f0d5b2ffa29c8bb7471c4f355e09700fc47b4a3378fa9e3292bf9d780fb8399b58523879fa6f9b6ef977a79ffdb7c1fe3ffa0b1ccffab9f971124ad67bb91f6c78935c9d366e3e52ee094e48e9a6a4e7a9b76d08dec325731ecaca2f2c94875fe216bf1552e46a296f2f9b1d19a6e3dd2f7bfaface0d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e2468ae4da1f00a5f24932712ab58fc4"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
