<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"379019f4f7fe19ed4c6d652ee44f7471d703643736a78f5c5b81ed5593437dfc602fccecf3fc123132b31fcce8fdb676ac5be93d581d547f3cd04bb8e30c0b3191af1d44687771e0580897f864a815e43474ffa8c5a7b2a5096eee480982f7d71915da629e941cccbb3f89674ca2738953b1a28bf0cfe863313d7db941c3abbc277ffae82c3c78917b64eb1c9e90cd188415ef6db6a35f712832b3d5ab5b09031c70c1666c87a8a4a322aa4a7a900d650c89c44dd1013304fe80475d35f0d72f5ba92d2c59fe3d8a8d98d8942a2e91f572da2791ef55bf1800672c1d0f1ac1a44054a6a9262176f62ae3a4344e9ee1cba7dde5d51a7f5ec294ae6b2e4fffe67db18c9f6c2365b7a08781115844ac23acf1ff6109e117a9a4f7e34125d18403d5926597ab0d9a8e30248d61770e58daacd4232f615ce8433f53f3cbb30c251ca10f2c366c61124126ed5b2b1b7c7376d626695a00c36d6e73feacf0d87b047f2d54d8aeb2e422ffe9938d2cb4d7c7d36c4629b88594e299727455e740942c8874696f98970b14694a2a190aff5e97cc5264ee30cd7fcb3882bb6b35a24e7896a00bfb855a77b3ff9cad75a0b5ad95f298ac963f546f3962495b1bf9492c9ed112d2132237405316d995d97bbb9972ed1ffc0bc747aa225dc089f4ed0551b3808b1d8129fd927dfc3504e12f548d7c56bc7e7fc9fc2d533d98d995e778a8bdf47d622881023aa6b3be5ea114fd4005aeac107add5532a32151379a4be51e0de3ba800f5c695a5240ee84180fd43d86b1b716168fbbd72ac8e82cf6ee2d26f50b1913f87f2ed04df0b5cab8820d45a81476358d420767de62ae3042d863bc662f8ee284e9f66d2ed8af5421bd0f8769430f05132f6ba9d6d62e0c2d5406104e6115eb6fa3ad7e77ee35bcd9776247394598f40ec6ad3ddbbc7da950875bfbe337c5523645349d5b283fe8e9a46ce1bf201d65d196bbbcf5843003110cb895b21a70b1966a0564f7b5799e7e83ae20181d0109e26373f4cf9187fa40aadf7486f75beadfbf42343b382378df86af63472a5bc3103498166617d59bb92d20de83a85af41830657b4cc3a72954f663c96f98d0592c5c0125584d9729ca1ff06ff515601d3e50510c7c2f98856454a8d4f642c3e793aa71e6b57935225b0a3e4e52e768b0f266a11ee686baff23a281bba6b92e27e881071fa21acefb8ef2565fa7ebdeea7b9f0a504525b0936699c69cdc15bc08df7fd8da2c841de4ca1e0e55579f9e7ed4c04186df382ddfd0cdb6b98d036485168fd3f1031835e4a2b14f28cc907503272a3d9439cca47c796ed4f19acaf749d96d8bc6cc5780ca6dfedd05d72fb87e4b804e4644c15241c9bb97d72809daeaefe73788b3eedd6c52eba45b6acdfc9b96dbcf6137a48455644c4ec6daa2484ba5487700b6dca8ffbb2f13e03b762b41fa3b64bb14cd78942c5c737ec7b332336c1b114557637eea0943d5a7e8c180af2b49b81f6628e38c9472a67ff63e1279b6c7fcf6b7f16a6d1c829520476a61649ef7deb3c2e8ebaab71bb0ff44d8894088f748380dc8d365b32f12ef16fee57b2606940366a4284dd08ddc1b06e4cf228086297a015e4f42138bdcad95276c1f2ee0978f4221474020eca2d6f807e6cf7ebd736e0aea6ebf4bd29ee520627f0ae19e5f223ea8958a480a82072d1e6a0db5b53937b3af06629ea92978303b8c6e038b45134b26e318b8ad229a933212fd2fc42353f8866d5931c2480f3f08bb9df63064351f18aa2d5e82132a566d6d750648c4006f53cb07a50abb01274337a96d47bda1b9505ec54ccf5115b1589038220b42863a1095c4b8b2531f0c2fb4e2c3360dad7ba10d3e57dcc46a586d6491166234f487faedacee632fd0e42bd7387104aea7964c8a18621e244738f282ce967606e7adbe7c911507a350c0235fefd192ab0f9ac384fa073a23798906246f13ea6381932d037aa8323f113f2e72d2e33960742d130f6c802bd1939f2f575555eaf73f9495ad59e4b30b4bade64302c4be7c3f329f28acfc56a7d921e8e39ea498ebebf4e83c965bb30933c8bfacf35214ce7a92527b11524d2cf872fe7701b1ae95734c0cf72b93e9b21bcf25300997ff236ce4a6030c4bec4ca697e6be86dd072a4be3a29598b5110b984d113a18f71f5b48f936557364831ac2163117746db4cce77f0f6d83bae0b6ff5322914798295bf701d1b03adccfb63f9640b7b3387eabd8dd2dc136a33f0f11a91cf12e1c6ee5a7637e213fede55d327297ad1ea986aa5779bc3643bf2576741772687d815e6dc1c6a5a200594f3af8afce01be2dff65a89eddee0bbd29b5ba74beb90024c65723daf18ab6fd667c2475e3a7d8a8d5fead534974153eefd6a0a667bcf5c5c68011dd081ebe04dc7c3242b4ef4a674130a808985194686c277d7f935a3673c69e95708858d84ae5a90d7d5a237dc8b84cd51813327a5757d2b643fd6b9d3ad4820263a79e78e8dee95771b45728fa6ddd5e7b423e1477de524023fdeaf11ac020dc77cbe3ce3cf5f1b4121016941660e6f6468d1a7e06107b6f7b8aa42e31b6f29b731a04a92fb41c9df2c2088ba3f04ba0deeeed44244a4cb7d234d740c549d369527cffd3996247e3eb3233e999e3ef517381b4818ace33a22b88b744c00d45a5121e58d5b7a13f287c3334b6b5bdc91c125df43349587eaa1aadf6598d0eb239e5e0024e2dbb92e3df0972c7d8bf02dc5800671ac0228b9b66139e1a7e831b88ac857473f4a34c0f6dd5630aba1504e8e1c3e7a1129f8a5bede8b22774daace4feff3888eb5f46823298e836471d7d795f66fb0acacf3374b9566372b75ff06e94bb17e17e146ff6ae6974111df003760f8ddbf3c49a348474aadfdd21c5652c455fb9f890f8bf533f395704d53d5a3a63932a604bdfb011c3dc64007744ae3b2a64569a5cacad54fa1a54e9e9b92e0899c6c4389c0f676e419d572ca7568fb97768868be2e17c195cfda6ae9c887fbf188295d756777ace0e618404c5959c24692e3fe23a9c3ceb85c0cfdc73f64e9072c232ec49a1652d2c50b192ea7aafc9e6564229405c0e99e5c9c9eea54f980c15b4edb5f23386786a7cd65452e0ca718cff7bad803a6bd8780feaab7654132e146c7e1efdfc6f6517eb259a5be6a6aaf30b4465bc1b345981641261509f47cb526139206d8bff181e7bdd6171c848e258a19875a379f640a6b42197a07ccc0b88a5012ecd125547f13a0ba237346850202052e3818b880c8bebbaf12cf191cde6e1d2a5866954d2f28e4cdb4562e3367b2a6f18198adc03e91ca235419ffff41b866397f4f26eff51aaaf19aa1f4c09778aed6cbcef03b547d05038cb9c654af6f50db38e5f0860c26aab29ff4e50d2dacb5fcc26022c5b3242f8799b16a26d5e9118ff64a20f0f8ddce87c38f9f945f2206a7a40f1baf8c56562518ea2ef0dd498e4bf0e0327946761c4fdf4bb399dd801a39562dfe3912b9f15e0f5dc7e4dc38abcf0e85180b414a26d7bb526aa57b25d759899b58107562ae6ec8ca6d973f300ab05212affa3a5d7089bb8a22040332c7525ba90b07ef49882f0bb859c36d4161bcb1be10d8fce1cf078a199bdee4525534a0fc06104a3e899028625c6f864ecd14a1fe7b4bd3827799b9cb40e4962a6d9f5e94e4131a6913bde38b994798a9f127479ec7390c4fced6ad1577200d6cd95f7452980dbcf3f050655ca02357ecffb8b21ee80bef3b93681a48ccd5003cba0593102ce390b654984aef25dfa4dd6b64ae049ac184f127ef7d8225d184de44f7e4b3db514575de81eb6c0c3c19d6641a6864ad43134736cde2d937eb6d869af2420908cd6eac09743fc7c393016d4dad50380f1d3cbb797756b7b4fbfc8435a3e3d92dffbaea8688fca2803dc8f515e7892ac8b42bce6732a045174e3f43f550b92ce83214b79a719abcb489527a32180e0fa08e2bd825871a8e1d1416ed02ed1c1cba39d9c3d1518f5580828ce69a03a83a0878b5d52f565054fce89937da3570d1db4efc2dd33975374c72986ef343cddf87fab8762431005d282ada25503a258bbcfc9911265539b4ab34ad261a2a824f7ee55e4872830666638c0ab33ab00885acd024def9fd5f0167f04d8ef9d6120a2942defb84fafeef53dab8f7593b2d11aa098d190fd2c06dc8189f5bb58a38651472623683afa12d5cc7350975ba20bfcecbb95283bd365cf95505c4b1b9241d398125ceb2b9b6dc67881e4ec25c227ad6ffc7ec100f6cd41f5a25db6cde4d28c68f5ed3d38564f5f1e30badb5ad4e20ee3f1925e8cc69590e7c357205b07429a0091967a6b26a07b25d947f6fead75b5c9ae5d54e11afab4f90b616faf09fa1e8e13ed5ed07dc41b9f67b1a43d0616226ed25988463b7e86e47ae08d6949824f2a7ceed749ab89a16fa1e16e656400a90e675e6956ff2bc890e2fce688d49459e5642a91455d1e6e61a24607239d4156bf071c5de3188be975e4f603e6729e6db816817abc82aea7a162db45ea9991a21656ed4df6701b591c411b1b5ee51ad8ec4eaa7c0c9267d1c0a96e110b4755283590bb04d76e50bcc1188baa9281da91d4409d455df388ef492c98be406f5d195e46a872153bdb0e0102c7ba2ab7a43be9d6ff8c54f687707c064af21f707c0115f4c372d697bf80402c521245e2d713e5d6a9aad36a04de55a44b4e7b067c989ea0b75afbca8fe3466179d3d5e3f755d3530ac54a81a301a9865f92ccf99a4093026581a5d79b897778f5dcf149a7288b07b1f132ae1a7a5f7296b306e43627a1a658d531a69aefed1fedfd92fc027e0a0b1fd765255e2c159a8e2a37c8dcce55e2c11ec7e5a70445583d5466e39664b7b33921164d9f58e5549fa17d3793617ba23f463857d1bec16da484369e46412585f39251c47fe4726e438b0ebdfe042b06c73f8651058f0f4281f62ac40b9260996f7660728b4b9e161e4ff7b3e0a9bfd8ca807ea2b2a28e465dca6b35423eb15f0ac01f806f40cc639292429ed558274ecb01189cf1a7b4f0ac7244dc948c9b6191a35fd0638ae82f006442c5b6e64b8bf7476fd896108c2c04b7daa0eb135c3870544c9b72ef1a07198afaec7e385e1c52d7a493ff585d56164281a41b98dc5fea6eabef21c7762236b29189eb1dbec865049617c9c15cb8012c249e164f09c32ae3dc57bad055293883d1323981e03cfb69a89dfaa106b0b479b047cef323236ee512dc1fbf45f57cfd49b6994bd9b269f87aeb5e0c5832cb61ad26d5b53a43531d145f0e4869e331cd4b76a7b31a8ccc5d48a7840266026662eefe7572daccb781375cf6aceac32b8f29b2656fc23318848e37c977d2516d6a5e03f69d30a249cbe13fd4a4acbaa19a3c2bb50315d0b81a65f041dc58b89d3174d598533d4a7764bdcdcaf8b65790d22404aeb894c52b9f038925792174868e169953c9fa308a36aff763e12dc485f687f5c11b1fb91cc3cab83f8097991d7108d9cb16001289bc4809d89a5ba5d2808eef127bf78e6cc84e8922f4a9c8b8fb278f9df2b0045cd8d4964167be22caf410fcc8e4d54809b100650bc193082fe33ea12110f83c7fe0019b4214315efb4f4e449ba0087ea2747d7cc3be1c4f8676ca769213dec2e1f51b367b08b0ee8bb615832fdd3d135f538ad327aa12177af9016f29aa2c24f80858ba85a0f4651b22b3efa1506d2c88da3adec6c9da4234695be8f047019ebb3ea08133b21457baaf1ac056e4ff0922113b31493870d1aab0b65f7db94c96fc5eecba3f265322709acc1868e557162ebc01b1f5473057f44ebcd92578a0cbdf9ccb0035faad3bb073c5ddf4d4910402979543c6424a855978bb23a7d78c911ff07b5c397d93b0bcdf08acc70cc0a30f1b620f8bbc476a943f252f25098e08deb83a399aa860677881168b9874a27f488f9a9cb5b4ee5b9d1c23bd778b80a61d3f730f3f08547713d7c2c4a8676606224116dc2b8af6b7a392a785b3c51b76fe39d7987b41ab72de54805ad99f6f6f20d3b4f1986ec1d0667e2f9220b5ce059d9cc44e6a7e82e727f364d119df2736a9d8a8d3caa743bf36b1ebff1f5e54ae5413d9e48d31b9834013b9dfbf4f91085949514b40fd41d6588758ddb4f50f66ed67697dcd1773dbb3f8b7066942bcca471435180cc848e24f10346d7e85ba01cb9c7c466b8a80194cfd0c8a649906918cdad959dafab150773263087596cb1fb3bd10337676533409468f74ed221618e8bd53a461dcff1dbca88c7f96feb69199c5569548621bd9fd4d735de185cd472da25096e874cdea1cfbd9a254f3822c2ac552df704d0b43497aede7a1d87e595b3a94e4cd49147516865c7523df5769f3562589ef5d0b12116b434ad91ff52eff7041ec66c8cc0cf8004639396b5c8486bd4e64c8facb8390dc03b417ef409686a317bd608f74f0a9850d748b3c19ecb5d049a7feaadfed1eca3087f7d5a3747dbf02a7a206b20c6012e07e147ee6c4320054bfef821a5f8a99bdcfd8f705c0e399e16db21d67506f64796abdfde77faffb0abbcbe739861c25b8f3735d048765637f7ea7410d0a20330d61b74403fb3805542fef3cb5a2e0d4dac23618f9985dce91237c2c2be8ab9c430021040a95282dcb880609f403875b047b22067a2dedccfc45d65c37b84be7e41561f6f5ebf215d71fc9ce817f25a2507eea81fe38964057412488426e5d9a044388e4d7f30a28fbd340581242a5b37f82f85ce6c0bfdfc6387121762048eefc86ce21cffd9e1ff074f03d40d95d5b677b05c15393d7d0dd2d03cfd2aecdd733cfcdede000d37e394dc9949d7f1445708ee4a84f507f61e31d7ace17742b0e404e8bd784db0eafb1a8dc72b494fe364a050c5d080a2b9daa45cbf04cb924448b5424da11e0d0642d92fff05237afcd4a6c2b7aedc0c33052036b2d6ca11cf9c15c67f777c6df5d313af44d648d9716958d59a978cc7a1b66257791d37b7c1439213d55e58855ff3dfcab2676fabdc01bab17407b007112dd5e78bb982c24db8d55c3420dbef676e053e17922cd4bb89943be5fc7f72acf7e8bc702bbb8c81657ea3fe69cbc7c14a2de4924a4c4f5acd9473ec481d880ec8f5489f3cde06138f6d1b41d887315476dadbbef600dd80199ae2109dee2455a7b5f3d7a7ac6551c47b188c84810864b50289c3079dcefb08587e754519ad99c61e34cc712f1977cf84e2c9470f97f8e725318dfa00fc0e2b94dbc6d0eebcec76deeb1956e2051ae0576aa5fdf24ca3a4987a7404ac5acdfe9c87189d838d130cc2660b8fde2d468c9ca2aed70930b8b90b9f763ad1ddeb6cda952a7149ffba4aafcf3b678c73d73290b559d4ad8c5948de2f5229c32c4cae022f7544f422da284c0cb1b267f26c65df2d06fe410a507f6f4027d02dbde29a4b7d0ae04d9881ff680cce6909b974ae9c452cd332b7b51b93f4dfca9d6b165c6d693189725f75b6339728e34334c10f87c8d53cf0792d884881c46bfbbe8cc3baa719d80fab3dc9add422350def5312849ed7cdb546df0bc820e804b14d36b7138d83e1561f9c5b4977ef2ebd89f3affbcc740e04488da080cf665c8b69155b584b157714f48d4a34516213906efd8a952458fe862231b70a729585e631979efeb88e59843ee50335c20e838c5aced8141d39c3b8a0aa34ff22955e4dfcf6695e007e9e88a13248e63d0ddfc1e05803dcaa8caeb6cad43c9ba61d0a837bff794da73b828900aff3d9ef1a4ba01b28cac621a524b145f15e3b5aa672a0e56448799e754763675afd637de1e38b3caa9483b6d58fb87db6d18b4b92a413bf909304ed3737a26056febc4142dd36b34ac983c013b29c79be7ededf755a6c18bab99a84db0de3abdbbda0345b49e16ed4dcf075e5992152e6cfbe56f9ad05e24ead33bcb25c062d7aa5eb62f46f3dda6506a39a224f13185b1f446d7c4da6a3e432fed7c574f8ee6869a424f65f5628caf03dad42dd23ab34ed48c113c276ae18206fd284057734343935d8951d34ad32c0d74943495d781fd0250d076849aed37a84194868aea7ee4c63b57ef59f2022f25124bf8492a49825f189cbc02542c0c9300add5acce8847c93fd36bd118b49aa2fcd80644d2bcc89a6c3948b2e6939ebcdb0566fb4e94b75f6af1c0e0f184ac6e36a566f68c74a7718f035fd3225683e1b32dfae848b6f74dc69335fc4fcda991c9fe14817a529266cc65b8d6ab0f7533d6681f4194045b9786f5e6a1109f9780dffe9d30c1b39f35d4537bf5714dbff9b1aec78691d06c9fb0d1bdcbaa5a5147ebf3c4c0965f2c15c7be098f00859f1a80586b01f1883e30aafd13f47996631a309fe0ffc99e0d80b194a7bfe55cfc05e9a2fd76332979fb4f9cdc7632c522e7507ccddff099f10ce9ff86cc2d4e52833c988587432fac6bf8dedce6587ae867dd0e2cf77632ea5c00869e1285565543e301ab915fbba51a1691976a05c9d3f9aa2280fc51d7b7d8aeaadb0f504cf995b8a4fab3da26c32585872acb2ac86f441310eddd39a51a4cee1cc12f7950fe509f90b65cbf0d0e3f812af0b66f01ee52f277676b4ac736283b1238e9379fa326d7a45cb0335dbefda6272e5c08816ac5cd68e3dd258c5a670e164a4a50d13efb0dcf115a3eb093e26bea17ff6d35b73b13caf196f6d108a653bfa1318530264d2df8dc522f34ba45680aeffd869b850e943815344dd33c651e4e31105c064010b8b698925b8f204e25a7a76e41c281e9d08004a845551b2908f5a9a340af2f4b8af890a214e39657fcdab5f194c7029a7eeb3cd166c31fb7e1e5db458ef5896e7a0447387da518b0a8435a97a4e7679ef447dccc38a6a11adb42d9b8f122eb3a3d84118ffe84f36fea11f29e469998fe51ee2da336e7493f9dc7b8e4407738f2a378a4a6111c9cd8093379a75b6e3c4944a2c498af78d6f3272f9f2b447b7927222cb22d03df776545957784f48f0068fd432df8a04943fb8e2a3000152e8b03ac3e5b3562098b8b3cd0564f94147966b8f5ff503ddb90f8eb0f17cda737afb1f410efa390fa156fc56e6c77ba3006d45d15e8f58118bc0c6b89cff7ea24cccab80d5dc3a23c1f55f2137b20b52ff69795ec0e5aff1294c2dfec5fc6991c50d50b50cad4e5dd5a8412a74b7284d3cf6a070aa0e7696ebcba381b24c9443facb7afe3bf8264478b0a9590c633326ef1b2e35dde2ebf24655799f931d54a08a843fd810f6cc9223390b4402d4f8c5a59107f3038b79d536237a5af467265d150c58d005d169d985b47dee4c6707c6d1ed3ace24f949321d3fef2971be6377fa3e7ec4b92bb778186e0b2f1b0bd700989217aa44c9b258e4e329770607ee687030b44cae1b3c28eec8d172f35af8d887f1873940273d3e037dd485c3083d31e5f897bd442457e451846c8e846dac9bbc0347822c7a71245358a16c58bf92242086976969ca5b7082940bc0ce3e5c40b5ead01d6f1dc9660a842a96e8f2790a7816a43e1a878436f615c1f0e79c685b097fca118674fe7e8c6246ef8400a333e1c9ccd536dee2dcba97e020317cd435bffc6b18ea1b08471c9655cc8fc61eb9a95b7df2da97365a9e737be2d95c2ca460ed012b9a1572cdd870693062225a3ac411ce69cf2907c374251f1dc96c8f9519998e2b7687cbe938e4ec36520ea2be26b4b84095592a86eeabd2a649a528074af1e3fb1a2121268fa00bde486bc93bef2a65734113943b856ddcb0784056a2353ad75b5c072e9034f268de05503ec79f10cf72a6469b0ce69320c6083703a88ebd214f5cd090608ac579e76cefe3d1a3411e9d87ba0f6e0523a82c508e15d8d42cd1fdbb9631b263879ec942ee00da4317b909eabb0744ce61683e376dd781df770695c626ec33635fbac18027c2728425197057495058782215200ea7228fb5406cd0a03ba016e02e52510f96596325c7fc3d6a2c80128899a8a94e4a87067e8620dfb373e027bad7e5416bb3a6bf5da729df561bff2f4be763895b41de6bf093026253df6654c1df6f6e18b6b0c3df62f21313a91e132b213c8c41456c5a332bd1aed43f84fea69943ee5b4ee17f4ff85f0815ed35bab5d2bc5eee7296484fe1e82c8f92d42979bc8ed9733ab4f0e138590597fb46a4c418c1a87dd25e34b63e50bef52ef14da98d41ffa2020dfb0cc8af6f25e0a4d03019ec1b3a938439e6740e04f910d9bda38b7c5f43cbd910166b9462df77b167399859aff002ff923adceb1395127afc6e8c2dd02ff92ca6c95ac1e517d4b525c4a520487dcd72936dca310eed6d3d4c82a9984716e6e0ebd8780619c5f0b472d8d1677fd8c1787081bc9786396b01b6e45e0cdc07fc68e86e44fcf0940694b98d7e53e94d24e445faa4f786d34daaa304b1daff9d144316c7d305b8a5424449a14d0b8d727d9122594fbf0a3f2b6aabf104df2de11a984ef28eaedc9463623e4d90332fbc1b1ed0fe2ebcc322101082e1a2506eda35a2bb3faab8a085705c52b9353e0b852c653d12791bcc9951e0a8b5d5bf7618e08bef4ed1ddd2e59163a8f5491fbda7511b7abf644a2813cf70a1dc8dbf906a8c7d883c446accc12cf0dfd13af1d1635aba74101de1e16211c7510623f143cf8633b4b9d36e23857aa34fcf218221625f90f439c5cabf380257eda42eff5f0a7adc06ad0d6da1f8f6428e8ace035e3611350344ff8ab06ae4a96101287efb1112be5ed1f00f1e3e16f517eb9ccd1de4fb2216be8b4b86730b63000235541cddf691887a70ba94395328ae62bdb3377d6c97afa6ee405e211365ee0cc84fc2cdd57a1529c229b0101f7a69611a60812fd55e4a27fccd9e744dee27d06bbf81178bea195f2064246647ae81bf72684288ffd8e69f12a74ceb47e0d63cdccd866c4536bc35f54350c3f174099c558de701174361a96f494f016ebf49cc425e0271126f105823cc9b8fdde82049cf5a3d01f6bd22c861fff4439b6d492309f4adf964e99f46e4de98d51dbdf9cf01c301ff494ad8a81eeeefdcfa93835d7fbeb407743bf055a8e419aa3c333e76453d2c69a3ba6efdab26a62acb12c37b29fd5093473aa5ae10ab02e971c129e57c4523266a5bc60ab3d9be46ad834522cd94811b4d19ef6c544d14abcb4a586912ea867bba7f0d4e84abab52dfef4ed18ce8ac7c4d1b8933bfe5048ba1b3e09f04bb159b647fbe77565d56f594065e4e86c3ef47245ce2e86884ac112c6b0b8d7ea1c174b1b266ab5a66d4d8c5a05640e9be744a4771376561557339a5442ef00ed30837601aeae9ef5083976738f6a87ef51f49f65ea3684287ee1319add7c555536defba1b19f533579feb0d5e3505f9def2efd1d6ca47d4bf4af8d98e7906c6e340950eefa4b4de5b2b7f40ff3870f52e68a09ac8a8ccbb4fd70bbb4c7098d4e0b54699159ed7492ac5866f6347bde24d04f10952f9056fbeb538f46ac30878a7fa7591f7fce6078d50732660d2b891010f7a7d039179c58aec21d288fa4fd0f00fb3e179d188dc291f65ac086711eb8480cd6840ce9e959ef12e2a4951ff7c6792ce35b4bb752ea92110e614277183247813f3dd629203e671a9bca73c1a823caf7bf7cd61ae17456e2b3ea909d09dda48661ccb11ef0c95ad7e2be321ae2c6015a15dfb12814f9f38d4a09708ecc5bcade99f7d6e58fc59d214324e32afa2d7342548ed55fcbf6bdc2acc75b26ce23a5be7b715736f8fa2c7e226787c5ba8afdca6a692133642bb09fbaefad27f3a3f9a8c53d8c94c7aae4d14aed2e9c1f85989e9e51a169d68b8954e9bfbfb7cbaca224cc13a6dc0982690ed9552edee984fd973bf7b3f38b47f113bd8a7b976667d37dc7c7a8a2dbbaecd8d0ea6cb3ff975a463bfc0ca016de67536f117bec2fb43ac9acbe0fc51862268b34e77a1de8a2813f1011cf8ec87277a9f1a3756cc10a884f396f9276554e0662d70c738051cfa9944d49f437ecfe54b39080be773f35a89f498b38ea882684b94122bd3789b1126c9af93fc0abbe0c186c15ac44bfc17da692d7e3efceb1e8c9ae4e9e67833c9bbea11ca225d7bb999fbe7b9ad7ba8fbdcdd55076d3d4907ddd45a692b2a3e987648860a95a5dc13f622d43fb71bc6a640ea389a39bba80846368e35618566d6bbe6a77056a188cd3dfef410331065e4f27dab7b2d5bbfc747e4dde5d60b21c940dafc23167d9c30af636691ce9b49fa02b0e9efcd81a03f851836538c2b4fcaa17e031c6dc8750075be0f7e7e3cda21e30f55413cb787b7278e7bbefc32ace6829ec8809a25766a67bd7e8142bac7001dddc451984445ef6198edf6d241fde832509a27b74edce85435e57d8f6b6cda30883975478adb6b5129423fb48c328b711a1ab703f4825f236b5d4f7b7fcc99c6f96e45a39d3f2159595bad4a6d74927933fdb851b253c0f7b37716a308b2efe7c5bb6dba970e28d01292d46e334c44a22a50b81c506a69075adff9b94adc9bb38b6ca08df9b4f1f1209c4f50b922d65cafc4b4f4e1076d45d68ca74dd41765fa9c6b3e1c7a3131fe61c46f8f7d317fa1126e6f9805525b9161014464344fc283d7a8bba258c0931e595363efdb077d260f288a7e1949a4f0526b9a9db080ec2ab2b347c8ee69afe8ef9c90d0a78e346f1b9ae3dda84f92a7b5f4a0ffa9a22eeb2d652c5b2d209d7141fc69181d7b8b10728b04015c0351263471172ed5a4beafc4d1eb84c5aeaea36d2384bc505e5d79fd685e76246d5cbc20cb94fb9c44587c858c5a27f2cd081aafc0e76cd73e548040923e1e7e4c76a8233fac38353600bf14347c2e40b8c0127fd72d72d8227ef7e8211c1bc5d319ad19695e61d04ff21796b122200ffd99c36f7d8322fb34468914b686d147f231d7cb22dd0938abde54d5c68d3827a4d45b3539dfe36e1f4811e90de93fdbc978d2e0d239dbc68ad0b69826cf55585a7bc745e1207de7c6e4e827e174ea1aa91de1cd1e3f5277fd281a6b2cda83f37823ed9b2f1d53436a8c03df9cffc9cffded25c2a5cf987eb31328ae3892263768b3b4ac6bf156b3e5f17725abc71ee409db702dc22334df8f4c9cca8e76849c03d7a239a8126f1f9e21c6e411d54a60af2c9bfb0d574d0f29e7ef5fed2c56f9bf20d6d798c5a4638e81cf288110d55074111285f16f8768f98f5133225ee1336a6eab67d5d4ffc59444a9efd3843bf496566404df669aecddd39690c59a032f7bf8a525086384e6884887fddf8d533fbdd2468cfec56e418495b20e7e0027daf959c631c4c807e49d80208ebab8e13f63619a2167552363405d2af42789051781529af7304baa786c4b64b393b7e1ea0fc05b1a46ed1f7b6071c6076dee2f9a143aeb0cb9958839c2274249ee8d37bf10bdbfef98437fb1e6e02ee34e196d15f93e263ae6c693840aecc39f776f823661892368b033c38f9ebc8114458990ac2126f9d7745f8aa7ae21bc8de0a7b7eeda16966b6a5817f042322973c612964fb016202cf871e025ab121a9f71a6ccaa9c72b39f540dd502a69bab2ae5e9c99e7c45e22d1404d8633631c9733b412995dcaccb421566c96a75d623cc5f88bde17b44267f59eb7ab0510e694940fa0c610e6ccbe01511ba480735862b06df99e9bc94a524683155f1be217a09250b36e2924107f99f7d972a17aabe036e5925de08af61b79255649d7bd6d9b5e894464c50c58177585c05168ed2d0c5d77ae42f3a6b82d4ce6a0200f001799e68347aab8b4d84379ab695bda5fccb7f5da88067f7f7fcb6579ffd31a96befa952c63353012bfc62fbf1acbb6c047b1a374494cc202d7158dbb3ec4a6a76d5b1ecb41854f3a22dca1e7369f0fe1ed163aafbc244224e71ba3ce8fecc5a0ee20a0f354e38b5b62c87b9680e3c20fcf02396ceeaa555d85565f628273d867224b91f95ec62834aa69bf07ff1f07e83806f078e7c4a0842c50e3ff8d91f468e3acd0653b2c97bef093d322db11b01e2d4ed4346b624f2a2eee54d4b82a982b90139961c6be8ce902cd0c710f0e2d46a7aad70460f8c027e5669747049b618d0e3ea7374b679323ebfa807d9c41d377250a783fd67be18b1dadc9c7014950a855b43755262a92510279255db2e7e1d08d202192bdcc20594971848dacb77996d1b7abcb498631ddb4f31d0b4b1cc2ce1182ba8cc861847412f6112262cdc307d78bb0f53b90af3fa4016c24bbd2de936896ef4d48ef0a3b8172e73c19f236775a143758e174b5931e074f7059eb2b7a2f7349c379197a5bcd66f2fa7e47bf814a4abcb8512033731cf4ecbf4dcf96ef5238487b4517417dd33f58361c961ef84d918411918b61bfc7498366c9dbb76c0a8c20ff2eac5295a8bf57429aac4be1defb24607ec8284d5f1d8fcf71ba655185e0ab80f4a0ef13fc6da111a94071580271f259ed7b992c88800e9d46b63dec9fb38ef5c4dca79bd00f5c6ddf55b83db5f5da694caa3cf5528cc1ad03d24412a84786aa6f268e64579cbad9d2395d7b0758053addba0c18482f13c9e55341a314e87e9bd3a1f8608ee472d4f1f428c75da3bcf8755e7be6c8d966ece0c5a396ef8f16cb87a9c67664c010c35bb099c12c3888ff8440d449552834207f7ff75271f3ac74717ae690516d9bee794aaf30228d373e3396234967ca8009c9472368246a21aca9944364a78a2a79fb2cb020d865631db181ede91731ecb59b2ea635b4e18772e27f51ad593c454b681f637843af18a80492977a7f446eaa8602b91eac5846edf29dff8f38c995a26d0f344b9971eab61c2a3b573561a96be972bf9d6fc103a22fdb3d5806f5bc087df2fcc9887733074c36441298ac99779bdbd51d6d0f475dfac9da416074ce72dc16d47502b91f8c9c463a95e7c428cd4e4263eb882e6b3914839752723b78141c761743ed0176799318804b8d8558c4a6944cc9116b37d9191dd2619cb30e04c5b5ee6904d21e7ef83dc3582559e0195f3d34b1ba7176693a55fc0caa97a0a9fa7c845dbaeef5f40307bd2ec886ee9c38a745da2d8bf797bcf617556da8c75edd404ff7d1aaaef3f1aa7771aee7247654b65c8865301f1b5f2f0710100f46c02919653d5efa672b00e111428517f599a40048617cb013168467e7d637c0ab7c115caf49ee44bc49bc7970186b19daa6acc00cc4a53660f266cfa3ad8f0a3ba0863d6063e205580709fe6df5362a395af9fb90bba8898651359a6003bc4c1679c16a40e30fee6dc3e4c104fff48eda29a343ff8cae3810d659a90b03b96698aa8a149ebe4acb9508d7ada2c9f2163853cac79f66133fc54764cc16ce7659a1700b29d154","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c18045da2868ebf6d581bd4c299b8f29"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
