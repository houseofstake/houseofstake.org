<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df9925d83305d15fd8e64f738eea618f84da8e96fea890717308a2e036c6c00c9d075bc67ad67cf73c1abce7fca7adac4dc30eed248a84f2cdda2739799a64d3f4c3506c6bb4f869ff5233da1d1ec8f35d3ccae0a960908698673274a5a14d0d29e6256a1b51839bffe060b7fbd0c2956aed82c27edace69ddcd08f2c6c71f0599a2c2090654f2cfd3d6a16686ceed13935eca016f05323be725e43109aa902aa5d2331b2f0d03ac919ab01f46c6d0ccadcd8f257963cdfcfc49da6737d86bd7ced56f04d16183789e17de1a5ab37ac69459b5e29b6cf86423ca69689b1647e55068e16c54db54c5ffdae82dece5458fa77aec685a337a2ced8cb05da3ff2adc7607f6c1f3dd68be014bd70c49ad9adbf337210ab0a6461828cd4696ebe8ae788ede99e9e30fe0f651d4de16d67b93988b93b4c89f4f566df9dbb8d70f3a5c08310a86ffdaaaea4a4cb308fbd69abb92c74519e32ae8242d5307ec8770cbcf763db61c9d91163eb34b60ebe86e0093ba5520d279cf40e3fe4d969074e04f3c04f38dcfc324a872eb0df2883abf4a76a30282c7b28c92b114d9e30363c8b88a3c89268ba8717a75eb763149fa967ba883717e47ade397e9817e731a86b31bbd85fe04db289b10887897760b92972f391f2284661b7d538d52b4d0b110ef2ac55fa98f1b7f70b92358e4bdb3f0d56257efcc8eeed8162e5dafa2d53f664da98cb6769e2d77bdeef440b68678ee5bac81ead51efca256b8449267aaf708299194c0b9f7501ce34abecca4ad2875c819ad33e9d2b0a8697cd91c1aba2dce7a16dbad3ae72b5cbd688151e93a2761169e09840ad61aecee2a25d055815d98c090f374af5c147698d6c4863e1a1eb937aa1dce907f816a41324c0348a7f864eb6109fd0ba97043ae902dfd302de62a836ca274f2528085871586a5d82a630eecd69f189149e56ca78f1961691e0677dfc91d67e0ee2fb40448bcdbc8d53dc0f7a27580655ed5d7700e88762df813d8fb341593b20578a52f8561f9c6748153264433cbf0c831768338d355cfe0c6b9f4b12e703cc8bc478c365d30e630b8dfe75eedce3f785665888c9d24e0ba7e1db9c01963eb9c39cdbcfafaf83b59e6e5f4c57e332f75f63407c869b31be26565401b062716874b685236abe83c99dfe8972156f1405a31cf4963c3b078755846ebde41ae1d6a5648d3ae514676fd6fc754813e5884b0f24130968f7d8f0b98f5aebb3b1d03c7470b1aa4d0d2add176cf0fe9e2e02f49c6f82fb3c13dc8dd3822f2dbe59bb490880da25a5bc00fc0172227cdade525652d0508ee0514fdbda8a816805a8f26cb91d3ed9e59afd75eb5c4a14ff18293cb75f85b4f40259e9557da218a920ce8f4c8042024ad7f7a1268b2d067971802e11326e8c10cb9d88983fb34e54ac7a21e9ad125fceb520506302be51c51088e258d00d77762219e0011e2842b992cc4c71ebdcf9d0ed820170075538077a52d1064e290224145f7947cf438176224333663c860207f4bdf01d4d93d86e3272d26e785b68e0f79e39e24da7048350e78a6b15aeac7919a885050aa2a7a5354df8eb9b09d02f3dea075447e3c853394cfe05ccf12be4f69f4a9704def125635d4cb9accbe6ef4acd0a56f61c5eb69e930ebbee04600922012f42ab130e3219cb09ed739c1eaceef4de07e586d05c599a526c7dc6c5dd703790f8196aaf30402e93020c39a78db82536665c60b1bb9949a44f6131121680584e0a44dbe85343817bad69272016c5267c37ac189b4896c24122064451a30b86599224366430138a088f6e3e63b937cbeb674d55179c98210376774edd1f6459f7d80c40d1ffc3edb11011e06de0e507268885e1485357290515b481d254a3340ceb014ef06e8496bb2601b9c086f1ef1c611377ae05ca75a420bc7c649cafa171ca32406ea3e1fe2b98e50aa97775fdaaaec7f3c8620b84d87fc2c56edcd30203ddc3ddc7ec916f02c010592b40bedebc84bec4f7c434cc537887855abe36328f7fae59e898e531bcf93e749a6d285012fb47c3248e8c0b7a12bfca33ab5a69e28dc6eee20369060a22b75672bfc747634ad65d16d90da10ce75b8b148bf55fe09ba36ea6684e80126926cdfa39b083d0609855773846699167e1ce266ae25f49d0177bf99cd191a5b3d110b0be56ec5d52e529b01b4d2d55bed800f248409948a8e9862e0351d76b5392a07816baeda4abb6d034583036bc378d49cc4b8634f56c89274082f0b1d35eef7e946961909afc447d472f6da26a85f27721759b223cd895e089013be108c450c92e66ad639d4543c1f9fd5e9983dbdd78fba5f2c0094e33f515b1c9daf40fddcf8ae7a7d972970cfd827c87f502f9fa7f84cb09f62af4004a5943700638992430a8b27ed6b0ef7817becfe8b98e65fd6ed92ce07837b1c4eb36d34980131859ca03d28ea2fc336d8549f345cb7d9cd2c39178e09c88ef3bb985c2567726c4dfefd2675351afcb4278153f83eea78648748e0c0cd3e93baaff07e51b311b0f9a98ed5d2603cf1efc5bd8e9d06698376065e0f667da236c996c600a4a17e10779b3c8d43ef71d5462e24940f7147f3a14dbd38d711d8ee74c88d6121bd1fc4ab58c34c848e58f401c0b922dfe7767fc369158e4de7e787f4b3c10c0b1b7e1dcd420ed27f33c92c00fd1b28c6c8ad290e0e4de076b493a70ab8bd8ad273db7d17c75b76867c269c3b118ba9ebad1f4d0256d174428a152fa8043b62e03bcfe0a95e54ee5639ea944d22b9473104b42662df34c3d353dfe70e6f0631306eb3f82887bf4ed5c5a0c3bdcd6f2c8e79764e3b8a3e2ada73af2cdcefa210ab3aee87d4765298033eb3ddad5d706835bd0bf03d16897f42d6a9ad1617cd9caa3967b33a8a863bb916d1efe9643a2906845312970b3598eac2b884b415a97e6422637c28f234dce11adb32dea525c26a3185ea5ac2c3f7eab2150c345bf4a1a6a19d7e084f13005393eb92b69eeead69e6b35cc223353741a7f4b7de0be4a1f5e87d15d1372a2edeb8dc442553b7e4721ea7c7b37883edf03c9b0e4f7439fca8a3294fdeaa88c4c7ce2ad21a8971877760c1ef54bcbf2a5ace0fc825eb1256475387f63c88063074da0086b60faf587a8a33e6fac66cc35e4c96f15d71f884d18e69da5030ccdff7555b9dc663aa2af15dc5de00eefe5c1a87d57b8fb3efd609e0f0d7974a6f031820ec551548d89f75fada1f36ef7f2555eaf00033683cd18ceb7a86ab4a6d268adeb32b0a73a2747178379ed8183b7564e6a0b730388614bb3beccb79256d6dc2b5f81821acf27d8f247d0ff3c2fa909988c7d7307a7cf1f1bad6a5aa766702ada2c20355fa467258964b3a340230b6651a43ba3f802b2f850f789db68f105812ab66be0be0830453b1e945a059e8086dd37ae9598b58b39f2532b0ec2bcbabc485b81990fd804c6d3c44d652505a8dba66844a0c8304dfec2e38ec2d9f5600b0672e6154dacf80f58621f240e7a81d316f6969072504e1b2c447c01e948f5ecec5074a13767c95170d49e753209d575f8d78e8259e71ee55d29551c1fba4f244b1a2075159a87d5673291331c0ddc207c0390fd5a84e93711970327e250d9b7f827a983e68a6a737c335ce98b2e4ea619c75b4b7561fc0975860e6185152645dbb7785290db661b230121d41a678332f2ac758e1786d60d26cce21c973d5289063932331fcf8bd99d46123a35336f1dfa132703df0559f8370cb1dbeaf26db017732c73a584ff5a1f003a46ddb6f906bb94357fe715d9294a144eec772d62901536940f271cee71effe97535e04d21f17afa54166003a268096f46538ed663a5f82ad75f69a634ce169ed467ef47169ece3d77bb73da54624192d464edd8967ddb4e877a2b03b634d483900e88038f74f4e5127c7be2405a2deb9b5e4f24f8b3bbfe7ab02a2cd88b02ce7dcb8d25251faf5da1020f3d2281c22d06e0bfef95a68fa5b0cb81c4c51cc8b8751b8b6523d18d3f5cf4aa55616b4b2984d34281a86e5eaabc6a4c9ac004f63692f23a0d96284aafc937056e5b28a550d80b5fafc354fc634c31b35445456b0905aadfbe6087c1b5ea2e71e6c63a37937c1e45f2555279e9f92d127669fb16ffa6ceaa967a01898e1f167949aa18b8b33ed893a6e0ae6ef38587133285d67f70048c3caf0bc3e05415f450d6025d812e05d01f4f3c341b9adbd4fbebab4cc5c0e14d4852f756be2bb00c2fae0bc49e0c7dadcc55cdf1734b8c73394f0d6c3b78f6c5734e6d5f9c4b235e7afa6264b2eb5e1d5990533d90700adda6797cf6f77cc1d00ec7735c54520c4ee57cef3bbbc1a2f3835dae3cd66fb8c2d333a4f3dbc2803f68eaede042eb0b06bc871398d0750688314eb1058840096af69c8884c4a0b7770f85b4d22a3eb1ccb8296a45bbcbdfa0ff6ad7e751a2a52d2afb36907bc6fe15dca5f3d18e6cc3c60310acf612859875e45c1f251709741f87deeaf6f1836a3136ab46d1c7a78057cfad0299078fe74c36c2689b7bc07bcb1d38751392177c33b535b0f982b7875450347941e48be619adde4d96cbc2223658c3f08266109f9947427972c4cbd3d1b30800a13407068b540b5fccc3e1f69f35384fe8a0e486f1b492935f8b45b999e43e6811c4d9c3e01344be3a4a05c8929a85377aa1392e62dbffcc098531140bd086d333bd2d5beb734cb6c4b6bcb0c900e959d9b6722e767c63f3334393f4c41d094f8e134b02196267d887f23c36969992d306b50eca765bb04b2c72a4bac98fee0da916553db214facf205dad3c23e57ccefa7243e5dbd7686ac7be416f352c87f2a46412a709e7498ef878efc996ea572b87453a0a7e74ba43e68a7db357db30ad1a8cc1c50039c989e26ba644af9f9ac505e2a0e466a3b891d88cc81981c48d9e17ac6b1dfed47b60b1268af4bd7203d2ccf3171586dfd79b84867f8f2f9c90b87abd4df263a593eaa58ee6ff06a87b9404d3480e0168a65bad50a0a537d7cc5a5bedda4cc89e7d12cb38b629819b8fbea3dea1cc874e365d27fc915fad00e01d52e569a192df4e988e53ce449619c9ee1e4c0d3f8f7bb15e9d86d42269e97aee86ca5a77d27c0040ee2e9a88dbd6555d0db8363c262411dd03d708dbd1ec7f53cc824a143184a21336d77aaefd2ce77729a128d12f698c1cb4d5930ead108df76a5329ed0e21dd73f184ac2b510192ab15d7a17a15107fc2acabe617d3f8488a1aa2c5dc09d55510a04f4a0364a45c786127da91078f0f24786c108e19549dba69ec9a0664db2e8decf51100349bccbee2fd84787ca1658ba24e377e83181b845a62131995a27361a650a0daf55b7cd01826726de9ebd590cab22afa9be16963c0fb645339917442c172b9662e98596ffa4db9b3ef95b91934b3fffac4de2cbaef5fd5634151aaffebbec138a58ee79bc6a84a9146662f29112efd43bbc76a7451e0f4398b9d2303c471efb493aaaafb0353b6441736e0ac7e3b990f4fc16800a7920175d4a81739f7a1878bebc5630ffc7ea55073ccc8874dd6d7b4654ded52d5865124b648288dc643b42576eaac76e123340dd5bc05c1ce2af0d9639369285f7402740ecfbf1eef4df46e385e9c089fd0c2f0875101b66f19285ff871849b90fae051da7dee89a244649410f39bc5f9b66b1362bbf82e6beabc4debfd53334df519b59485ff3109015153f857e867f89d775b053dbfcdd8ee056bd9d5d7e250f32a4966a7d77d3bfe229f40bd4ee7e751560b786a504863479079b5d6267f82b844af1825a919fc97cb5b6f18c848a3bb21c9c946066b103caba6e2fd9bb8050ca4c277fc18b89a99d86ebb8907aef217ffd548a0bbf2d0fe2046ae59b4c49578744090b1f2a2ac5d7c4acb8bfa51d228e76efa4f5487bfb22ba71c2e453379e4fee21d72c3cb63d4f86ecbb140f18ea008b5f9c7aaf405a938e2032dc56abdb75e96dddfba35b66e0f77f5557657a91e7ea3d68a24c4fb24e3bcfb40636a5c983b2a54c53d8a37a3960ea678497631a7e1ed93a844f0dd0819bc9df28ee68f92b2b1ff66996e1a300c213102e4fcfcafc8d9b3bc64f9efe76edb99b74bbe5451bd77152e6e1d3f7c47771c2f7e091277f70fb9ed7eb02eeebc340962854b7ebfb4e33565e1842da70f26ddfc6d2f9be40c260ccff82456280fd1dc1e20bef007ffe654343854acc1b1d76d77a703895549c016f4ae2dcaaad4901d5014816c4ca361dfbbc05b279ab34db3b30b34de4b5b0033de3f842b2961ac74b2ff753a2b49b0973d76045751bad0ace6198274a46b583cb66bf289e041cff9f20878fdc1c9ce17e7fbc7d8b8b02a2c2f56babfc88706cf2a5b47c3772c7670f2973dfa5df7b6dd8d7eb067b23c971f53fad8169d42400d83741ad995f057709920c1f2ee4e61a60319d713a6beb19fb8cc8c289f75275cea9d38b29b98da193c4dcf7697c0d8c4562df547f44de4e7637f6230dbdb81ce42187af2f7303ece5c89093f97637c187f90921a7f67448312a39588b1c4f50246cd9cfb02255ac09cef96e79d9318fa9b0636350c27ccc75a3bbff870cbb832d823df4544cc81001971fbd4abeb01aa509a37514b48e3e14ff60615fdf682467bede83a75bf8f1706854b07802d3d664de7ee4a962f87f7a912cf593143a9ef98d1ad2840d1a75a8a4a189c74df25edf66b877813fc021c00bad993d306de9b3df8ab92d7b72700688c5fd5d8adf00c8400ddc1d1ff2c6ca08240a22d4de6451f0a5841885b09336120c23da7ef5bc6a682e9c5f32b08835eb25557457836796815f9b25bf24a0ce12ed26ce75e8aec4791ccb2b5482e75ab2741872ccbe02566b3ce08d9095d1f47dc80ebdcfedf32c2f9678fd44044054d1df2dd3e3a4d25d8be2ecd7d2be5a37bcfe17f70d7914a852fef3ae716f7ca2aae9446113c93b7eed373ea4c51eba491b56fbbdfd82a7064dafa2021cc2034767f0e04d824fe9e34ce1ccfe93351314256e0db4571b872f72f8ea37c66fce1894fe9be0c9f123ddae8204b077882f59123778ac9c98f8f6eb3ec1d409e5cf3d3c6f4f2cf39a1089a82aae92a0e57e7b9a9263f1c3e09bd8dfea92839394103c163ec5eb3b92e3ba0e5745a5a5340bec6ae47382ab8fa9e87d4fdddcf646d55492dcc8c55f1ffa28dd6fd6343f3c9a27232c2ce5c29469b6f01aee0827315fbc71bee2660ce9b3ff7b501f8ff745a2d99e5ff74b5908d9446ccad979789ca1896cb5b6b9571f607e528861e6583f954fb1624a300e884c8a9bbf91427ae7fea0538b10ad374770cb844637c066293b006bda446e4baedbdf6c70a98bb3789db7d4e8f5a28552ef96eb1a0c3a99eddcac299296724db85cde945e7d02ae9f89a629cb37add9dbc3deaf945c3725ceba081b0827d31355382ba041e5f978ab350d3b327e211f95a8bf31677e7bb0a2e586fc588bae533e56178703d979bb23fd15465947eabfb81eb016cee2954cb83dc7d14cddde7351ba434f6b19843b45aa761ae1e29e85d5eea8c556fe9345e8de3515a4117f83fbdf22d71b1d493b6682c7a029de3b198d6977522a029981d87967d8dda5438c7c1ad629cbf56975c9955b49b1d2b819f3b32433d59db4f56322904bc9668786e00f7ea2194e178182716759ab7b662025f9a29c27a7f1f6e80afa174c61774db3358d4219f085ae0baf373d859639fedf967885b9711e7ff127cb8de02adccd2a8564f9e2ae09b777b6d0d9e1c363a1635a38116974b1b1553162aa900fcb83a9025f210fc54b00ca8bb2751db4c19f0cf1a4dd4e62d4c398e82b6133c572da2be5948ef764075150918d64469a75d71e0e294577b915f1f6ecc1720bd7e313c160282732ea5db397182fee00917fc69cb89c0a8d6f93449b309647cfbe2ce3f7c15ba6dd03147748837c11aa179b0db5f400103c3becb5415b58e6f57d833afecce8bf7c31e819707e7e7697d73208d35d192d5d769376d0c05ca9c70e2ae44e620cb9fe9f33b5bf026fbe3a03409533c288623a81be84d3aff9ceb7b86c8fb243a2c017dd28a7e54f8ea30e83efca9b6712893c6217d42a7d77a6800ed0885216cd7304fa8bfba20a60eabadd109c712006f2c1fdd5e9b191990b819cc313fd8cbf7a2460bdf6537d9a535612716aa2f4918b7e089558463f9227fa9d4f77305de99516b7946efe80f8658ffb12736e4cc4b025a4238be1dc0d84ca212631d1e239acb8627295c4735b0d067f0370af03dc75bae2df41d3871c072fa41fbd83c36c12be42b6ed4cc0e327e4d3b2ca7ff8113482b4ab494df9efb1f095e2945632a50e201a92045207b2b6f83a686595b514f94fd354125e6bbbf904680bdbc20fa30d77815796ced28cd41875463961b3c0950d33f987bcf474f6395968a8c4a08c4a8604b34938770a8b520e431459550ad39ecb5eb3fd1746ecffd24e384ab95b115652baacc561133b82517a9a7eb018c768c15d3dc99aaa038a5b6e906b4b3d0b21a2a06ee6fd5f6bb4c88b5cdbd96be6565e4f5cc6bfef27bce0bad7724cecd2ea602c593d38c353269ccc784509e7a3c1d8277a06c5cfaa889f80f492ceebbd5a8045b6ef9d44e8d8f741365b184e967597f13153f34a84c3401ea130a0c92090b559471f90b70663d71f9da8193504873e8625395ec66e3911078b922903b25d5b008ec1ab49556225f45ae8c912a0d2a68500d48adbd637fc66619ff56ff483fab2314af6c4e2717303e1de51da8e61345c4541bd59755b33bc3a94dc653fc31dcab408660f19a5812e7825254c0a49e96fb73eb6b98d7c3b6b5426b1dac9b9c3e99a31a76cb23740fbfd272aca0e7d3d69ea20b12f57d1453269b451917b711a0b73bb88dc792aa7c85869b392cb0549cc9a66ad5a956740f1c99ae973ba240f39e6c020862a3ec09e2208a1d49bc9a094116be925ca661684f59accb090a80e631e5e19c6f24c1eb0a892d3e98267c27f325f227e237f25e349e9f4fce40525e1273e21c30beba3d279d9afb9c54148c5b5bc382a01f8c84a70e57b1890ba857990b92c55333012c48df1983ac9ce5e07bc62a2ab3205d831a578edbb6eed3de7fd61a78b5992787f7502afa34588523b27bae246b42eb42206acbb0c12bb9e75978a136cc868e002c3d0b04fd8fb2761d235db28c2cd6e1fe9285166e0793ee3d120dd82a2fa8326637c3986aa4edff5990bc4b1b9a89beffc67f5160e65303a9169ff7ea27bbbb6f47f413ed5068133cfed326a85506943888dccd93bd1f70267943d9ea1f0e0341bb8b0a123781e955411532dd5ca062dd071a2d5304b14d0b306634bfe7db38bc54a35064b9f7ffa01fc1a4628b9820cc307172c12965d8aaa7f0c916e107dffaa052fa9b27eedf64214534498f9e513cb7d3e05b5cb4f694eaa14578e3c61c9e79a529656dbeaf5502af3366070927041dab92bada94f2d3e639bd04bfbc5f53ba2e41222ebb97d2003f8179a3986fbb8a0f55ecefeb8c01ed78539c3b9ad9d303d4ffa0fe406b5ee32cbc9c7a5856b2bae7719084f3315227900f0675286194a31c13a6c7a058541148bab5f51c3bc693b2144816a76317efedbc0ace224724afeed8cb7ad69ebaef356627207d969979d545d463864496468e8b4ef0dfec0d1d1cd22f4e7464e606cac473e02123721f89692cd720accfc8df9f6e700c3a55e69b7b1e047ba5fbdd48abb9f54914b709b0661131d3401d23d2fe5309645f1fbd18b54503c66e0e19171d7ce0529c121076d5fd4125a156c3c47b847d87989f238265179775b79e299d59c3e35b6f0316916a17ea6e4e91967d540c77ab10bdfe6b08b0865e6d14b601281e8a4ceb9d7962f543bff65b269e99a70d91d7604c7c132298c9d5ee3ceeb8a2d9a9b063486352cc98b89d230328ce7f407cc6b0aea1ed6e1b5d72e593b36eaac77e03f71ad486a2b2272d2ef785920806b37230317406403d87f1ced0d0f36034e9e70b8151b1db82c22ce34d84957f850ec22f1d8de6ce39a3fe34248749d07a384a133b1a9e338fc774976fd68957472ba49992dd350ecf7f0c55dbedccd60bbbb039d55f21632b862619ede7e4843ad93b2c12247d5aec0b5ac2e243a2df74a7a5e5794639852baef4a63ba8741955170be4962ed3319c70b31e5d9d7c0bcf0f94e867320da592a5d3bda270acea3896c0d562ca2e504a93d71f8213bad0da35cc233c67bce85ea9aee450031dcd7fc105bce135dea045bd497828f404fdc60fdc32e134234329ffa36755676b310d493d9c6ec15131d7eb57d6fab65a5ff82042332873dcdeaf771750683dc145909d22088ffd462c9e17c75bfe0f5ae4b37a472d342983e163ff261edb60f8f10c53ca3a13c7da68aefa9afef5a28736319617078cf007a0d151f0b053420a663f5473334cb0403774f76224b2a0ec24acbf1b68a73532f05c909921d4ceab69f77e70572ece58882e27e3cca1fc0bb46e3e3b3456ec60931d0a124d997e5fa6702a48a04a446abcb28bc4509963cb13257f9b925e77054d757c2c3dd41fd58d50313d917ae6b5f6cd81968e4a73ec5c27cb014edb791e2ed66777d98dddd61c2790d61b756ee5c76a6b628079465cc06f1153cb5ad339edf6abf7385d8089878439984bf4b8f322640c3c9b4a5f05eccfdd9ce0830a8b517f447099e3f380aafa4b8ddb3740969640374fc6fca99e3b8c3054324b864c0b2e8db058a4eff68dcebd63ace884879a5946fa516d9e989142c320d417588ee83c239f764fb81ab82f6c26d5f42ade37767f4ba363f04bf3c98d7d9512285eae946ac90225b5a48e51fe1e9dcf2050f1369d3b9def65874fed49157740e65636de67c4e1de941d69b7a08d075821b8f6147e9405cbc5c8471b6de3a1e1181c902e1cf06e0c4b3fb017293b2cb4755c8fe655f6e8b03f69c229b5069cae719b0037b95a86d86742a3d174624134ce7605a2ee8684e5ff54966365966117e69b3702f6d981b72072aeb91d003a6fe9ac577bb0eb93378347a82fb248b5cc9d173d98873fc56bb9e6af06e7f7ef0bafb7fd540ad451cbbb38ed259919332bb01738af86a8a589e6ea2428be7f7524e1c3e7797432bde1aa6236403b45318e57fee0a92305d005cfcc762fec38d48e9c2917cf0b84021910ec3e114e13afdbae5725da93c2a7ac646eec0213df19008510ed300132b8a2e394dc760592b445790bec5aa318286ffdcf69a9a0292f3e0c202ad2190a8f092c5c71e0d15f6f90317ecfbed4419dce7868521e21c30741fb45d4049dfb12b27a7f5cd9f23c83287be0f0f7c08ba9be9468b2f407a557cddb717c03f9b8bb8e7ac18c9e4d192e01f781bcf2c18a05f361fba4e3fbab1726c4a39b3fbe133a996bdd4a35382e78bf9d611831b9eb67f4377ca9f5c243f21c00e7bddda3b012cf3ad6d85fc3323bf0b5b89e3380d28942aa304abf3bf56819ec9c9db0b9a667179081035689e9a9aa831bf747a284fbe25cdf669a2bb5bad6c099a0dce7e9487d554a2f8d89002c362a7fe81c3cebe9a1df3780a0b0ea74428d2abd222eb06b9b1ecd9286dc5570bf14d2fa2be6eb5b2b540575f0cbca941fe709f1fc5a50ecc1ea196b68be524193d4717c152dbff1d01595a260a094ccb4366d1465ca6ea7462e0d5cf082803c814e7286c6fa6ec50e98a3829024d64eb8d965ff05eaef4bb9b19e11bc15e7e91dcfa6f59db2943a8fca960dd835b2f2eb11db3bc78a10738be42dab0d6b6f3078477bcd8af68997ed7600dcf17b66d8d949ead4d0d320b3805857c54d1173641c181321cfb59ffafeecac3f19187b34d1432a304458cffd6024efedcc6505a7e076b5a8974a6f4e61ae816162802c1d0bc2bcea427932b98d01d18f2277694af382bd29165d06fb427c1e1e27718692ab9fb950bf80d8f540038abdc4204703ca61904d04870ee04babbc11cdf0de1031c141c99a2821445d3da0c5300cdc7c71ceaba66fb858bca23ab8e0fc344d9bddee56b1263349d840cbf5c125d07707a7efce5811e1886866a38989329ff32b97d46c7727e076e220d7a1c23c9860a6637240cb347309323331a02cbbada5dea6bb035a10c2ecfd8632ab2fc141453e5edb922fb12fe8d01bcf8fbc6d3b4824598d368db184ae1b0dfecde32926b2fb919e2eb016ed9a97972754b1780a5ebac6f8a8f5d69addf3d7c27900fab0cdbd24cdf549441f8f1cca6445afc4ab644645ce9bb0f6b821620c4a89ab4303da593286a7e0d87ea010b19420e7c8b49c3ae899fee8315d305031efec36644f181b3093545d37232edb69918a90a48b09ae11e1cee1600d2d47bc99895de20da763ca95329e07dddb2f9c84367be8a19230246a8b62c640249b4edccc05c545014d4a2469e40eaaa4bdeac9bca0269267b418ea4c52f6e37e05020a8d8b8ecf3afcc3f04267eeeec1fc1c522dfa2d5cb3083e0daae24b31f0762b9712e916b29ba8bf70edf150252a5e3772bfd7f88622949a4eaba4f7fb8a94a296808d2b7771cc2ae0448f82ffbb33474ae49f66f379d6c4c25f377a51517880891370277102fe673b27451d342de7357f6adb0aa85c3e622a6540b2e5549194ba699c6ab58acf49eca5a937b93576523b3860396442cb139f9aeec4137d02442cf12b9952666cbe25f56f4ecfe22b70e694dc548b9bdfa00310a6652c1089925e88220006f662030ff63d767402a039c6a16f89f0cc7d97d81fa5931ad2f795a82b72a640ab0ee1a699d820680e3ff75d6477455b0229422d69e0d69ce4b51396c6d5f18f373ecbb0c655e5a02498c2cfff5882e645387f183f8e8f5a6d8f42f57f3e6a63f1bc40445bdf0b1639d404317a2deef7aa207e9a5d52a44cf69672dd09c48a6b85d2c32a3db1c0e94ed188301fd277a4e2e98158bd63cb68d016f46c14ddc977230e1582f821eda72108041cef035cf273b8f2a46d8d2cf7b1261f65ae092c355353734f5b556771018741f1a947018d8b3836cda80d70aabeaaed6091a4ffec57b927fb9301659b48223f7fe672693c8fa62af5f750ea45db8262d6644019eff067d07163ec764c18fc8d50a085cfe307a7d1fe215a9d9a1bdf7fda862cef878e5b19a54070668c89370a3d5cfafb772464d0cf1c773cca7588afd08ba0d0230c33e5aec658dc58aa8adc471afe384b4811973be60f886b03d66fccb93f1931f12f5f0a7ca97f8d1f9069dbaaaa397dd374fc446129d7b6f133f5e6da2fac0c7b2e2ac2b9450ab5d378a7cfa2de935f3a3f266586c40d24c8ec6bbe807fe5cf2b59b50adbe8e969212f590fc8266edec35d7bd99cfd4907c9ec7352e2fc019aa655b17f5ce384cbc7d8593ca46be54a3f2e0231ea373b15dbda60e51dd09ea87daf9a39468b83bb6f223860cb845d02794e464686df85b100360faf175e7abddd574c58eca6b110565d5f279551ff0ec0319faa943bfd79469baaa3090f3244f9551c4e4e453807dce7a873709f0a2b8235a95cde79bbdc1a90be15f1d14eb5c77a3a92e0134338cb832e4be4eb70f19afa5db9ee2535b24d541b57d4f86e6874d0ed4a466f748fed94d6a7cf1a62012339dc21ec2fedb4c51a6bff5bad7b0ddcaba63f62e3adcdca5508d08610c1afaaae0164ddfdad6432e94b1142ff9f4704cb8ddcffffcb7424fce23ee2dabd37923b948ca982340c1e24e239452084e98225e747f212f8936de48093cae12c7cb2ea92364de44dadc3f5c1419ab5ceb908657db895c2e34eb871683493a9b363a44dbdf2a15b0e2b25aaca48f68e24874102cb3836bf5960c31f626f4f690550777040758fef11dca67215d97268ad9795b0b11abcd5e264b689880eb115d5e20ee78c94842714745bbb2b40cfa27a34be89d40eea222604c4a3f7355202d2146143bce70fff76c9ad233cdb503a8fed478f2f09364ee539da82a56e11650415b88f7c345fda9dea2481c5b0969569b8e61923e9da583c28e01814d6ff3453778b2f43fac2f529c2169602175451794accdfb20e22b9c547af419f6102f675b8ee108c725149ba346a73eb40c8408e0feb9dee72901155cdf2d9e96fa8ddddcbf4954ca2460f9238cf9bc30f4b5862c7d57b3c80995c851a4a497c3ac9030900b78e9b7b9d7c93437824acef02627094dc5eda1b2f1d6fec92e4a0f998c751cd5d0d7dd27dad68f5b55f3543ff3c803cdb7229750ed48284904a37087dfc8ccb3291383186f29090b1fc5d60cc880b78dc9a0785c27e21de90a9cf94c972f67f5161cf655a3974702ae7fa294d33ba27fd9af5c4bce2e30d3e3926ac11f3b936054065c7c2b028ce41032f3ccc77c87216063ca35b13f3ebc6738c42f37f80fef468536f1ebfb23d62fd5bf9b23ba58aea5ee23fa1c32f92dbece049fa5c6434284cfa7f118738ff5ed55e352450f4ef4504f7dbcd1b2ed05cce22a2ee6b0a4c17b772a4d435e63faf492e6da2fc0520077a966d1696c429a9d0e3700850a4890632a8501de73a6c72bc4059efa9cbca10ae896a9adef859b7d2382a88e8c80986b10a93171a29c7ab549e7cecbb08959f593a5e6f6577ccbfa9e9b026fb8ebb65b93d887205cd5debe4bf2847aaebf5f17e45510ad06566bb8a9a7416cefcdda1e700409314fa887f3d29b8b04a217cae4816fc86cae1ce3fa1c94ac2bd62d6edec7d8da69665ae1a591e9523e028232d6a84e13f1add1e4e9c0eb8cdd3a9e288e1c1163d36dc98d13de6f0c4be3f32bcf399265ff42c0f6d493d838799ba5527be29c477f22fba2760893f11a001068979dde5b8c4ed037c19b6c478b67ebf9820f5c5224b261512d85dfbce50020e16af76d58d333c8abc92e214f18c3dab6de160bfa80d5d9659edbe0d35793d86ee065394ffb8c99a90959fb5558f11b71891cd8f22407b049a081cd6d4c7c4e84c5b016fe653150349291072463b5d86e5d507","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"126a08e53e36b703cc95578979034e86"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
