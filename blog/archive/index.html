<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d36f6aedc3bbcef26f2289c56ca8c85566f17cfeca0175c2d00859038de129e64c802c0776a8171a6feb65db0d4fee4c50ed29fa3221478c5489059e86c329c68e752b6aca52503304c2ead8a6705d557d662b5b20aa245479fb8ace3727e0b4d478ce0335d447044124b210bf695addbfe91cb47ad60d60dd5ffd4f4489ef0f3eec285a590f424329b70c7495efd1839343dc53de77629d41d5720dd2d1682f2ada8fe1b653932a4affdaf162adbbbfc59bac08f72ece3861e4c9e39cb7fe84d43cb2edaf6d4c457b5889475aa3295347481df0589414c1a5660aedbcc24dba5400b0894758ae28df2a8a4581bc209ffa49e3ba9545ab59bbdab662974b15892cf2ba737f855677f5508bd197206f2bba57566ff801f1e67382a9b2812a9c63a95567b91ab739c16b4290a0d67ea71f83a5a9ef9c83fe9546721dfbfbdd3ac74007111ec8fc12762111f2b59a9e9536a08efd79d832420a788a8bad8b73dd631f624ce2e9db85637ef2e723af7ab0e5028037d0ae79588eb64232d1a6237890727640c688166ab32eabe6af97999b39984eea17ff662d04fe0e9c02e757d895898c398dca14be8ea9be4f3f5df5055a82e3d5ad62bcf7bf5fd04a8b23128b1f3aea0a825ddc5796b19c1865e62f5d2925f3d26a2ed11620146638ce5b8af43ea1bc9bfeba3756723cac32611b9bd4e15a9033f8c0d181daf002d9578acf35844bb183fb9476674d0a7208f5c0aed726985f887ed28cd84105f49a1a5069ecae1322bb8d6dc06c076e1c0a61d1ead4c64b2066dbb3f67e97e6f58e3d4daa1640dadd6fbc91dd84034ea7f4b0db589ff7931d0db70991aa6edce68b5eb70be42bbb474c427283fdd18a01193b19d07a69121cbd0836946d3e6762af903ca537e99d4fad24c13de07e304ed91b537d40c319bded96b99623e4b52be25358789ad9370216a9aa0b06e83cb4c33bdaec5b7adb2a4c82320e187d4bc821482ee7ee00ab9feb0333ccdc57dbcf2f9656865179e59d4289b57ea8dcffdfd4f2eaa1ca47670f60781eb295ddf4ddb9936b975f8ebb0115d1264717728f44b1f8dc2208a4f3e61b395a972425ff148758e54a619b87e8938d24a6476012897db65f3e9a8a191b22d39b9d741a0507541ca7de697c05a5ec4da8b75267103fbe54d4c092edb9073e0e8ae7b69012c0178e17afe3902676be9a7756dc53ecc2f4ebd5377128d477e1fcf530be4456c446f20972030a274f827d169060c016e21543905d2a45cbab9f008873dbd6ae99e7aafa031ead78d1626c06b50f5b2ff8fad58f15194af5f268c2d51615a49cb6be9331dc06d950d6432d1e9339539a89b7e1f604e5a070be423f1dcb4ffaf9fce41ba8968f826a5a9691e195d86d74c3df63c4c5d9c1be10219c9810965b71ae7344b29ad6cb7a859cf18c5baaa238aacf6ccf5578ba9408f1134ea12ef76a1d44c04a924fc5857d15275b84907333470216098666d37ae04a26f326c309079bc7939dedbb043364a9ed5488f89b924d5ddf0329b0f830bc8597b0a1d7890066ca5fac6ba0cbc5d83b72b44022c5b2a9583ad078b0af17c827cf1458ccf38a61d53f53e644566064f9b8be7c7e298cff56829592ffb11ed4bf9930ca2447f31ec2f892fa3ad7b5754110c871185c3a99b0d33361071eb6ab6c1c34165d3ad4824c0cfc28cefd065072f6fff1ec92bc0febaa4fad3e0d52e13bc82ea52aefe4b54e03dcfd8c42926784d8741b24165d4831e973fbe8a6cb38cd0872f7fda503b801e09d445bf13c40cb34be244145974ccca6257feb9a2780f28c576d44a1bc3e64ef2e1f52b51bd26f0cefe8bf56026ae0d84cd46165b53807cdaf7f2d7986bf07c100a14f509a7dce68ef52730cb9ac4d527db514de343d122788c85694e696817e3d45d548a429745510a6cee0410a056aec601312ba1f2c94b47bdbdbc2576f44797149d6dd975f124134d2fff649bba32d1e098aa8ea83b45e91cd0b1e5d296e7edddaf1f3c8efea97b753c9a1e814aeadfa2ed3bcb639d7a9b0843d593be6b40965c34c78bf79ce1125cb5224d9765b6a59774390791a7aacd16e053b98364091e89f2616ffb072f3d15c36d432434c0560b175efcb056e52946c7a916fc0ef2333778323b6100cd3276b97c42bd9da28b0e60e2a27a6ea12529e6e7824959e0b8fdae0d82eda593b0fa70517bbbc229b25da80cc49363bd5b874ca5dfca5557686572712863396cdedf30f6172e6ad37bd149e41124c867052d2acf29e1ca2169b6e93b28a58266894f71d85ac59e2320d56f4fabb1e60735844503f34a9928820551ec975db50034710256cba43903ebfe10c16c4d1bc30cc06c3fa3ee199b598f407bd1fe4831a77bbd4f4c21449bd3540fbf99468f064599fc3a235f56e24a41764a11d7ad79088776a666b25b51a0e7b6dcf474ff134ee3d2bf3b3eb4d2fa65c5a17e159cf15936ebb7fcf676dc902139834ff01ff76a007c1da004465e99f468bbf28f4932ed93524d0bb9ad90c3ae7d9c9b67bac6a92f5fe7a6c876f5a31a2eca8b226b6b5043f4be40f6989be3e74abc8656f12161dcef1d8363701b84a36717adf7fb055fef869387ae53ee3fdb17dabf7282ed8b290e7a399ef948c7d378424d2a8c097a0d5b3be7306501743466f187c8fcfdccaec77e936566a49ae60032ccd77885de496ca8126bfa1624fc7f44604dd0572f99dba9fe2e6901c1099003a3f2b91ade547233b2544fb9eacd069d7efb9972f9390e2b75f5a2e96a6457b4328cc1278b3933f6abf41bdce727b9581d51289b26ca86548131997b795b5cfe4449a944fefec5105337cdd1a9dabf554c833c77b9dd4c94b3a7ea0b9c1417685f3e8a597ca68f4dde21a63353fd723db01eebf61af2287ffaaf5be7279ca86d9a0940a77f167e6c1d177590fc102790f58b7be6891c39c6d538f304e2eb44fbd67446d9c84bf16d9bf3c0420d31b6365616b135636f690c4bf63a0418bb09f22c2acd3ea15d1ce9827431cc2789f71eb46e348aad483979e549d1c220e812c27b0b147fd9b2132afefa897fdb8dca867263a55d0a4ab6cd7930d43d48b2bbd3cb86b26eecd5cf35f21d9247d8f50e876c6e7d73dce38de0f605c019805fdd77876cfed040d229b57973e68fd338f8d3c46498d38d6401e90c980e17f3305e2a07a78f76b0d9757678d949a17061fbbddfe0822e2126fa9f2dc0fac8940181081722360ae57c007df491e5195e10576c823b8f2c099389d042b3888a3ebc83b9df320a32b44053b62d68411b60f092cfe00d7ab28fd7edf9120c393dde6ed873dd4bd5444130491332b9e00884c3f372c96e87dcbb72cd3233e12b02d8df83b2e42879859c5afe4f27c06dbb7915192896405a2cf6d5c3bd5e7ce40cdad8cd6d205f62ad745961881ebc345088077898c146e6a5582ceb0133e3970c83e72f13b7183a4e669d63a040f4309944b8bd893b406370108bca743f948fc42744b27e3d629394a543ce1accef2289e5204688dab7671768e0d9e8aef3534a5c98a9d0aab1220373b44fe3535a4564333b3e46579015946c0c28e1bd51aba1b9f67d71ced33c490fd10cf53db2753495365f5dd1799687ec45834a005f086d8053285c38c861a325808b8086d940413b7205b7bc78b32e61f6a6ccbb35b1c331cce8fa5640eb77fcdfcdc48581da6d58a06322b45d76f6129f3e33f64032e97e9b314cfb5af1c539dd7f4b073cfa7a6429eb09d02b4f97335f98ad4c05eda2cc1a2e9901cebd77f4f2d1ca8322ecc9c35ddede7dfb130c8a7070db4d1648dc59f90e80ebc643de5750f37f0885ee855c8bde1d9bf31f34f3057c4395e341ccd9b1e8341b0fad10ba6380f06441c86b69c7272b65ae7883055f2d3856b08ae3292054d65441bf2bb76dd36ac270eb7e5cdabe812dd845f57a5abaff55419e539a4f394eca27e1f2619190234e072ddd04d240c7508d12bccaa8d68ea1a759b525aa129aabd267b5596eb17a5170f5ecd1ef6a692947d470e015d2375a33e6c966fb71f1cd64efee04585c2e77d7a9f5f731b7b8b586a1a0672b9bc5b666216d6c5e41e14838124b808d695dedad70d8a1a9d35bee83e18b1b8ed0e50b5a3ac7c77d3fb70a09b595a81d8221bcdd989c9b9ac3db350fbbeae675c291cbf6c902972fd2bc3fcb4672fceab3a94a727ae84941ba557fb53732c1f69ea029a1f0b9c03eb2c433d86a7a5186ec4d5d462beb07b4e02472adf38346bcb2992fa312a4736be92b4b1d851f22261da5a11663dd5eccfd2823c5ed9f6087de46019e680da0f71c58281d5fe9e08143abe5b30d4b8585334a56030733b508c3e534b1b6c6897ea697afadf39b22ee8bd49870a114c1a4870278f8eef2aebcb465e44bb5e12d8124a44dc9dfe7171c25f6ae7d006f1ff703ac338d831da572c60bc8fb727491547a93e51bb4accafbfff27223caa7cad3f921fb3630854c309a61f5cdc3bd60fa1712dd8d074135419753ee215cd56fd5e91a22d9680fc1f8703e551a98d1f3d92ce818abb25a123787942485791a28dd151f712f021ca529c4e4f54378c0e1973bc48658cf2ac5f6677e025d84074606c780136ddd048c35f32a19d70fe89de1fba1c9ad6947bdec1e18ea00787d7c637d5588bd3c445eb616fa0fdc3977b45ee423223ab59bf158d464e1dc3253396cca856acff70f0dae69c183e77398e95f72d7ad4a20634f8ca07da16d48251d34e4107f4b66d428c7007f8f68940d6c38b838f74f645dd7c2e875fe196e6f90db2dfb918f84e898b727891c386b33c73cf77a0a550b99005efcd969d2b6e92940f170458b5ce4545f0ca2ff38564bb780b87e88174ec1aeaab27090b6ff912c7bc3a67ab53f15e18f12ee2e6d94fc09c98fb5dd3ccbb09026771895dabf20fb8992d7a3098f420bc42950af6e89946a9835f7404258de6d21ca978d8fd7a21e7a4e6325e3751a37c2f750b8bd2e774cf49be675f08f8da69c3d190cdd4279d8660be650c3936841bfe7a86d9b93d2363d2e1edeaa65698551bd28e5c32fb014fe40248b0014eb31add1484d2a4dd79a83bc99cbea1366967c43ac890fa86738cea5e1d7ed65224759495b694bbda5223e031f1aabb79492592d27bdb6b6c73911aa9dbe3169bbe13f69ee33edd4ec75a8e1cf6f6c8c550445a0227852d41758e3f693de9ab7575e30477d42c91f0ce15c6f7b01519be86ed79a55d8ba1377db6c5ff2551554f2fd424598ee3ba1e5faa2ae80b6bb3694ecf3be0933b22e682f5b41e1df1b2dbd422fbec60a5b40a0a15123779500dd8354bca0c7659e94178998c890286a8f1e0ca40a10d9f207753e50e3a8727ab308c12f5c10764966a6b9ef5f8317e8fc8425ba4581a470601d1f185950ebf6671ab68c7372347a643eb45ebc69de05d0677b4c59a7ee6893e18e110b74fae6bf710f334be0d086a306e1dc03fbae70da4ca2f997a8afd5e4896342ec7f9090d5b9272ef2a99569a4ef5ddca20d5da5a2843ff946c75963979e3c818829ff14490bf352b1eb1443773b16e0ccecf3f7bfccde17119e86ee9d27740fe9895893ccdffd10e0d6dc203ef2345c0f70916c785205c93d199fc910b6c823745148ed183f14bc741121a333517158995d994335b61de6c40a96bb1e45ed19b22c6c0b30b72cdc255de05f285f7f5c5c6bcefbd2d13ab4c85bef98294bfa7c781f7037d0f3e5412507a7f26e344df4292905b2f4dd8eb6404684837f988dc6dca84547d8e6108d9c21a6a5dd8d54677f82c4c229f1ccb98b5bbca6fbaf5c6c294f0cd70066736fd00405224573eb262140f7a3e278f4b46de7e22a2dc558bf116043d6d3a9f0d853daa0f9bf34dff7a6d34f1d870dd18f0dca75693c9670fef53155908241f68d503326a5f8d5aca337d07c3e227c38481cc5a7ae562793492600a6d2e6bf2bf9515cae6ada867f228146742cc316466029bf78324e6e6ad2e6135747f1f546f459d30200fe100a47ca4b930a047be20f8c6366a30e856548777110721b909b679d9437b96a19705ed5f1bf3b0047711c5ea193afeda08e348e4a2956a7890a984814ac1cde8f437298af767274b008a8d85dd566c88aee5d714deeb0e6ebbb733d1b2673106bb12405b2cbb087229eaa05577d1132d093d2f9ebfdb1daf49f6057edf47438eebef77b5dc4544add8cb1a2a0d602ca87bfb37dd93720833f9cf7780d7d97c2ee1fd460f78e3c8030208d486fb60e5e5e8778b769870d4b09cee82277ebf59b2541292abdd80a8747a7537e9785d735a27932b72d7d6c9a7a9a21e929fde4be2ac5e042f0417b077a916540775b2f0803bb21e0551077380db10b8eba73cee96ddd99312c34c43d595cc9042195f534aec8ac04f294eac6d444b2a94e81d88f5e6269682ae4fda659dafc2f248e2b3b759e44a237d8205e85ce308112d080c04021b4d62b8d8074dcd19fd07a97aae2d8d38459046445db94c6be863f05988d1563d83092ed9e05c108067cc5930cc065e4d76739d7ed99afc759287a1794edebab5a4e181d3550252274b1832a1ae7c38215367433f457616c3789d4a15b824e27438d2fd263caef962ee1aef527df04c4b01d071e80af038b7c6e6b409f2378f6fbebf25f3815b927f9ccdb60b0e17e33625faad406d3ade74760c8f5126f86f804cb3c989d10225cd4e3ae7336544f2b077c8176740257fe1979af920d9dbfd200716d484a1a044cc6299697ba24513c882bad5bbcb8b0bb4b32fef8093af83c6ee9e63883ddfe4c67d4f8eddf2b74f403a146d784b615e0794b568bc64dbb74b482a6763c6d6b84ac733933492a433dd3754406cbe90e741576e34f6d49412d714ee500a116cbb3717cb4bb8c9c1748c2d99acd55dc7dc89eea8b4dcfe6f8da75557ac00a6aad91993f6f184396862d4bff2cf0d49ec418ead66ee5ea6e50808c33dbe200163068f564d334fa6757a392e37389dc60331d33e887c7c0f350fbde892a78552cc9df39afacec2f74492be1d84aada884a2acd3440f2026c2937a60bb2ea14eab96e623c14397edadb62084720a23aa31f67a7c41f68679043f55cba570446e9e1e293781a6217c4cc4b0ba913beba3a826bb93a09802dbfdac415997bba6620812330d0afe59f98cb712f9e0e38d4a827999d396428ff6d78534e20643968c49b28f0a707bbf23bda1a917f80c8702f93118a65ca42f6a3be0220a5042ac890ad1a4edcae1ef3ef032af8df1bf80f43554300199ea7e7723ca20d1a2813fa380cd5f6212a1a91aafab9dfc4b9300d90f3f55ca6c3a62fd92ce6cb3b1f9d8a177eec7472812b999834a27b6a9042dec2ff385699dc36251d5b3306c4a1f592b5a95a24afa5c58fd54a7b16e9c8e1347a4bfeb64543e93d44df354aa368ff306fe4a0a800adddb4b5be25a3723700eb8aa363bd2cb31249161e4d487fca2a3d9bd1a061b5d31379e45751f82706554424a1790d547c676f1721d45a695a8e7d0cbf80e5935ef1ec1be49302323df175b1dac240d3e9ea4a92093d306b040584cdf472c55f2870d50a9cd08cd9a7ff7022bf73a1e5a2a784328103846e7df9d99898075c10eb1c27dd1601aaa4b61ddf2dc9c3785a9ded93d0867d9f5f214d4633723b1210b01c45893879c990b455c1abafd79b181a251aceb5a1c0e484fe28ba2bf17eddbac0ab531ab282c5d8009bfa5d0534cfe3b716934536353d29ec9ca10934c4b5606af9ef90ad06f6df1a6d296f2c65b6b3d33a2737ad01f8174de5b658ee9b342b1a4e0783ea1eaf52890145392cf98341b5ce15f8bc1c6e0b274380ff159dab05c6b63279efe8b1d0cb7ce9e9ff954cdbea116513a0350ccc3631f8484af1dd729fff4bc597e71087d097d6f4c910a9e9889c7967f2c515cb7e486d42fb11220249b5f8ac02c679641393d857d1fc6f949a90fb05e7157a6e46428aa996ca5c2c5a7a0384f7a625cadadea88bc9217077bbc8e9fdd74c299537ed4ef5f17281ec117aa83f9d3e283097a296860ffee2414790c20265ccf8c7b91c6c6051c192324cc3156d675f61b2c50c244832e7ff39f862a2ef89b5e7f80df1bb79de01a1b0429dcde1c9bef7583bb33aaf7dd6aedbc190a0a06d24d88c9212b981d31de821180b3c34e6759e90f5a8a3dbdf8dc042f39ae2f60d9550e30cb15867c284a3525a1ece7fe7d09437e63c56be8734ce466fbed11afed27c817368133422fc2a7b156318fc00a74cc94adbce6b7e4d1686a1a45d1eb38f9ee90325a63a2adca1c13fd8117405be896db7edd953ba7bff805a33490194e3949678c4f19a947ab13f67aa2f4d07ee9a2483115a2a1450d2ef63009204cade4d5881a627b4508ae75a02a54d603ce92b34e3c2d897e0c73c584cacddb2b44809bd83ba4ee2ab329932478a1272dd0b68d7eae8c7b64414ceb43f65f5ed9764010e5e381673310bc24bbf6cf6dd08a05168d64be895a9da5b2375d09bb0153c400377c27c374739520866e72d207cf3865d311772308ac57568cec02da0ecead51de669930dc59a00a093b43bd6e61341832dbdc8465e130e951894e49079b7ec94a7418929fdc4d72ff62e0f65d1a421710b9a63307fe12692526195ebb21337b5681ac7d6aa98d1ead51387bf2677e4031675934cc41f3ffa3162c55c7b73efdd65d0de958acca0d051fb2ee4b3f3d22be27168fa653a806fd84d4de2311e66a86d874755efec7c0e17a1922ac05c9784a4a07ab620f2c2791651704d45a570b93e3c3c0fc72479826a0b13b7bf5d094e7dc057bb406a6dc71074ebfb04ab7c4dedaf917aafa17deb70f2a6b8058515773afc49d662726a3dbddf8e201b00b328433c05decccd273a3cd1afd90d59599a857bf3234e5dd00288832a7bd84cc86bef6e0c0d19965689bd60545c8306f20668200385243f98e1d236ca72e7a175aa48f6eddecd74b7eec4b4210279ac800e16ca98f945ad96c29def8188087253d63ea66d9b40ba06169c2c07e7d8167df7d64b278e10d41d99399745fa3c369cc2c5d91865dbcfe89a2d8710ceea6805d455466a136d79f36db5811b8b70be0ec8ecc574c38751172ef357d4812c00209ab2ea0461b04a8c3d078dd354f4cd1bc9d98ae4c94aa46b10c9be7c87caeba04273539bb0a4196a86b35e055701e1af35c3ffaf3f82b900ea93c7d365fb2bccd3a318e1e7c94ecd900e9c9d3638103ca042faa44fcac828842337a62de556b65c36b771cc664a72fb6b05d03074c91f448bea3f3ee0ef08e189f43b96bc284fdce5e27083bc6919de89337ce46ea8b6baa6bf86182bbef6af8046f99cf1444ff768d02ac67440b500199de45fde5a299d7a3d4e35dc9da47ad900a40f2620dcd26477b808b23679cc61408afa0f18d812e8d443e6d456ed996af742dfe7d73211bc23f500d45b54719aced77533aa1a4b5a8337899b78e3cc0b9d1e916d153846d6d18831e593eedf81e04fb0fd3de7a88eaef9b5583ab80db427a8fde3d90c8ab61c49afb43f27cf391c69141e0154be9154da3a863bacefe1765cedc96fa059e76d68e53df1f3bc005bb67f75c056ca471d5493c2efcc2b464949268b64d9a2cc28279cd8b47635a29ceb652fe2d53dcf78716886e174e16ebcd658c43010a0ab6dbcbf6a2d4b71c664167276259cda5b0eecfc84903277ed9566a0a45bd8e1738cf8583268f27f2b642bea222bff1419b1af8dbba061b83cad6f3707b31d6e125e2dedcc25f28b344c39f6a19f9ff40370303fa87f760b3d5071bf8ef5cf576f4a4df095100383957478d837c007ccf760857e6d41fef80ee7925642b165228bc54587430bd8ecc1c9fb1a69f83c65eb4b8f3932c957416c61cc840dab1fc7bcd42b86b3495dbaafdd7b515f2f070ed5f32b707a2bc675f75dcb0b5453ca57efe4309022bcea2b5c440b64dc44772fd2d9b0c4fed8cd0d7ec75810e4d13e7a484dbb3ff56f815b1266254ce88cb3398beec3bf9736d3ac30280e97e088b8dcea8a27960c74c74a20c208423a3c67a526e045168fd64843565e70b39f4299bec1bfed41de1869c213e3b98190380ec650bb3f5415a1d05aa4ea429297940b6e5b4de4be91cb642d4854548aa9660a34e3c41d2f38aedc30cfa1736962d44885707a3ba8047c608932a005c30783aab4fca7ee66568de1302e675ab90d095f57c9ee6b2189b720c514e11ad0611533cfb59afdf1e796e02e0cd38cb7498b0afe1b74da402222bfc7f591b8a85fcc700de6370c21dbc576f46d543daf46485bed1c9ef70459672aa96ddb3bf49caa817302f4bf0fd983ecff6bbb54400d1503c573171e0b8468ef693ccfa82decee6e8120d8d097430627a02441f27c75430752a2eaa0a61a30612217a63c220f4005c6456f733cfb50f875d885216173b9dc9b2ccabba6f06b971e7f9ae0c3774cd152aec4aa996ce6fd4a7f04824a8beacc9572b1472151513e155367f6dab979719ca9b4b208ad94822b38cd891896674d91ae560d8c6cafd4259849ca13368efe893feea6ad207bb948cf0350ef2d16e38cd3c99a904953148b6e11460e559b9f4ec380c59681fdc469eefbb8a0215354518f7be13a670e48573fc696d8f30c62677bda1f8a4b85e1f90593f92a2532a1a94efba73cd4af502f958300b4fc9831ebb2de41954791f829e558f1d787a27651d05b36ca4e1b0ea9747bc262fa25c2db29cf4d94c21c23b81a3b852b5d253d8d32ceb874e1da042cd4413b9aa8e9658897f65d6c618cae0fbb2625709f382661588d2132198f15da8250b9b34e9cb3528fe5574f5bf47fd5aa637a438ea7b83155a0c82dfc6f1b1eb1d944b3b2e431dee2762b13252f5f8d208769b40524a988df694666212c3b81bcfc120e9eb157f531c52b4103ee5d34bd9e63e55f8c94ad21371787de22dbfcda178efa8003574bdbade30f4a6f51d3bb04653d9c802cdc8ba1ec302f1a61623ca351fe3097b74990df719944dcde3e06d916e76499092690b4bbe7baef3d992c22bf09562ea5c80c9727013b2932e70435d29352092e42dbfb13b9e628816062aea5a3a68b48faaf19b3a917b2151a1a421e2c11dcbe1813f028038a77b0488cc931a16e271e3bcc5d747facffeb217ebccea29dcbf2db6db687bf510bae8417601650e765540545198864afb614b651cac4e45f3bbebae5afc14519060f6a496924e45560886126c44e515dc4f3e8d7bdd1bc17a9d96299c71103deaf0aed65cc3ee5e19b949c482620bed1201ef68e5e5d6f1195bdbae78704a44b24e4c94c682afb32cfdb7ae48f2335c206493063323f181ca0387cf640ad3e94238418418d622b352aa2a01be56f1db7a5319f1b03594625fdb94043d71098b1da964669fd44b8f321ce6d8c413c00a66f08e380554cf918e1bae2ac7d7bd085aef2033298439893a98997cb471d54b50cd1eb8fde672f676a8f63874312b19c5fcc62053440cbae03f011259a4f2c2d59ac8d29533cf5e7dca3c76641bec7ef0aa4f2650ca0923dbf2fb275071fbb8e9a0c79e7bb5b38e5eaea92f21463b7feb1ecbc181f096cddc47416a1acf91b19c778029494c6b7db6d9d4483d4625a7a58bc8b4ca732de452bc848323bab1f343d606f0d0f2e26a33c3c301815d8f2c9df81ec6057084c8cce16f76d8f4277721284659d39fb387ae6257383a04841c012ca3e831e3a8a9ef5a4cc47ff5ee1bba706c292be52cada8bd013d51c3e9ff63fe88b2c4bb7722f1c2ae046d66fd166a5ee1f587fdd476b71a4e60d105e13b5d06b98ef10f8e3212ac3fac37293edbc5c0afd91a58d7f922947d7f1601522e653753a0f1725aad939be37014ee3363c8ca127457fe0765ab8c3ccdfe6b129df11c9ccfe1f3d2e70da27525ac81d5f22a48c48b0c7e934fef6fe96027bfeeef229d1c3a6576e3da85f8ac9e61964343c817e6ee0cb16df947195aa6ea47ec4ebaddf3475f6ec53051343391fa9e163f24a7951509d89b5b8a55e6cb8b9b689680e86c47d7cc467c5fdb3871a8b6582431366d6101b6219fa2fb107eb7cf6a2afb36e46ce81d89e945da91d1913bd946222ef6f5d5d1376173f6ea9db8efd5fc38473d5a9bf3a1f71ab80552dd3cd5f22f8f57ddfc2d2aa724dedccf409170366e759a9e6edcf06b880d37b00f6bf47c71cbf9a0f9938f23564e379cbb5a39b3b1f654ea4a8d3c8a1e9ca68566a281fbe123787793bd8534337c3a04286364656f0690f745d3dddcf9a118022366b4cd6b52971669d451bb241016ee1dad4c9926227c0a07ca95fc8c8aa688ce3e5cf5edc9b9655ead384b2b33cabd6fa11e87dc2ddd8e3765ded7adcdf7663a0154cb2a3cf5c3401c8f57cb10c6812e65c4412fdcfc9d4e4cd09e92cfade6d4c234e6ba46b811c64118b6f8e7c4f8937a5518af26310047fe85f6c6591e0e7004fb55f8ea176594da9341520b29d359ebdf0de47527b00b9e81c48147c49c92ac777f34c294777a5cd0dfbf15bf74ae237b0157b064fbfb7e462b9bf00b13e24e3d7625a4be8ef87abc85018f13825812c88d900a14e4ddd56a9e45a2c4df92d516a070e5a20186c49199965db7b3acad7b83d388aebee82cc8e5946fef9a1903af41df6b883ca95729c2f207e715c3caec6045c784fc7064916b39a05b9b8af4f57c289b503731e28d385fcbb7b4a6264b04047be77e19f87b79ae9de74b63fc2a42e06f63728c0180da48aaf869ade7a787ab45d25798acfb51edb3ea3dfdd8f65ef2472c021e01babaf0001660edf02b6ca32bd4f84876a2ee4741f8cd9b6802b71a52f9cd955fe551aa111ac985521a9eefe426ac7106bca0048bd59585d72f85e453c3a4998a186c4c92ddb669d53e4f18ed852525fbf654a84f3632c1627847aba9639f74cb8e815e9ffcc83c3246def53b0f44e8c1f96547949deb1393ee057f969eec94de69cd2d2f161a94c82769dbbdf30e1b646cb9ca4d2458090e0f668306848b77343146a5e38613224096507b75bbb5916bead6c994dfab714e513a18f0f0edd20b1a445a9a5d3de8168f77addbe65dedcf52ff7b306ba496f48bb98f06ce16c19578c5314d239d44c240dadb6e933a479e4dfb0ee22eb6d4e236063992603c04abc47eb351449d5ae8cc72f3268726d56480371244c490f5be7e447054ab35d7ac1bb5708a7146f79c8b7dd5dcdc1d5375edc64ec8e534e7991beab9ab2823c1e1a991ae35585b5a636465a733a403d90ddc42ff875ab3c3baa2ab75e6a7e572c155635288100029500def08ffe135a41eb5d223b65b156df2375f997ba61695a1d2537626f909e6127c605fedd0d1bfafd2fec5610b5aa439b2434aeb647c0b3a0e19e18c0d88a2d16063d0a572e699e80bea0be7593b595a31abbbf6054bdb09e7a1fe940acbac1e68dff7de0c632b32fa30de81203e8a6e689dc6f30f510011ea0198504af7bc91396d5e056721cb7d6caa47dfb2ab4422dd761e9e5eddae6f06d53ad62d53cfe982b4bd1e68cd76f2da302a6b0916f4860949eba419c5d0080ee9078452e89ffbd5b7e6a2e7419d733d44664e2cf35481b01bfbbfe15ff8cd23a8f5cd2e4b27d00502bd2a56f38348f59c1b4cb1f216d8ff5d9de10f92890f297c7d974c9108837463682f442c0cd6b2f431848e2d9bdcd8e51f9306b708b024e3fb07225edf7dfab0289fed7461c294680ea6e06e8b15752ed2e7782cfced855f98e06a53a8412d435340de60d2f6d2edc99b2be311b5d059eae15af1a633dd19627ce8af5f7546e029fddb0a613aa5149ce3593a863436ffe21038a42c29775cb3564e602d8c09d9d57785cc7b6f82b11f8c77389e0cb6eecf2d46f79edc6a53b54027791d930cdd0a692de43501d0531d923d0550dfa85c92781f228ab8d2be26cde34741ab5fb2b1c47e9e344fa06420094a655327f69fd0a8257083cf02caafb1102bfc1f580dfefb706d3dba385eeadc305cff740b3a58bc1868382757f443ee0c815d680a833d7fdd60bf0530ca09eab98bfcf980c39dfb9a452b0efe498072156d2ca1d77f49e11cecc157e6cba9c02862846aa0102e23ee3937e602fceddbfdff9f72101e843d32a9faa3e204a76b2553f4a410677ab5f71d1b6aae7e20e48f65741549c4cf831913a6e945700a0256cc9b1fcf39445e2c098fb81ce64a3176190ddf1176df11193d8d6ec28974dcf088f2d1fd3bb896989f7b0ebb23b283de4cf4e0a55b0ecb68f12c2c00b250e156a17f5a486fcedc43b5e311732633274a0859543c1b230afb036fbaa88bcf0e84556f167aafe49ffc270f675a2fe6e2af5893b133721b0e32cf9b2955f2eece19f3cad601df9928878bdb1e9d7cd4c4073ac5b694e680bb1444f39e5c877c974ac21a7aa8d7676cd39043f50dac52a248d37b5b1b9d62660b2edb0c7bcbf0b434b556680227979d77d2414483cd26be1055f6c41ef3ff536ab9ed037bb0fb4b11300a7bff568af8e53905d3d3009d5c8cc5f32bbc95caaf472ae5d327efc086e6581a1b2b4063b6d6e41e777b0acef9e578bf79fd1e4e1c268a02aa951e002a65ab308a54c41755d90e46db753867be64ccaaf165e2044b6b789eab9119bf414c25841929771e047bada03a9adbdaaeedc51af2a8e15e777794384bc267ac93fd47cc728713c79522aac441c52c5cb7b63ff09bc5c7d9c5d029d281164e4d0c2db6d6792d2776d0d86fde21476558ec47a2a860c606da4bddfd703621fbe3decc1199085c8865376857e8739f3bff79f59974ba75c8e569cadf2200a0284734fe2801f7e1199e482c3d83505ddbcf9392a1ee03b7129eebe740e55d6310e5f4959365d86f2a1b1bb7a4d220e03dc47e45fd16c38ccffb8c0c9d228e3adfcb3c7716332aefffa8500e4510181db6c2d06c64048c04b31045c7f8847e03bfd9eb7f2ede1e85466a12bdd2cc44422308caf96","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5772c6c6da40bb47a5b1786c06afb5ed"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
