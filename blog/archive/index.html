<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"56f3c1fe3bf631f638f93b38c40ab11e773f5d883f431e95e4158b32588ce4791cf48ee5a3bfa06d58b66696cddf02b7b51ae944bb70b8c3c13356a87d2a9a5334345939aaae2e8d9bb89120c1b3df7884d2d39146ffcbac3af5d37a66e3c5ad81e2903488f55edd4d2a6d4156bf4bacd8614eac815b3df06ba90fcb50a23a950862a1b312d00b80e047b80691b5e8afe14a14a2605b9e81b259dccea0072b34d2139aa1c726579937358c43c380ca8034f9905a9af55903181a65163e4001335f0e7a0594e30dba418cf8808346e56832559d6310ef8670852645bd50491b06ed2cb94772bc49c4fbc78e0e8b328dd74a9420f9366a4aab5e4b579c7f01f13c2e915abde1357f4d63f52be32a122ef2185a6cbc679454bed9c8b65573e62ba5356d61f8f53030bb5125fb4d5e3b8cb7f451eefd1b252413eedc27ef4aea9737d6424e5f9b27e948d7f483f2f537bddb71eb67263c2103685459799d425bbffc5e45e9b2bff16059007fdee6a037e3058da982d0682f2845126b326d1f354e029c3a9b174cbaff2454e3faccc81c57fefb092acad978ccbe6e4acee2fd9d85e0a2c1bc7f82f71766fcd37e544f3744df0349747a7bbbdb5345d14bb2fb05ab4e382b163b15a7c5e75daa697455f5612b8f1d9458aafca5cd789e5fb9c032c80c394eb60c6eaac60dd5bf3b6ec10a44461a0ff51bd5b731fad7b2021797d0a71fbaf03d65846793b2f0369fb5bcd9aa9b562715b60772f56952e276a5d95c6649ff8c9dd6ef95403cebd5dd63f32173695c1b1953279a5e4ed8fbbe0ea4d42ed6b4ff3f27c0d2f2a058aeea84d595d29d17399110e8f2c2102e00673784eb68e80bff57cf107775d86f3f935be5c4e8b686312848666fdef6f86f8cf31dd320a9fb921a257159973bd2ad9086cb81979ce88af7bca896f0e0eee598f8ed272a8ca2ab22bf1ce76433f67e7c16816aaffa5d3316cbfccb59491064e602f26a184e3ace444b8b2e8ee8f47a450a7529b97cc3b6ce180d5c2b152f7911a80cf073940352e49f72ae3b20b40b26a03a52f02781af0d1128983c5fd93891608ba1ae42bee8857ea50f0df78ced599d7b1d218828c1f1fa2768fd99e88ce08b5b7bc91417b9aa4c9a1d4a7c39304d7b78ee60643a60cf427f9fe2c67e84d29a05db68f38128ce4bb45685bf6baf436ea8ac45d3c52401a270483b1d603f87589425a4a2e65988d081125bebd6dbf9bfaeeebbeac89f492ae0b5e673ab26fc729b4631cea20a406d39f4963857fc500cdbecde14e8716038f8c6fab148c8f7083c487b31dc9768af3e7caf24d4cec32436b607ad602760b047b10be845323cb3242a14b754e4e83681a9521e7dbd29b2126386f3957ad540c2657d3580436bd8219ae1ad3b5e27640c054ff32f87a6a478835ed1c8fc815986c0f772440637f44ba0dcead13689b6fa14da93eb7bd6adaecb4812af83df9c817cbd382eaee7ae173185b5dc151381a1d36772b8e3f9a510a97655fde06680108eb60ab7542d1b6aab042a95ce8d4003f73115badc02919bd661f37d731b33b0afdf3760a240c0af09b04cd9d77e91e9e2315fa82c2dd16eec18c65ac6fb54cb0d9244e60e01fd993637831ccd73d93ec841474a0c27ea1fa881e88d13538ead2dac9c4ee237adcce8ac15096b41c6ef8695ab6bb0096c21687f77c092d7b27f7dd4f9775755c5e086e590a7b1fb6fdeeb3001410acc654a47ce75cbead3a4ec31dbd80890394ed22282304add4622bf4d5b283ff0b71c99aa9cc61a89144137119b0588f27bc20e18a2c269b2d6e9de2d2b508320a9573bcffa168e3aba6bee0457c9259ff95f48ec13a857be52a85f0fc49874a7fdd757a242cfdbfaf3c66f8f1076f673b57b9cfb9252d6e5c7010863ad2e426844fd3f8eee9711dc3bbbbfa7449026edbc10eae09f06226b6c7addd2cc1b6ce99396661bd3625ab19dd3cb87d87dd64416da0a3120ae6b909c6d748a1d6eb3481b1dac645f0a4344f9a07f33a3d349e9ad9018b7a9b3f89f707f4adbcd26d3d2053d627638e38e0a7275221f1895e8822ba7565b37c11e2b200ce170ebb3f88bda377a879204f73c9582c647dabf12539cafaf7df475881a14fb56b638bc8a227bfa5efe642406bd2b1074f6f98eb29751823020b7167c4f40458b32df8e74472ba10cb12c5705c3bcffe79b9df00699cd125a5d26ed30219931c681bde962a0954b02d4801a61e369e3ee3350f241e036f94daa9ea980932e6041956752b378a476066ec9f381596ad14da18efd834b94b29ead6fc0082096c25f2dce4ffd1a7bdba9780a2c1340c6c302376532f08dfaf1d2c94fd06114ed264a28cb721b1b9dade7cc7fa18b458dec4fb4ba3a2f588ce019a643a837eeff4d97f9ee9ca822032900121bc80e1aef24b1f6bcc81d69792cffd708d4b09d67d41ee9d0d9700b1b01b8b243581da5db4d3888f4bf14e7ce8d4f5ae1a45fab27eac3f30f3d447e398aaa0b71f9eae2925045f55f6acf20fae9cd1cf0ed59718991a363cc2260729e22a2160fe9052082a7e9f6a9919561735bca080719dd99f5a8a6600e83d287f76aeb984c448ccb164fa191c952ed47b2d165a5184773e0bd233416e371b4be2efb9c5bfeb0569c8f43b2055e9ba492e2e65bd90fe1fceed40ce88d5951e5bfc5dd28c01b43e88816aa20346fd274a690a8d45ffa830410e0f148504a185529370a6578b9847d63250cd75008713d901dc266677ef6306a47c761cc9c626ee15242815fc1a5a896f0a4ed686b90891446fcfbc0c89f6907b1afdead54c35cd10ddd24e91abb0f0cf109f67bfbb78c6c8266c358148994de5103d39a835979b170e075b5fb42d5b9ce7f52383f883d2e069320fbba23d9aad332e27252338ad4ce9df44471b371a7deb18e651d235bf3cfbddf751c9f1afba147fb9de853e68408dc3323575f04a24fd2aa48bf09d31b16887c535ce1632ac6a6142a78650433379d2cbcfd23610a5746ba1fdba9241928d8827d9d4920adad21effcff64053ecfd983df961815dc35563be1f0dd30c59914a8de60d6d6278aadf49d8a1e1aea0dd81c8ca0e8763af0d65fab99d67c9cefcffca00b06ca16f71b911474e561f0c04f661379968210ad85ed439d9f14bc492da7eadc7a64a9cc9a992c0840a54a3dd5908c72c321a136f7bf3732a0706b3bc6cbe6d20893b3dba61c1ded0d9d3cb71dea1b91920da3dc03b49c73d7ac7e7aa5cd8a70db9389784b2eee1ac172bc2e594bac22d8913a767d1c2590bb70cd01bc5b0c0143122e42cb4b90443e2ee6604080f0f84d95812766177b3ab2f6075818dc6de4259ef8a29f0ba084c1f10128b54e8ace94c149e38882702524623f7cc6215b4b2452262d84331697b9de328b1e8528a8093fe6bb5337105b040f7a853fab94172f8c9bbc2c9c9ac02f311d81e4100fdb90d5a796699b3671d8937a788d0ea00439e1257abd959d132a2ca3303b2c726bcc4df81eede72f623a3b0b1048605cc4a77eb589e7a3041908e3637b6877f3911de076827d3611f05b607d751c7c5b658b7d0b6b8a870e844b0dd86377180a30e501832dba36961c2649172d8a84cedf93284ec3fb94581c3dcbe9c15c06bef1263c5c968dbf9d18fa94327f9461f2b8fc46354c01fb38becfc8ab989bc81b1b0092c49820402a5f4974f4dcdb93c94256e59a6c13a881e68ca6718158a35d9ff083834cb1e7fdf9762f6342d6c8c14853c7b4e8ae9278b9bc402476809d72197eea0298551581db48261146839fdd000ab05216bf3f89f87691cf3e2399ba02660c3f6b424aaf3449af283fdd34458165793502413aaa6b8dc6790535f257ee4793123a726c8eeed4f4cc22428469e3ab8df52fe3e3f466241e1bcf98bb9be1e93b6b68e73f03b0e74180b2450ff2744afa98945be9ee4968ddf397b53b95f1c2d35378c0224d3ad6dabe3dcf085dca24166a9a154f819046095ddea0c6d38043091fa7046b2b04e0c3c176aebd1e1013b32754133d2dde968fc0045f4dfd8daab13ed09e8cbe283f1b62215a47770756cc9ab10006a5e89ebf1bab802aa75f1312b5372d3a3a480640c26eb5d1a2585694e43418f0c20d5a4a30e9e444562fcaf012b7260313e84c8a817eb5a1121173be06a558a203c55ea0fcbaa3b325f25c9db1ed34e2bb8c57ed0fed731fbf6a487523947e4edb17b2f7ae640e14e84a6150cd05e364a8aab243b4f949c4caa623ef25d0658c2f846bd2212ae38d15cb05c2a03b5dc7318f591e480d06b760bb7e943bb08ac26953ba6818f75d696e763d7160e5ccadb61912613712829380370eebfc90fa7f0ace400217e5878c1fa361e024cfc42e8d87354aed854627125224c72b049a6739e28748a6820d94e02d192a8009028dfc9dc49fbb86992253ac1d839b26eb7875070d34d3a94dec39429d2a1a910f690eec02d762367648dd78e7f1ab68cb9fdbdf6acb9390d895a5f01c4cdf775096d73b3e8190453067216fa56332e963eabbf1fc3417b889d9281179b727559dfc6f53dd21b403c97c2454521b730bf152621a023877b6ace43c5c9e87c816bdf49588e4b035109c8450ef122fb9495c7d77b788b588d1845ac4077fb92c5fc26f0d41cb844a141a851c1626bee61855c12f1b15bf7ade7d8764ae8cac4d8fec7c517b7ec74f9750457d8fd38140c98850946dc03881769fc20520fec7fde49d7ced9e439e02a725af59808fba39c42e07aa89dc975a7b130edc42e0762ada84f0124fa2849aacbe3ae9d040afa6cd489f8187bec1ddb888cb70da5acb5dcbff6c7bc859da9c8c9a5940426579b1156622bb86b79310fc6788983a7d95a0b00aca660e4a037c0cbd3411a464f8438635f3023506af20b9e1995569e1991a124a97e46dbf1005b52d902b868c87b45d0286dd6938a7be101195e835d1b68866896a0d1eb96aefc036ddab2467a6b311d88f8b68079ead9c4842cad2eeff33a4a1cbab332a1798056b728ab6d636b8a56b69bba3e62be4077384b8840e312e2712c5694fa793759a0a34d0ced4ce258bd2a3e3aec3bb7211c0d5c013b1808b805ec1fa85facbaf7b072a59fe36e7393b89ea3616a77a9d60f76c235625fd90870c5725769052435292c86d7e2d101fe7a1e3d4bf15cf1f6e0b1876579a853bf1917dbd8aa4f999ac6ed2f061be46b7a0ff6270363757c6721293e0d7aaa4e5fb03c1536cb1280067062c9484f601ff591b2a0167954dcda6a1002c20e23b6a304b2eaa4eb21a62ee7829b0efa539572899bc03a4f4d877849b44af97bb7ab89984e4a56f5d0f5feef471c4d718f6ff23d976f8156b45911c132deb9bae220c8d45c8653e3640e34c92e346371e0b6c22d6f9b2a2bb29944a799c6b09748584e103ccdd54f6422afd70f213742dc5c98113507e9afa6141a662cb8dc32d9db0be332b9ba36baaf8e77f31389e34d2eee3a1bae085b6cd2af71ff4482d368fa90c29e0ee03f78960fdefd4ab9169ae0265a6c9d5fc72718b4603eb171ab28c3d2a0e908c0635313340495872c67592a011d3825f1499a6020f2455366965639150d1891a6fa36dcdfae004ba0bbde666fb622af816bb812396a26c87dacef6745f31c0ce37804a67817a38f1a8bb19877f3f1d7bd3c2c166ef2cc4408f43dccb175dfa9d39264ff7495d36260b35ae8d088a2a1704cbc5ee1e57bab6aea2d1252258377977b3b70da73e9f322b6730d39d4d8111890e848a2facb525da292403463167295459be636089a5b6768ed2063e748bc5df7079003d17d92c7840b31cd4d53b19508b982ee752e15367610c1c527e7e46d2ee7a8559132a806e8d806d27b18cd2fa7fb903cb23b4e988cdab9e14c39e39c0fd90dd490bdfd6521be9fe2422f029bff3da72d857d5c0fe8d37cc7cd5f12f0e1f2dff1e1aac10f0a6d7cd2c69df3833de42e469b63048c03b66458f4b0565e1f9617de16fb19dfbf22f57ecb27d794ea18009dd2a444d27e8dbd17841f8e88da18dc3610d02d71c3de5c4a9bc877e8ff12351fa5e4b4c1c901b9ac1b8235819eb4e4d169352f74d04b62451d16abca1d1a216721bf1fc048fd5d1c9127d3bc2f0fb1e46dc3564ac64fc9067cd70525d549da3b5128207168488626f43e21f672f4b311758e3eb9f147886a6286c825f0363ebe766669ac451e52f394a5520580a041a231063f9784fd0ab94cee319183c51d7b39c438c158fd2f63fb53879222667aa3c44701936eaa2d1f6e2392f167316a146f41344e1611d8a5e8bdbf3f0a79a53cc820f5c8af3a10447ed343ff630660d29f064711dbcb9668a033a108bf4b0a24bbbd162cb9aeb7c90a4a87a41e18b6923c3b660319c9dc123bcea482c942e0cdb2033e7d39e1cd1ee792dcd16a2e5062da07188a166dd1cc396322dc65b894ee5d22faa663fac6939df8e53cdbced9d8566227644e13242bb32ab0292efb941a136ae42b7f0e22b440ffad6443367167f9ef3c0c26fecaf35372710859922cfa7f6cc13e32baeffa8ade2e506ca3da2ff0c5077711b4a825325b45c700deeffd7e7c081878909a7aa6a53161ceaa058bd5033908bb258f955391db7dbdb8d21345a6999013eba81a145e29488c5fffa426db5f7764d972349721b7db4178b880f37fd28bffbc3c619076e27fae3a7bbd6cd2f1570dac694292fef60c540022faebb43854e9faa4d1cd4ab91cd5a15d4c684730a761de307e036867bb322f1b6d899db690057857a084839f0641d9cad15904bee55e39231aca947a6b752123af71fe6b8b682e0d6051abc910177c06f2bbc86ce5d198d31df0d0aeb3601336125c77333ec9dfa4b5fd08c7117c354c1b2076a9562e547a17988d6049815a17a8ca32ce6a8e7623642ef2e84ee6d64293d873759b1b68853337403f429d89973ed327ef23c0b7e4130738ca4d9b71554e2acfa3500647c5552d9989a1211532b3aad3c24a934c24c583920d8fb5eff7c63e4d07fa77837d3a21ec44a768ee441d4f2c5b88846fc6d39442b87d7dd4d2dca0939314e18d8691f213b96b332333589a15cf42164a07cf461432787ba492f9c578344748efd654fb29f1a732aaa62d907435ac317ccaad8c1310864a0b95d2b719b2873325171ab330fc79867b495f439fb9aca4db9923eced0759d595d44a7800b5836ea3c927aabd21864041673b453e1fde0d173248332018d0e3e5a2b0c4595d115e95731c1ac5e5ea31e58a65ea1bf45433273350e1e475f9b1f1dab64547e2d6fe0518f90bf7a598d989c395001ef20b0099a1ef9461a8f26238676bb062a9a8beeb212e1d01262c639a50370ff23931f091e7265d2f0447aa6517f7dcee1c0e3e242d2b63fb2fb17a0a0c6d68f0df4e692fd6c2daa2d051912d25c20f004499c91cfdfb4e823150a5604b2f2c8dbcad75894f7f4dabd400cc71b08768e401a7f1a263e808bc10417636849ee4a7f0673ce4b79518f3e2a0b1081c66aa62175dd0d2374cfa5025f76a7300c43862e0376bc55de30201599e87513b740ff368d77475c960eb4b2dbb2ce1c01e701113dca5af2a27a3f3df8c6475d1ac489455baf01cc8a588317603109ac47d85d7d51d0f27635c517dc7e402f1860cf9ed4f4e5eef15b88281056aa1f8c758348351a6e84bd1bfe86c5bed1d36de402d9e922f1ccbe92ed2ad187d44dc6bb465c98a8e42ea54ea71858df73ef55bb9435cc6d58051552bd4edd1d5ca24c74f7403d6383f06be131f514126325cd99a574e6f3908728fc205740cad32a4780381c3ad43d6be611063d500f47d36b9a76e5b39ad5b6db457ec1941ebbf1af1ceccf0409d6a2a342e8af3c0d14d02fb967e7c91c1da367ab8ccc73bb009a36b12c3e5f67fa0bf15b908e88ae2603262cc28de7b40aab2337b73197d1b9aabd89fb21cb089eeff6a7db3052a54974e38f0c9f1c66b47ab36f3605790cbe618fdb47186dfea509661fd6e8579e21ac14a041e3147bfd26d578376ddc2dd2d0da3a28885724dda158b72cf5837eae588bb91e2bf479b06aeb17387a0f876f75d50cd8e6e1df6572e2cd7638d1c8b0e49161d581633ef3973f472f204f9e74ea614850ff89eefd5b606528b415552f1e9228cb9151ab2b02f6aa6865cd64438a36192225b7794965cf4753935a3c50544440fe2ed834920dd4c40b4b7c6b12dcb572f8a460cee1758775e8b84d376aca4a0f52a142e2ae59420d52bad33b96a43ad14c0b109148f750ff1bb21ebdc2d0230ec2a993bccd7f383ae14ca1173da92e19185d507ee82e010d6843818f7a1c3d721080fa98bb8c7d49a16e4b7f12270e5d1aa93ff5af059db8a5d7e77f30b497428dca66ddafbcc5037ca4d3aa7751b11dc46aad8cb90a36c4f77150ca5918933e32212999ad0fc42cb9e8788245c75939af6d4835ce19a46a5cd0c7f484ea1f3cb5ca6b3b0371a9458688ebacc9232c8a00747ac6feef849727a2219520c59973aed2935c06ab58e46ae4f1cb7d01c1c2852ec36d6e88d8416137e024ea4765cf1e4883da063035548374d40bde632bff4350066c8a0f3d80fc28b03fb7947007e314bb651d5871fd146a0ce20563268ae88bcd2fe400ea3231c3b4d44b23fc3bbcf5395087a7b2a7effe91b458825130e4c3ef8eb844f7de4201601c2cd66a3f9f99fabfba1773836c79a8b6110244b0d6c0fcf16170c1f62183fdba22f723fe0bc1b9660de48f5cd9d436c9bd034b4118349a295d0399a3ceda7555cd7406fd7a5ea8bbf874c2b8ec45f18db22c300f62a15d2859db9b5cf7f728da979ff33d8e0dbfb60e0f72bac2d30471f3dc731dbb8b96d449e13e3fa3390aab80067d418ef749aa34a785b4fd6125e574c4b706ea751faf2c05c5dbeed02b9493994cfb438b9da1325e7efdf6217ed8485d5743d384b8e8162efd3691f7a046525332fc84d8ab19d67edc3aab20c7f0cb598d4b3d7b059dba0de2823605f88260f43d6520e8d976ab074d55bad615cd20e349c9090f9c2b3ded770e455e8537533d1d42befc6b17df82e70dfd32ca9059e937f97d2f520dc40e74f90a09b2d15ced530e4820d680da7d860f33698f43f80bcea43008385b62d9cdf92a2a15de2cf579fbc60617316f29557517f6bb7ebb8d3e2838eb5af2f6a0a21c3fc5b5b38a75249cdda61116e42e337658ad7f9b9d09b677dec552be9e695366bc8775b2cdb553718695ddea7f1b1c15080c45da7d2e4d63868bcb662b8240c1a40566c97c6b02f81cac777f741cea7cee4a6d144972d1b9fab54a70aa92af626fbb835bc15b04243317926d84e6bf5cb451c449e9e0a6c2b91b8480e1c85157b4c7dcd5e0634881fdf2027daecafb10e431a8e12812a5d51f6bff6f44c59ce93627930b20843c2d34de798e9b18d48dc8b049b351c99530603697cc6af334e8d397a5c060c08a41ee074d9de10193c270f24842e7c2f754bb3e0648d7d9b7a085195ec1be4771078cb01961ba41710ebdabb6e4ba96a49f1d5987b464dcc4a9d17a205008e2aeab043ce95c963e229c958f749273f0ebbce579bd50d3f34c6114566c86f261a1444d5ab1fe661c956daf60da1440244650577316a3cde17b398b8b0eee4a04127f8425e5b0359eaf6311ac17b337180c50e724692fc6e676827b21bbab46bdbda3fe64de1729305192f342993d0dd8d47c6cdbee0311063f2005ac2497e1a202caeec086153a86deeb6d6257b26614d86ae06e543005bc912fd171a352992906f5cde7b4ab8a2eb84fb5b932d2d4b3be265cfdc9b5c40bc69ccfc4fc9d09338efa4b85f1aee03474feb5993e96f13ccdea23325db0d2d7b927c82f189d5cf537238848b8a25356d04f72ef84d0a9584a08f2968eb31cfe47397b2cdc6d595b26d2b08a93dd1a540fc8c7699beb097d78b0dda45747c2abd63f5d3422b7ea5c06b10d18487d99aae023d4d9e8e34b098966a2b96994fd084639d3dba8a898716269a3456139e09387127be96876206fe57d6193fce6e554a3123f9f620320272b4ce5c522cfcb47581fb830d989c7b53291de2568fa01bd718d7780e9015a7c533f1c488fbe90f1045c329b296c45f1d6f91f6a862f34ae8e6453ea4bb0c87836d3aee6ea7cd74c670c7efd0f3df92c6dbbf74192b60102e2ef846c1594c765f072f84647f26bade86a1c68438cc10ae0cbf5cfc6b0840921d5e6f820be699606c13fe5e5fe0e0a4ce02f8c06f678323159d1c6b0d6e0a2c42ac1df04c29828e0cde64c2ba397a83207386b81114a7626167c62d583cff3e435110e2b87eb90594d47353b798f9f68592f568588c9f3157f878fe12d19c5be93d03609c0110a329bbaa9ad6a39a64fe8e91099548c4da436b62c14964dd582829df757d0e43f10b601d9359cbae772a4b2d30eb9a2e52b0ea8f68104ea90b2b31be165a1983639b4d7023e3671e56b6b07ceda9abc5abb334fdc241db219476918a3ec54a26a05f56925b991f9b59f283d858435b5906986be588a07889bd9bf3008b851e085001c7f3c4e18eaa1f21ac1b6b359cd3fbaeda7fecbb61a59d1e5a5543d784159c6e09742aba78e5c6fa9e6101250c71aa423ead1ec7bd75bf16f915c4fbfdb04851b0a069e343bbfa8e775d8c1403587414fe509303e56784958f96d69bfd85c6e3f57c5e735ccaf607a68071a70ab7ba47cf15d3518a46412683950fa61f9ceaf6f22115ad35c0543559dc2384d5d8f3b0f13d7409769b162578fbb02069193de4ff319c3fc93c568687fa5384a3cb4c4c4060d531fa11e1dc36d5b35cede9b6d71e21c5595a9495a0a3e76323130c7ca5caf3e213318eaff519322ecf8364fb16374ea5bf26c7675bd1d8b18213bf8a68740a58df7d358f53173eedb0ec7774b47e8d096479c3c62a6e97a65031cc552548c7b9d89715edf22c505952b884e3341fcc3bd6d7c40932983ff6913314bb74e2cdf22adf02b4937a9e6fc82d88a0c6c01b2e57e9e650827f8f5c4ce4fd1f74c632b04c799135cfd082cbe72c7c75e0344e9d40a90f200ccb2251cac55f3dd9e058c7696cec247e62f63d65752f7892439353ee27bf726092edd3ef061f942603a5b533901792b666076a6a49d81999075c85d6e4a4fc4fb308a26fb242d7591cf6b7e186e269e312ddcd4ac507fc0bd3fdae52b17083145459e94af7536d63a4efb39be15562406268ca1511ed1c9922c387b9968fdd483947ba5fa0c01b0a0074cbb582fe4e568264449e964b5b3a532487ba2ee2181221f858842f109502c4fa4cdbcd8bc45776607252e81f9309a268328a800b49d62eb2e5c7883ac82321f82d5918406a08185ddb86238d5545f3090c93bd0f1d8d3bfdb0146607344994709ecd67f05bd0d5e7452243888ab1de8459d9113a6d692e5e0d252007d7271add367c4bc9225fb0ffd89381b2ec549f9cf2eaf06906c29e3625c493f58db18b6ca7f799b62e38d3f61d561a95b39ac78001a658674e8f57c3d1077d187b1033c526980071a6d2ef48c0a5df0a4f7b44ed500d512b1e5234e6c83f39218236915b75c793e1d8b99c037955a021262879d74c8d30af4abaf07774a08cd23eece2adbedc59e4e9896e65276f461a8948ae08bb5965b78f93dfe607a0ebe8dca8de636b555608a723c8eb017a811c935dc262be88ec32fe4cfc8eeab70eaa070e9ee1f062cf4da9c7950b97ff7a3c8908366abc6bff7f54854619579b4a3a4479fed057ce8c115107960b34649b18aa7751c06db90ca06e1af872d98e26a88669da15a1fbbbf47def16bf7b0b7614c489cfb28c12ea67d893015820abee66265bf8679d1041d964e55a2ab601a85edf61f6dd48702272fc5ea6c8f2b6e258165cd12335e987961e02a32f2e51578eff93c9b4a2a74ea3bd4fd433e91d87e85879d2929175ea738d13c79b1b625df792e6db7a7311be48757e66d2f09e94745b2d7f326a663f6584b0e0d8a5cd0a815594b1946ab9770e184219c877c7da3b3edaee2aded8e805ef6ea37aabf5527ae9b69e46ce984437d491772d75240d481ada3a48af02284b67e171b42ae751481ef3a74946fb0ef5defaf42e726f66ff779216aab1b35b66dee05aa43fd99429e9ac04d64b7b21eebfe9aa832cd66f106262aaa2f1e64e7639d0f27b7dafd99f391cdc1d5f879fc8771dd7eccadf0c4e336d94985ed2b80a936fc5167955c35a11a5d22c7fefc687d7e716adb758644c8944e02422989e0c85bf7544ec71cb59325ebd5425a9f4090e3c5f9ca04ac55045683d4385ec736d35c35e61a22bf888c67a6f9589647bd10b0c7160b44dbcc74960eae04eed3ab20558b3582112b7c8813e43128232eb22c70501e7344bc37d5647a4af3867f7f1c1882ec45a278e8c0dab701c18a915bc5e404f802843e054b52304d817fd139fdae6126f00220ad98d6124800b605c4fb6e319f5f53bdf91a861a7e8bb6ee42681ef69cedb7c3daf58fe2526beffaa3588b4d60d04eecc227fe74cfbdb646690082edf309e7e72d23db6d834585894cb324875c244b76ebc2dae9809df401bbd6b775c5eee59f56f8b1b428f18c404ed4221119d6c4881af93eea25bdc9bbd54034556e057dee3e7c5247493b74e655cfee4bf41f364b5b7ca563460714b0c98c177de8d7cc4ba72b2820441a8597e71213bfc4125c854cf1f711c15e725c393c543b3a1c112b9008f259ae8d6c22e927bba50322d29d5af992316fa5056405cfa9ecf62889da37689b500a8ce826fd86b134fabeb1d0e3c903ce6af95e1179d094cb3d10a2c8df3c5f92a953bd59970400f6013238d80a24fff4488dfb1c25c4471793a6a519e24d6eba7d56be93aa3494825c288ca5ad9362cc639781c4ede3892dce6a9fa9b2d907cfee6fe59e474583e2a7b91183be968cafbf5e53341aecedf44578534975e5a6058633d0b61a87059119c6e510ecda1cc30f2b48cdc1ebbc0d5ea745ea85b0ff70f2536bed6153c453ffac3ce3fc8f553d477bed51e677ba5bad3a675faee08ef276d2969ff532202856fa9e162e7c5bc009faedb47b49231107858142b3386c72261e6a0805f557a7d143f38c47b4d4cbd59070f3e4a52e20c34620799589ce140f3ad87e3af6bcb540b47b1566afa43440c66717a1c31562e907cb3c5b56d1dd6790a7f381083c4107bbbf8aa000993688bfe768ea131d813cb9a7da90dc483f20ad36f36a73a7d9b0364d89c2edd563fc59afd0eb5f79aa6adaa226ba4a9dd5854a3007b1118b824ef75f820d18acfbde6fd238841d724234a5fd3eb4217ed82c3e85c92e4a731252a40dc5e25f01bba2b0ff298734cd3216a960c88e4615a0ece3c853fae8edd2455708376f288c532906fd5b04fd271b2075d39852b4f2dff7e452d18c88e622340fabfb56ec7ca19b65f7503d569a1d5ae726ee548a433ca5fa9457a6231bc902038b36f252c75d24a9869bcc5d40aa97f709bb6508c654b8bcdacc4cb47c5186e812e94bded45e772feeca7a597c920d7e45a05de362705ceb7fc4a4843d9386437b5632372e97313719e630dd1bda24dd818c9384881004fff9eb5751d43fbf61fd865bba366752094cb186262d623d168409b6e3a8a16f82275e1871b4155e04d0228f39645a8d5bb0f70bff8f89755999d6af085bb2f4c1a62710645f6c42676f27f9a70252bd7f7aa1cdec0ebcab376be635579c119e1b3bc4782161268c2864ac25a1ecf3c17c233d2ad291dd52e8937e5ac2c933c26097920ca5cb97630eedd682b9547228ee6eba940525e213d276c5acb064a616822ec6303aa1254cc25904ac18c3eaf83cfb06e6a7d3da73ed5cbfed4509044828894460bb90dffbb0a52ee906341cdc1b05189c9536722ebe8f6d9bdf98b68fc81bd0cd649ecb86251882a42a44982724e66b2fa08debac73588818da02063af807dba2442d01d2b64c919ac96ac72d77bb92d81d501013af1c54e420ab2136fc009e3b6cd5e8f30135df9b3ea6764118c02e39802d76d7c9a6cddb6606c640c2ef3b3c210e63ba0e756d56249724c2508edc6cd6b93cea9f59b47f286f6b0a9e56a768450005a090c91c9f46932d70182d96312e35cd5d1d99cf187f6cb79498ed978e77473c93b8ef6087f69a8a80dcaf83f3efb7f50417d047c6a8b4e7202fe221bbdf601fe1602f4f44f9acd5e95dee413db85fe9c12b4e9adc7b4a2b35e01962bbdca02679d14651fdc88e2fd4c3a5d35ba833f15f6004009e07417ad94c6a0eb45120e00bcba852e5f477186d2ce16d03f03c5d627a34940402e20f8a4bf16ec041426e026005c7e69ae7bec93587aa3700f00ddc9a79021dc76ae4ea7d240d217470e73c439497fb9c4ee1dbcf43f59a1c813fd86ecd55be7457330bcaf52522cad1824a0c6084be4ac2960020c0d9932b901afad55cd8b385e4cba642e4298a9e7a97bc4376f11ec442be2315871b276487edd9b60c36b5269dce16c201a7e18925397f963befec93e4103e8fd69ab1d0f7a1ede1b529ce57637cec3d94323d8c33b6e361aa00f6f1c05a5d6a383674956624ce7cf928c40d76a44197ec18c7a7feaa975ab5ae8e2a29e2859ff35b8d6e07f8980b0032fe7dac6b7f99f5b91e465d3cf285dbd39d4f8ec06a800d3ab3f1d30ea8e425a2629dfb75ed17395768d5ae67d8a2b1c3267290ff2e1c29130b062a363913d56849ef21d9680f1deac8dba5172bdff3dc8fa74d0b4de906d0723ec32d3a5b07806959b315ee5d5e11105b5061ef84f4aef1917f67508f7f95109a73f9287484b5ceee6233311d1397bbb70696895ef7723238e8fecbf5a92bec5cc557ffaed4d6f4e5f1ac650880a05f3ca2e0d87252170df6146af40791fd88a5f600ecc62c6767992b8f5f0e599e570f07d917db2e477f24e45a33eea9aafcfbf8673329a3df0998bc873cb3e1b60ba9d314aeb6cb4295ea4da32b4bdfb0a6ff","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"2b16f9e9479bcd8e2eed943fd9984c29"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
