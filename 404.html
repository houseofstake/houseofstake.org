<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c246db3630290086c74e07841487ba9893dedc865d84cdb12f3748cbd0c61ec5eeb4e96cb8f4275763aee367e629ea60302b0ad0527d5ce0c5de9220e065cbef34b271b7e837fe59756d382d917d573547daafeab8bf37f31b4acd7897cc663ff9a39cfd6112d8bdb46d67d855b3a3da7e0e9afb28b830e153d6559e75f914cce60379675ff744e984ea410501b6033fcf754f2500aa1d5b67f426bcff2dcb3ad75452c02db5f5b473b0f38b4d1aa83223b0d502081c7831288c028f03bcc6380d1c3f1d9c4c144ef433b170d2807408d2f2a9896557affbccf298480c059599e31ea555cd26086ebfa568047bdc691e698e8e6b30f03f0cc79d2e3ba89fe722e027783ba350dead06204782fde6822128e819df65b12c172e412011a5faaa5e80525030e7c5d3542147ef08de42016ea5f9c5961023c127bad637f46739a2ab374d1cfb33bf04cdf8dffe7411110fcd51c9549002077ab5aa1c3574ebc859cc1c6fa398a6083bf15dbdd66b4a0086acc0869a43026558c9a014a17c748d79bc8decbd5660956a9bbcbaef5c2aeb5fb0c89360b0492a3879b4f34287fc1fb9fa0d720733fa97f9387e99b290f4fa38bbd6b0e08ebf50561e868d9e01a48031185bc95306348bcfdf30ea9c6873ed056f80e9168e027b042f188045ee8b6b0ceeb9671ee1901a492a975d7e6d3020964f51fee4a71e5ff1743c6cf0c7fd52169ffdd1fee245247b9932f5af5defdef41c101b6da23f99794961a31b6739792967ecb81bd490d4720605fbf12f81c9422d604c9478bc1936fb3a09926573e5474c8a560ba46656559792f91fa6a4104727cde9b93e2f79841c1554e0bca1131b835c3c749415b20127dcd0fb3d70a7f85bba352b9aa2935baf9d1f079b0b185c864e85567981ffe74fb6fa1a957f404ff89b9ba73e87b0bfa59dff5e9ecbaf6dd88bfc3f485dcccb26c13b335686fbd27077a548d552dbc28537827b0ac45b06c89cceea906eef53a1b2de85387393a6ba51fe1bcf57bbf190a31ebcac6397539ae68980629897e91ffe657eea7b66db2a20dcac79af36b451b4f37dbfd3c7c5e3965b4800fe29408ac58b8ab757b0b96f703efce46aec393b7c5796e7ea1ef72ce87cf3972efc53f65bade02469f8607b758e3fc04de0b51c7de4ccc0fa456d0c8f96ccb15cba0a1edc6bfc7f73eb209542c82a43efd1eb0eb6b7a4d855ce4b7463052a61e599c62b745668d5e6b7c0d412ee68ab1d7341bf213ad082a4817c3ca826af7c28f30b2146997a02022f177990f1d0058b9966dc315ebe1c7616a4a5fd276ada16a54f59df0dda437c216be55b15babc01b85deca71ef9d2fa147812b1601c2f8bfa0f3621b9f535acf1b0486120c6e12d1251ba5d30c73eacbb4636647ca84b7d835ce558461177830c0da6b5e53c5e1fa5b836ce5022b13e92a6fb6ec557069fe84a41e3aaeaae2e760fe4e6c9a0059584f45973e30cc8a95e7d24bebd6f955a64639ffdb49c930d3d9845c78897444d61e49c6a2e89efbd54a36a69a32b3fabf902829967f18f03c4dfbbf4d828e962bb5aafdb184a3d72afbedfcd3d71f52edfe7f74f0d1cda9b2f27047eca58a792d08f7f9d2938eb9675df8fb41316157cf98e5957113d9ce29c7d23e6e97897ef641ad7bb19ebb1e549486fd3624f9ceddd3f4983a1f8d83b1a84923172f87090a9c37397c47da3abb78a301879c685b19e9de0e8790e490fa96ef1eb975499d06f0070c1ec1c793098ca3b1e9c40e5feea56034cd8db1f11a113a34cb0ba3b40dbdf58fa1586e318ff36fc428f2d5031a5fbefad8a0fa0339e272860aec1766cea5394aa5ae94280ee7fe3a2700d7f611ba9b41ae81eba944df297b6a42b647e5166c13232c5c618d0b9f89dc580bed5529b5b9d7fe4b85de58efda6357eaef7834a9c47643189c79a7b181cebe0e36f265cac836c4c578a412353a537ffc22b9b88323151274fddcbb6ff6f329de1025d5acd29f1a65cd7ede5ee0e40346804e9615bc8355fd0eb154b5bf240b47d1a2b12cd94f3a33df24bef0d5309489aac6f7fa15fabe84b65e2fcc5ddc36f85713151ee9a962b52a630dbca0de04961d15a7f7b8f48d1916a70d13cae9b3deef81cf143b737f327bda557d21c4cce879a9e1c2bffae422dee3833d08fa7a91e28dd951d1569c3d78c1de4d739ae1583a3f6eb9899faa54cc36516f96589fd49e4cd823f4258dc81163f61f27334f9889fe87b1475bea1024143d8397a5aee0df9ae0aa9fa4e9e6335132372b8c51a451683fe22c9fc1aec26d8eb7a7991f4b9fa53590a216a3e046ab64bb38298d7523677beccf2e33423027d0619b83a3842ab76a09564b235cb53d6b55dbdc97f4754e01fcb70aa0fd1395b368fa8af69059a646172c9a78a5fac10c31b19717e8877790a61b3d2a2f7cd622929c27f75b14e6c192bb915bfdf3855d73fb016d3c768f2294ecf0820af7161068285890225b8ef538d61862452fc59352124258b669e49fb756b037e778d9423cc32e5ed3fd262c74d12b8b79dd93fa4b7743ed8dc6fc6872d296163a095240ab116e6b912130630460e14b41d2d2322760cc52232d2ca5417ce785a1ab57d192c65421eddd5b3b852073fe60df6023b4dd61c34d31efb53bdcb8641a8f63b6741a0ea7f8b8449c49c9a99fa2dfd07e2d84ba55112eee2f8a63d4a7b07e2c1e09e7808403ff24e5b8ef1ae3bee5d83e4cc24b7454dea7003c4059ab4b9bf24162a38c7e77608762fd98320998cd66da510abd6d69bdf471ae31e0baa88c76050440e733e89efbe40b5a327e40e0a3fa98b0a65af0c6b2338fcbe1cb3983aa7fb1a54504172aebf332332ef57dfc2a1de6f2bd6a1c1e06d9f50c599eacdf6274f9e739c01f352f31092f30cf529e92b63055e7c5bb5a069c67a5bb2dba24f0f49aaf4911c9e98bec5f50ed7610a3bb40771f005dfbdd50962d09eb025e8be6052133bcb7b44733bcfbb32ff0f088e8546b8d5ba8914188953d6563df8e94ce41705a47a72992d9148f971fd0ef25cc2f87ad8a8beada830402047cbfe5c5fb249f105a3ce93ee727e023688ad5ea8e60b5e4316c9dc03b731c92d136702f4dd61f9193240f3502ea2cb0ec257efd3e52a1dc712ad8e5ec7e470fab69d03ec6ca5d3cac13741eb00ae8e98e8d6b477ec35bcf11fe32d7602f23312281501bc4b4e06563333af04ded5623a8dea84e8a55f7bcd07768c37d18a7f9088842ddad495ff1f1bc846bd1e3d1cc0d1623a73f613e12a79976f31dfc249e5403f9b450ae0192073f046b3f58e7ba80e8ba201b3f8992ba90fbb2863c709b5800fdeb422e076d89ba40873d0e291dd75b384851db4748602b9050fc127d92ff748b858e746c22a631191c818ba187bd2b3d8415b0f41f41b58e2b5b6aaa7244ab53ef158e208c564dcdf971a9326578bf1faa1f9bfa1c3051b9c1ccf0d0a243499d0cf98d46b9f503600b5f6cc6e4a5ce70dbfbc9a57f6c6931c97ef7f56a777532b36fd6c51cbb142e2f5cfbaaf42e378e29b4d7f6dc9ce81f1dce8297fafcf22955d384004651fe16bbc495a10c1ebfc42de3bd58b85d632f4e68da3fbf4b1952bb54e0294001d532e3f89766473634654a4409401b3a54e4a2c5687a291cf46b60418b444f111e20cb99fc382a917bed339180af26a69287edc0faa14c1002c482ba542bf217bf04063cacf2e194c1ed9f0148eb79ca6121f2fa3e2455f6ec586810d66c0bc9405035b91558cb6926d4bb9e19a8818d84377e0da3f95d14209ce50c9bc84030866f4edf0b409d3a334bfc906566f6d804f29a4e5977b6dc42b6c43709f532d125d17a823e1bc5d9edc201d122723aac7680c0aa4e84e5abb9f89907839642242dacf0b07a5bcc15d835dc672ebc957d80c9247c8e664d7d754e8979dbaea41fbbcb888a2caccee61c228709ac23001d23d5d151ea7af244ab0fd4f356f58e640e878d2d40eeddae09f8dabe3a819ebf846afaaa035cce17d34baab286bca9361d702ac438a187b0371e6e65d33d162fbc464c51fe14ff1ae628ca6262aa1dd58a8393b3259ac68ed1bad9cf1ab5b0b98532fb9403fde7c6095ce21cc7c4301433a98d6fffc1cdf2bed4b46f9e3cdbd88566c006f8cace113ededdc73eb271794688f4dfe9b5549d8625aa34b8e450aac0cbe176cda7bd0f16966e6779d34620df116a1b7aaef0a206965812ece4195cebaea82511824a3bbaa6f7bbab5e804da76077e0423a186ccf638235f71796ae3a669a02df68774d3efa4e98f2f3678832a575f85356cb028cb0f7e7901f99c035f736a0c1404733ea0ddab817f0f5535725132641cb2c880e1d934f603499b5bf60e068517e8456927f553fa710ba6abe5498ad173d9eea12f9210ccbf4fb1bcfac7646a3087c635232118a7ef21f2b4aae50f662c40dee49626f9ed201ed5695e1cd20edfe6fc5612533d4e3c48314863b327e1d358cc861600a7fd89d653b39f111c02c10dfe629830563295db3f6d6ceaa9d9940842e882de59252ee19438b2933b6f2db58947cb184a94aa9060c4390cef5787680b1a36b5e25c04631263663d0d789452c2203f969c86c16ef61f7351633a310b7f5ffc26adc7b3666164a26b44658deb2c28a81ff0dd5d995892dd6dc3656f036c4c81a2dd3db4092add49f3dd2018cbbc405db6e061084a652f10ef3c95ed9cb0a011874c7962bac8a1cccf2fcceda20a646703bc58197b6eb7542b4724f4993f104cc4b7fe6c06a709c18677f8c78b25d7a13a196a4be7b90c9fd38cee21bb444dab2030825bd6ee3b84b31ffac268b30f780709a1baec89377cba40d80698649e95a777438c1151e203d524eb7a0f3d4c4494e930d93be1df1ea62835255b8577c79e66c75c718d5066925a679fb393d9a5494b101736377c75205347ae03ae11cfe471300b7ded83226d437e686a022da35fb90cebbc9c7a2223fb514217d717a77a6d3be8a6d7f19326c4bfa7d686043c909c338a78abf3a2c52f3161795c0341f7c6ec1e06d393ac53bed57ddf25d45906ee23c805cfc5331184245c2b23f25e41cdaf4e7f90153e38fe365c8876b83dd84072704b8420551b5dc4d091c84e13bf064b795d22c8d3d8c5445653ad333e5c89edec686d30ed725fd50a4f0b27f7617803f76a4035fcce64e92e48a5c0e1c548ba506abd78b180e678df9a3aab0184605c83c7c73b9fdb5fc1f88a1308dfa2c26c92504cf833b262b96b459c4b23cb0cfdeae853df50446ed4f72070c228850aa8d0264f815f1a73a646e17262164b6d49d14def13b00108cbf96becbf9002812a5d3741ba962aecf3c79521e55fbd8d6305a0582589c96e958f128fac2fb96dd5a72f87e121d0b74101fd951242e57609b73f15ae4d030d56c2b73736bccdf12812cb5039bd9a97bbdc323c1c274e03536fc99537d958d09fd4796f7cc8bff5c20551fb5fc00bc5b1d8680e9fc33baaef3a32ef749f069e25344c46a621c4bfcf1f1891a8a74b3955894badc1f851d2ee00324e1b773c1331be73717ae68b304fa7ce29f7b1f1515a2195049d6af944eae6e593b63cc6dc9959bb18c818c605285a1fff1a8c4ea0cb3eb177b48a412bb22f196b8f3d98c74fef6a4d2c3074e512cd4fa9175b1577acc0e19d13e1a006fc429c463f114aad99b9f3d277a822e3bb5e67fd5bad2d29eff365c5ca0be5c006797f62eed25ca44f944f36ead20ed283320500f876cf79b315fc38f69e0c590639eb444352b7a21bfcf508263cf54475351114b2f86ad6c89d83d2e6d395eaaeb01dd25e04d28442b72f81bee6788082cfa82fb8d4f29299c07566dfce03b91104071ba074bce0e35027957407300cfce189f00b38d3cc2d97452589343a3e1c3bba5a47957128a87b2a953cc526faa1fd2bf7fb2ef34afb4d6201b66440c45243de9f6347b2d033e32fc6caab0ad72ec1793ea508599adb10f463fa0fd1313bdc6eb852d74374c1c6117cab118cf5ad17105facd58bda0dadd5c292af7464e92a56012334ece4ef22ac9757b88dd17d9c48a9a0f637bee6cce62e6d112a940fb32649aeb67802bc137999700b54550e64a739f31b60d4c73b345a8f7b33c8f24fc54f239534ac2c6f699c1429373ba4a6815cc4a790b6ae9c5fadb1db1e18dbb319a86fc7f3278afb5d617e07e34859438d9662261ae867d60eb1f7e83f27e4aadc2ab673264ac95c05f57a7e3071473771098e204fd69d695c4cd41e50e9bb4bcc1d5fa27b4376f1dfb40aecd708e144a8a9d30c13b26ae60b46ea0a352559454a2d076b471c5c6632828d14c357ab1fe3ba912ea001e553240eb5ebefd7cb5cd7349fb883e78e875497286dc61d9a46762925a2120aa02eb638d3d64820c573b72915058fbe41e504750941875a40bfdd3e9625ea1d4668b96003342a60ce89ec4bc0ab91502e6daab873cadea465cf05a3f62b0d3a9f11dc8630c3569872e60b446de43b88628b3515265c8831a6658a05c676618a63aaf781d2631237a17e8d90ff64f19636471ca066fa3aeddba204ffd70b13564664168ae2e944a524ae76fa9e83b96f86bdca69ddd1d6e42e770d0c55f50a168990bb9a969e8a9fdb17c46a77f90febd2d8ccfb1c2535f01e31ddb5e5a240d1da02185a10fb08a808142b9f2ffbc315bd3f3141e7d7a71675ff8674609e610428e939dc0d14c384502268fd4f546e40c9764286544f9023dd1c8a9062f028858090adb81cbcf4adcde155f4c9cc7d29ecc7bdc8ac38b02f726386b7da11c65afacc5d8bf8343a894eedc9861fce9c50dcbaa86c567e9db0ad6a2f09aad7328e0fe86b9e08efb96d070c80a40a1e223e9c9a273a957a22c5872b56b51f3aedf168602e9665d7d50e13398a2caf0160bee57a3c7d6bfe071257507a7c5d8639bda0941f86692e6a8fc49f718c18d201458925aff5a9bb9bcb9d4ef9f3d54d47f2a4129a9ee6b20af7e332f25d0d0cb7f17795f51fdfe30f8b65a8b0c68af393b62df55ab863f9ec5dd58439db0509b72aee09d693cb45d2903e84e16c586248e7c1d09c4b16be6ddf38ce783213151a890664f1f1881fd1ea4bb92582e81217c864a1f9095fd67da4ff52c9e89c6cf2d8595fa8526b74ec3adabc4dfc926b92e5be0945dfe8d7f2b708cacf3a58229f64251b612001279277fe5ca6a15277e78a9991d894d3c4e51b97471672896b5bf077740127b06873cf4db5aa2a1dd8f8b8a64c7978e4defa91e6cf9d70c8c809fabb132286b171487be2e6e03d60a6616e951afc707453243dcf58afa63f2a6b5f0a5671951cd62ea5a2baa48be39171570ab692854230cf707775914ab1b299c514bbaf0e9f3aaa68ec8b1e864181822991032780bcf2b5a11e7782f67ae00fe4b73701b419778cfc74d4a9e1ac78beaf2ac2ecd44b88daed26e8dbb695626a1d5e9b1c76ad9cf2d6c1f96255350cd03ce38dbdd2f47348dca1f2d4a7d8fb3c25ebba1e2b854aa48dbd2476da4e49d5b3a93f987957a162d4d82abe2095bfa642443b42ffa368a60a5db2d752d5252de7cfe7a28184ced66dde1db34ad08bd49bcced9ff8cc5c002240c5c3eef3b4d7ff5854f7fed78c2688e2a3ea9495bcc27f885e873ae71e4a03a92076d9126bf8e8030fd14103b0787a5f089426ae0cacc127d2c629d87ed60287f4b4d160fd26ac3314eca269d9772e18087aad611c604083a7fa5979b64e1df8ed47d1b2c599fb1c48c292575aa00219a4a5921d88f3169ba75ecb86ee628e63d25e937c3a4c38d3f07293ef86755563de26bb1602f88e89e57e28cb9da9d4bea3a25004f1db0f9715176e4de8325125e7ba7dd16ee17508eeb297179f394be177d803bb865863ea22a0792d0dc44148f103db3c389e1cf88d0d006bfd651cd6e2f157ae080415762ca0ce9fb2a05eaf2e56fdcc8f08bd1f4e191c2a38b85251544fe8c6603306c64039e92addcd20dcede92f1ea8d77fc75f84da6d558328da49ebf9d58e5581e6f6a929068a4d79dc705d4b39dcb0638307611aea2fe9df13f8421cc7f04f55c1265bc256c9c20acdb65a96089e37a5417e2939faf328ee776e113e80a92c3eac6f85ce7a095ab2f5fdf0683bfada09dc19f941906767f31f83a46468e0c3c38b4b3995a068a759d8f3566c74eaf933bf4541089fcdfd39a142e9d1c1d0fbc3de8355a9fc35c6cabd203ed43fda85e7d5be14f108d606cd4c2d3c629928c7b55a9b08280fa644a65713eabe477ccb94a190512885498093d1dfb0316d13df9a2312e17cde4047c069921a515d7c90b90b0da0772eab08bee77dbffe60ba20c9ada60891bb557d5a1be862de1501d189eb63cd00ceceb34bc0d421f4e99d55d471149b3c7271eb2ed22e7c8d0e030274f49c32ba134693f1e58f411b08f5d2dc09d6c177ca33dbf8d5e18e3e34444703bff4fd74f11525cb44be2aae0f182e00f457446c71819ab20eaf30738d8cbccddd30e8e13698baf530b331bdbec48163432ad3fb18167ebae7ec26e0769d0accf76efaf0471973787ec67bd7598aa382627629178b434e5dfa12731fa25c6532f4f943d2fcc54de78cbdcdff10548c814d9d1d63b2bcf8bcd83d598fba7f924ba229ed620cd0add544503d77da5b2b7f069c2c0e5db7f7f818d868e914f52939bd42bac460b27924d0e4e298586014fc9be47aba724fa192f23b670885c601ba2de501f9f30b85c33ee7adf381cbb144cad2b049b8b86d4ecd4831132b2ce56ac6e2da9f30d115db6c9ad250e8e38cda28ed3d35bdd3086038d8d081d73821f252745545efb1c5434a00ea7c47cdf69c47e53cf12029da6c514a0c12d433f4d460b079a97b31df17eb8957738db7fb4eea7ef1453c011d91694adb628462aeeb1e182fdc0bfd2c3f9acbd08cb19fffe1b35447b565e02176e757d7aeef77121b92e891719a8325359d3822621198bfa3b49ca62bfe9367acb8153fab603aa9d5f0989659daf0b0130776784c9e5d5156e8f931d572ca20e82ab1abe5fbc72f2c695ac3fbfb5faa494a4869501763a499b061a570a3482414147cee7b9c7cf947c6969be94c6effdc0bc83b4f2b58a93f12205763a4438cf36a248e08128aba788dce06db049b638e1f634a80f81fd94b1f6e144fec03c191c0ef8a5714a4acdce11459aa4d4fe1cf96e2436a82337cfaebb1dd1418d6dd49f7928ae7e3ce31db3191a8a24175f6a00d310b548135fc8d97d790e9c709ea35fd944aa76bd30b8f98c6ded9bececf1a7f625c077421dde3aead5693774c7760658693b8420c46f1cf42ef8c7ad0e9c353e9e1352d88e11f30cd713e0ab0d27f16b7f8fca5f14d8826004bfd082a55296b6ee29fb4a9dc5c2ce4e35bef09cd253896a6ec95780ee49221338a98140a7935f0d4aa5c915a3de0b9a0d57d5b88e2d69cce495d75ebc3767255d2478943cb62107fa4c949bf7f20693137f47adf4af461256d4e3bb3c915caa43bdb1dfc9555a53e0faa800aa36ea255f8345eb796d661ab7ba980863b97924e64d274c535fe6cdca067bd32b561d0d9f80ae315104523c26fc108053197a1f5a44e2333f0f4b6c0832495cfc93c88eaa605f30762ddd2c5bd99e32405eded7b042dbe5446dae862dcea574ccd40d55cf52ef810f41368bc7b07d85179ea82d17f84b8eca2f27c5626fcc9d7f44665a9582a6d8747a32013fb0b48cf59f172ee70b4da810d6d6f5c00c52a4df1d03d3a57bb2afc8f297fda788a472c49050453aa067e75b277e466a35cf6fbcf00b3c645da7dc12375445bff855a0c606efacfaa0a9c7fac2c7d7269e455c3b3b36a39f591bbfc3b9accb9ea0623082ff4464343f7f209cdd403f1ec7fe8611550bf63c385ea83221a9fb28439df77195b46bfbea529f2288a5d238b22cc3af576601bb8cf61cd4b557bc47be5a0f6fed2d5e1a4e4cb3664937d8ccb32970e2820310b7eb14a4f88370c43a09247563f8db86f32de6dce584e4cb318eb99a579663fafb659339c402c91511391e42dcf7dceb6fe50318afeb534cfa2735d49f35ac9ebb1c47741158d715797f9fd842e03546e24493a64edb1ffe74c8598de0ec9d76c65c0ca8c91ff8115aa20f905a242d938180f0044acf0ce04de6c71a9f5a7dedaed0bd37dafd76a359cd801baf7cd2f806a3a2a98b7bdcc7380ad16e1a19f300de1ef614a927579b4c07955ec1fe88e7654ae02aa727c37aa41cadc9998667b6e1f6b4353a3d866edb5e927164845d66b23d1b61736ba7e4bb8bea82c37915fdeb05a2e03e0f522c824dead7620fca4a621c0e33e3318a921a41bb9f7986d748d177bc9acd33d9f5757e63c4ffdc1231d8dd859ad075595eb79d133d3a1eb5dea22e81222d5d198dd1d5c5c528b93e6eadaffb535e11f10776fabca8804e1cbfe8ddb963a669fa00719a162afae637f159b1780bef5a061fb96c1ceef30e16492878135045aa1cd0dfd29f07e57e1e3ee3d7c3f0f723621d33342a02e1afafcb351ed3c79b9b31839af81f514ad73d14b5757818edabbf279c7562cee95eacfb1b870f625afee90bce494efcfc059cd3d3cc575763de66dad575ac0288bb05f59d8c58ce381ac3d8a83bae7c88e3eae93dc93446d9ae24c0acd8e61e869cb4a30e984fd6f4195fadc876dc0c60079fad7f0c387029b9aafdb58a1784fc55cbf58e81560a6c79a8c7bfeb873fb3bf163277cfb947f2e4a99f41c6e25345043860ba6dd8aadf681f1f1e4e5e6e01fab898c2f12763fbbbd14e2d2bf203eeb98ffc96788469603f8b44a3d5fdaaa0c5be60298e323d0f4f01d21af4ab7e39160563057c8f7379379c5ca116eeedcc67453ffed712ca269b83f5454fc0819aba6cf4b3d44faa99b19ba0d8c3f4341f17a95c1c1bc596e4a19e9cf664aed8740792b4adf08854fc652a5d0f24e92e42a92107c888b50c5004eb96a0f4de2d3994fbc4e59be4a39c4ef862caca501d8395266b887ed3b9af4d4c2f8000b8eb1c753c1932fc6767ca0e838f8336c280a1466bdb3b46397f4c352149441a130b947a5889c50d77e4067b9c1749651e80bb198a500d72ffebbbf609751557a096f413de4b03704d9c2720cf225b1230f28a88ba2039f7eca7ce121d4d5e4f25be0a9df1d2869e6dfe331c2698cbb8b77455026a11f0439b8ec32c5888e5daedecee634da0e71ab211f3dbb08f50940a48b8e7e70dec6b44605151de96a22a63c3a5fc64a9f67540e0d2e662964269ca2a08b2cbc1b10440b1738c13babf10203e64ed1ec17868ddbcdf20a55b5135dc1d87774c06d0cec40a0e33184f42df5ee0c72a526984437d38eb3386c7de7774db0e94f2d2723c2b1bf76036e3b669343d92b6fc1e259f9fa387ae99dd2600c1b7077f5effb51cdf6dbaf72e6cff8ac90e77e4f3c2fd074e454af820deb897e3eedca3924e5d540025e568f9c756aa53751e14a6d5ece80de21a856d5abe25fbf30389bb5c14c014d95d74532543fc13e9e3786b4ffe572d0ee0b0f3ae5a3edd81dd78f5381ced935f586d9bf2cc3aefafe3d27bf2253aaee88ce14c4353f2f63380002c3f4b156d3e5ce5ad2f91150552b5354e1274b83cd0fc14f87e110a8dc422112a60ed290de4e35659a2e04eb4ded33803b4cd8f3f2ba1d0ea2accf031e623fbb607312e8beb24acb9bee775db873b78cb665dbfd29e9f22c39fd712b4fb5ec22af3b7dce9d006808a9551c7d5c94f9c8012958e3b390b81e326179db364739c8663e1c17c238f576e6d5c4384c4b7c5e846284a027e151b2a626d2b9beee5e01c695daf5e52ca3fef83a0a0a3b9864d250d3a53c3fa136f552993b64c338b9299cf479af111bcbce3f6c0313d3c18cae311781595a5d0ba68ccdd6c4f0fb09822852dd9f35cde3f178b0cb7c8a1e002685c4bd2c518fc8e1e18b3c75d3eae3389984538235c60a66491056adf468d040cd8f6df76093d3a2c07e81069a179fb79bf25738b0c4dd62e3c9ba8d4fa50dfafb8535ed3453bfb3fa781065c8613dae8a2ec7591de8837c5cfa0dd6f4010cac927eac19b2d1fbf79a55da30e4e53e1c00b5c46500af399c6825fca2219d68ba6fa71eb93b88c2e0042896a288f618e91fc01f6a6991ab1d0e3d82d3c943fc0b3d07be99e7b0a54121a63ed4a7facecd4d519e02e29984b6e41be6ac159d1aee1aa99596a8c6120ca0a33fcd78a104e7a9a73fd8fc01f6727638657bae06544a647435237541c66562685e446d77e2971cc25a0b04970640e930e83a146573abdc627abafba9195a784dd98821ff8f67234f5508a2cb25f5088691bb23ebd3257f5acb5f471f783a82cd2775af779638e1b0fd3086c52c93c482c0bb1d08f026063a5b1f1a17b98b4e45cabbf8ae1766bb63fe8ebd8bc479aaeffe8e4b2128cea7995406c02236bac069c4c0addd44cda674b147b8dc4db5365af1461a12388148981ed251cbd807a5d519e836738d6b69ec7b00858905f4b8493325a0d340654626b23aa6d8d8a3f64ddece0965e692b6c7f91ce529243a3c50cd8724211f75e1c65b87cfc735b97cc88c6a609b784eda5fefa42c5f5c706d275ff803cdd277c27a1f879eb2e240142ad7a9db495ebb0b4ef46cfb95fb309bc6efd040ba52564043e6858cadeb0ebce3a292a795a6acf535ca45ff9cd7bfd3c5a69a5202adadb452b16507ba44c962db5c1ccefe712510ee981004a2fa2064df2160fddd113a45ebe436c948a42d2554099214fabee43aa55ebd7cbf02b72bc7709d5f1a997f4a8991c6e3de5b31e2440838b7075b1707ce0614618251096abdb63fb70294ea91d2052998fc60e49ec4212cde5ef85ed524ca4a3cc393fc1aa68c7e8b3daa6a8fed4d33d5995d4451f0e6e8e74e5a400fe5c1c728ae71ad29a2c4ad36c37a8c68df35b9701c62d5294393b89680f575d2bff7efb28e4f1a990235b131e648d9c967ee1513cf77429fab8e628352bff851a6194e75fe8e748b0644a9d95edc0601f8a1e18ecf167c9afeb05548bfb164e457e0056d3492a412b81b29bb798f0257b928df2402b07a77d93c49921993340bfcfa99b2d3829a3b0d0ead22143aa1c7de13dddd886e4867a0708bebd98a41a262cf8a66dadd268b23afdd2f3d8a3278539ad2fc08a481be48403d52fdb490860df8b9afcec974013a8ab046c17d6098f5d4e0339d71d327709d634a3583f098ce565c37592b98667f9e9a8319f03033c0c08031e02f4668fa94a27d2a4ce0b4112f98e2f9c036fbb8a822a0f58cfdd207c15ba4900e9ddf5357cd1e64aca17747f63249421413b224052ba96c487099e0e226ce3310873c77c49606075dcdfd097542b6833d26b5c1724b8d9e270d84135efa52432841bd89369c2a188d66df63e824c197e7ae93430bf0c56246c9f44d19fc669e253365ebb38695de057789600dae1e9a0ea3f022e3bc981f5c69ff70f46656b1ac3e7c3385d36b7cdbf0b686f77c6e268a9bf27f1772c70f623981729419d5e7d78561458530b3491a2f0e97cde6890c0b3015e111e096742dbb62ed7d282c0e97e4479c754abd7089cebf000f83632f9fcbabf144a6d1a49d5748aaf9e38b1331ebac09594501c491a98841aee0ebc74124afec7afcf8d73a3768d80a0e583a43cd41db374ab959df97239b125a064fa7cef9f6293a00c249adb61535e1e34af604b77f2c41086a9aea252c3deee5e7f260bd97243942ea7aff42b8fe0244c3d6a05d8537dd0eaf7117c0f2f3a38c40d3ca9c097d539a9acdd67bff7acfbf85de5afd6e4fa9fd5c23f6e35b2055b02a77baaa5b760622c6515fd3c86fcd5a901cc18f5281bcb21bc80bc5d37ddd4abc8f45efcaf73473fee5493f49ae04ec62dfc5ecc37e52563a6cd24fceb323b7653350db9ab40442e5d77344d8d5eb18585ac3c467d41d3a3660043f65a5c89794eca7e29b35c24ec855a76c38671b230eab0393d2822cff1650964eed66df8997003516e8c126ce464bf03b08667d5b49d6ad408f2a0fc6a71cf63528723512243a26ad4fcbaa239b834a851a90b62327e77dbbc23e2170b3461194754ca83deb90456b3ceda4a66a1986514ba350ba2255934c317c4a1ee180f7f2d09250189aa1b4a3b749186412b72d2fba0e8f41f9de8d3b2d0b2cc7902857226568ac4acfeb5df4fa03092903635b5313f6130b4b8d4b5c9cb6e859d316a239ac1e2fd90fbbb56c4fdda53c19aa0066508020bfbd070b0f82d903f35546aa3d03c496f00466774e4960380e242a5dc10891cd00d7edc8eac3a769a6fcba9db696e49c17a8b5a75ec2a31188f23e4abfdf7bfbc2c94f9508f3d33c44ed6a0ca165c19630bd90df50a449f1400d6294cef3b55090b5351adc93","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5772c6c6da40bb47a5b1786c06afb5ed"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
