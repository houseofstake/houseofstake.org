<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c52db239374247c453d53abb3be7a66281167643eb4d69a9535f6832694203dc0ac08e1a58e409251e49806497e35a8e7e54409a8610a92478e69723752243ed21105b4fe16c8230dabe82cab068221d54d1bd50d8729ec72144abc5f0bb3d5f6c07d58c4b834f5d6adde8f41376b4bcdfdbd81565e532ef0b5bc6f2118893000a0b1f581bbf69faf9855d3b04949f4ac4dece2e82d50d23f1f0e114d814d4317bd5668dc389c3f017e97c063042d36b5983d7220b23b6ccf44a4ecfbbbe6a048464c81ab66de969d4350ddb87bfb337492aed44742c56511464794b98b8934b7ff473f7e8d3b888fece616a53a024d121a067d34c87f3b162e7a5d8de4e16279fa8864ed9e8432ba13f35b8aea972a3d780aa310f9c7d3fad8862d8b453e6dadfc8d675b4a87d08fc236e43f8b072b61ab6899cd2a35e17e8127d2501012375a925b14d38705327c4e54eae37dc99c96e49bb224059bd4c7bfe1b6c5e3f7c05979a2738709fb74e90bfa8d50f45ff920c04080d5a960ed8bde50810870bba4522052eb73633c516d52715e7a16dd8284bec3f30d8d6c7b7da65c407182cb1715145763d1cc518723ae254a2e10b6c3f01dda2878a602c26c60f16139c7f348360138c350d6374a9769f9d886f1a2ed434ae492451287252c038de3295d07235be37eb8674a51ab232ec915d430d537c9227e79b532842632724dbb5d3d68c3f5fb0c89ede971ca92a28c33d9a05acd41fa7c3862417d060ade6b9aefd58feb69dc6d914f247e92dddc86703d8412a78ea8b4b3cbcec1f35086244f60e9ba3a8a98b43ab975f37137d358ca92ea21c6e059bd176d6dd0102c945c3b092a807e4821a268430212720a699b08893b90fc314e766edd78345b7342586d833f76ed98f5ec42ad0c2d5751b03cbb6cedef60eca7f3ea469ed6d21acb93b5e6a19e016db326b896c0e551f64a3bdca86011d7aa80e415fdbfd797dccba0312e9c6babb768d218ce7a6e482ab74d9f711d23c29bc3f607c3dfefa8738add7a81191abba9d4d36941f051fa52a16a0f4f9d5cfc7d05b57b0ddb81001e1db21eb48087de9dcef1fb450b3161efa140c71cb9554e5a130414b354a1c24c0c6cedbe477f8a4f06420272a77ba0b5ec1d662a4338219c7ca8caa19cd40847fae2d7f499be307bed9756d5b992eb32a9b0cd7f076fc6600e90e155f0eea639abba4bba918e6e74136a81dc531a7e73643559a86ab444e0263dba5836c6269301f304272b9f0dd13a8f9baedfcb8106ce9695a6019d2338d332ec7bcdde9105f3f7e506c90860974dde1fe2f6091c04a301fdb773f97dd4722520005a86e60b7acd2385b2764bf9a982c1450e032b4cb6dba3cbf8dfc54ec6eeb736cac2adbc057d29d9c2437108a01d2ec582a46afd81ffb733362ff032684e7348ff2bf35f32dc890c070eacffd6f383f0aaf365f15634842ccdcca7355d8f0bfb5ada9caba1de4ae70854d9cb52e904643ab7962e5a42e9c6d55b75c4a70382b6f090dbb596a060882f69d0e422580130559104bc890ff19f5763b7fe0466e7d43744348ece94be8fd90ee75f69e07e7fb172cb1ada8e89626901eee546c063499692726cc1641a1043971dac2b019894ce33a058b6683a05b0567a4f1b7f50896a82e3b6bc79ae864212d6dcc7818c49242f4f1f05b5d7d698ac73f1cd01b655d532ed9e1c0ea707a2ccc01b623b8136080f551802b1af2d67d8496a50767b833fd9474edcece395187d9623ad842cd5689ec9985290b7fcfce509f49570ab54c1e14c6c1bdcf7ca6b4f4cfea19330f08cb596ea59c18fa8a802426a469bb255a484f038b12b59a84df449962cd1a0368a5181f44a42ed93a8ddb4a0caf3727ee47f3806ef611b8f2896fc7996a774fe6d9d380b1fb56d05c6eff5bd80ab7f6ff0c81c26045f05ff3ee5046271fa9802620181384817386c1358ad4919f208a8cda0eaf6881feac3824d883902b5f333f04edf2566eec12ad8c5e9aa35c2b20135332f268def96d5dd6619fb511f0191e7721a24bd047ba824cc5a58ec4e5d8e4823b4484a91954b813997a151551b202ae41e376ba87c85acc8b96522c0849bff0cdbb802819faed7f08acd4673b12fb77353552f4e5d44505dd28255ad458406423434f52728f1fe85c6cc673efa95415618bb32097588f1ae0b46258f4952490e20155d47c86d5cd886a8639cd0b17ba10f84279e7c99e3ca4824c23f48a55bb52734b76e5fb6907be88051e4072e303aa4f2f1e88feaf3dd7cde5d23d12b80c2e4d7043c6cc6d5a72d392ee142dc1b51e2575f66efea6a968ddda7ac90ad666ef1a3c6b9a3600304ba81333474795601eaba923a217624a800fbf0930ce30bdea5addf304235c218680392ad2e1e8b58d831a5b0b72bb547b5f090002e5560bf1a617032fde772c1d933ebdf16474d531919f3889c78498a66a26d8caf5bd12487e934a268d2ae38dde82a9d2b650b0f2ccdcb02c2847a2ee0c6f78b6a8912e90f0eb86e83640f66e0f00afb381d7273c6f7f82c77d542e4c2b9d742fa31fca7a49bb74c8e9c7d766ae39e34cf3b8f574e1bf8b1a0efd2f5f2bbd980db6422563c027412c89a7f8292683b4c864f5bffe9034a483471086bc8415b0b9bd2c4bf2c8747299b1385f6985bb743acd512cbaeaaa242ccee530592edd6f1ec73cf8566e1b3333eadb8084a68e3cef4f211f7dd25096158c61f6b8eeae20083953d842924ac9b6bb6a1f6aef4e307338530f85c416795f5f6365bd134d3338c23590270642f615df848dd81a473c12f4ef079a05cd0045f7071bdf90a7d3fc3723699a37afe955891b4fd6f5431fae9b96c03c1b74090fe37fa4283d91a81ec242a9718c2b4de34126b42898ff31ca2247f341cd41e93ea14a108709e17b62ee4bb143e392c9a3cb1d00a8d170db4d1371d1bd950bd2f3630a3c5f57c176e92ba31632517d13dd326b76fa137d3307eb04ae72267197a00d7b46e8ebf3eb05267aa49af46f7ab84bd59fe2bdfeb3db00c6bd5660dc2bb1706d82e98741f2f233f70a8c0de4684922f427da4fc146904c74bf8a270e51a62f54ce802285d0e7c8023a011f4a9b3fca72f00675417c92bb8cc300bb8734a9e579848da51dbba6653954c315158ca13f64a85bd866ffe1fe7446e997b65f2c87e03c911dd6befd5255791cdcfcaa7f4a6fc445b1c9d2ca266597b43178c49e801ddaa85379a1e90351d943aba37af622e2e66c8d7e9c66faa93eceb03898f490270eb5564aa08def83dc8665dc62e8005deaa04464bb7a312620537b047515d876aa0b1bb3da52960386369d91257170913644b7c57a00e40ab3df25240b5369375c124e7baa5f5101e27e3b570bf3e22f5d0acb0269cf480add1d15ea835e5021067907d7c8237c5bd1fa1a9597b39ec350a47621e8750421d9afc5ce7cb1a04c7c77e4b95ce49b6bac4cf439569cb3142002ac428b23ff59446af3b4f984d9815e28743bedaa7cd282e6a05840aa6808f99b0871bc4a7bf73db65b66ab21b862703f0cf8d64b68fcfc1df45f168af0ec446cd0a224ebdcd9b6e058dfb4899c8f0857c9ab1900643d41e333c3bf442e4456f29b44d3923c9950ebde2803442ff9e1c3a157f6492f7148b6814d1758266f1fc797602ced28db1b89ac29a0ec922c7f56ad46571a5082c0d5d4ab79cb5ae4158e8f3fc97f4c54001d99956f6757c27d49d54e20a6ae00b0ca04d0e0740f1fa407c9f949c0c99dad59adedd2acb3f2e151f1767c1be2fdc43d949ea63a64d378b89d0fe41b1a3ca1ef6d71893be972977698221fb25bc34e9dcde5b36a10546b8bffc687066901d97105276b8c534e01036afd8e7b0caaca7ac1c7d5357c506310054c04b331a40e8626c63194039a5cc2fe6f1ca31a4d610e3c8cde865b97d4180389ae059202230d87095d7477e4649430724855293af6bf8d81051573c0ad4435acb885ff73270814c2cb4b62373870569c330d99aec2d686a10ce5c21db491b8b2e0387935b337e5de6096b8987700b82e345514306d9e6cbf3277c53339d600dbce45964066c75407e231103b6a96eb8dd7f1d3fe95bbf4dbbf7b4f4c533c63bca1d84603afdc4c3a5425880fcd3442321dda3e9c957e96f39059adf5fa62c4842c52b85c9e980ed191860d5945b61abdabe069d654492523d43d36e73fbe285a1981c6535988ea3ea1251cedc08c9fbf161275758a9118a6b1068a69f9af5818550844cb9b9666530341cff70d485c0801b27879df426654bac3a32f3141451badaada0d3ce617787775bb916adc05436fdc7b826f4e7d1129ad47cf7f5f2fe7c9f393578e9f1814a60f94c6131871e2b09b35cee5382ca295365f95ea0f97e767415478e89c5a327e4014c53df4f3d4c70c0adf7dd05c815700e5500b216e9b4ca90965b78dc58caa8c9d36dd3520209f62d2328b8a4deeb9e66dfcd84e2522f40c9e0dc4947f5b45be56b9773b0370c75b46901a6a4bed8803eec6d5c43efe40daddef71a41f55de0be0cb1260e1342b86c69a2c3b6efd82af86c1cb79a1f41be6b9b36df309eded35d19f78875a36e07e522c56960f2744c0decefb9ba52248d29589ddc8f1cd106fd302ba437d1f1adb4e2c0f2a75d4a8eca0bc43a126e423dc7985445cc1403bc08742c140835b2e8fcbfc14050d9fa93144773dc508189041188832b94732b5f8e5eb54bd182c678b5d1d5039e019ef0a415686d903f63a9c991e16f3080f7667b8cd7607d1aa10dd0ae170013364ed3055debb7b6372165da04720b131713857d83b38b20eaf6eb82ccc99a1fbdae40b94e2a5610e1ed447c3f30ab0b1d3d7dd2ae59c534c8ecbdf8a6d38627bf47e3d7cefcdb961f80db6a45f76ab43786b19bf9ae7fc2572af4603f893949ce43791be910c2b96e78abf2003e3f8a12701ed9d337d86516ab182e756406c22e8d76d0f4d6d555b8a7f4bb28db6c3f817e793b86ac91fd00471ed12e7bf127e0250ddfedc073b97377d2856640c7e19baa1b2c513d89d5a7ed7b0f59356897498e21b59f2c9bd2940f6e94ff5a7742fbc0f3f89d955508d3cba0619445b1ef27a4e6cbc03f7a3320f7082bf41211b7a1a6dbfea0dfc1be94b3b3e60a263e3cec26e49dc61c9c365f1b2d4ea66bebf1da824d19d8ee8934dd341aade5a755a3bf57fc8c7c7382200896e609cebee265798d3137397146717b287cdf660d17f9e9ff030d52feac17330ef28447173dfe6b897f069b34036a421b72e473655ceeaa1f9b744ce05e0d38d1837a6e330420438c3d51bd1e1ff055cef160c2dfd411ed7aea7a34045425883b13d4dbd1622d7b7f5c0f25c997246873db82a01575b9f6185ad686e7581a076e84b55c736ec99568eaa61113b80176efe9848ea2b585ff843f6d3aa5bde0e2cb3fd1d43a04e464b7d868374a8264c15640b6d4e5ccde2d28924651c670eca438779052e34b670b34e217cf1472ef9276dd0fa217d3438bbf1516f42166511883ecb2678ea8c02014b5f52c0fa729a83b8eda93c6d37bfebd6900fefeef96d0d19a977a4a7d8dc2bfe9ec3e5cc8e9f177a9fe3e6fa3f99bba3fb81df911c6bd3fd37bf0e5d1c4170503fb8fb7793773669a00ca5549afa39dead5740ae2b51f4cd5bea39c71322586c6e63f317673db47ccc8f7744255c1b886d5ee4dded1134ae003526187bd0743ff805504c7c001c1e7b242cd139aa984926b11e1051f1c029205591831a91ab8d3c09bb51b50a4c3f457ef66e7ac9ccf67b25236674f9c590260298dd74b9e93f76f15c1c4aaf9862effe41da8c445f2e14d1928f22e4fe0592819bc6c92e9c5c622bec96a175eac047274b8ccd9cb9984fe2e10c351294c19e6012f64b31a983031717b71ceed7252ca3bc36eb3d3346a03eb6f0334180926c0df180c55056fc9893a63d534ab37b0f392607aacf556961aee9c89026c910762ea57b9a70051845b05ba93ae87054fae24c3630e33cedaa8b176ee0d7d606e40ee8d9703c370c7579a4fae8399529c1f98aa936b97ee064ed0902d6bbe12feafc5676109323972c9d231918954408427c477bb27d8734147d51decb75a7d077739b014672b8b5912e40e668bcc4c5fb246afa9d995911d9452934bef8afbd08492925adab54f73f450a1fa1ea7d2533e7b34bc306cd1a90e9a151f17a5c98e287eb6233ba454bb6e1c5ab6e75d57210089e4c60fef91b03bf3abcd4f40f3e1a4942b43122a3d5f871e09fde856043dd506ebdd78d6b8ab8e20c59f9b73dd4d9e7320fd718a571b727bbd4524df53a692ef8ea623d1284949b9602b70bf10a6aede4f3ba028e5b27b77979b91190ebd2d53303a4ab2c4212f3e951949cafac321aa421e7e4e2f49f79d541de26ec233fb105c0ee0c9d27e098eef421a05eafca98f8f853f8e9f97899cdb7814001c97be2f1eb17a8d07c255c4c296c5e6e8c9b1b86db3ad88d614d6d1ab0f98cce6547a7053fe8fb2733a9d6f83d32df62f4e8161225b2a2ae53ad0438a98b30df92eb0c948169572c5f2d6dfa9e9853039c4611ed85113d99bb4dc404088a3b352859f2b4a1b9c0e3470bd00079582c414c44ddf6187ba3759d6b519d927afdad91b0f8a724e82b4ae12de81da72221a23beea499e8823c4c9f5a20609a62e94701fcfc7fdf4dad73238a46fbc23cce53d8e683989d3602886d7e29aaa6203fd1c1cd27c1f9842364a9133a8dea96fbe43bd93c8c6ffb16948713e09ae639b034641c669b9d9eaa55e4117dca7d5d70abc4a40f75a4c5c7a9ffdf717255f03e1fcce27be00c77899c1bdb885583f4fa4c71a3a138baa786e304ec560bc0a617e20170fd3afb62c97795a7d216b54458606663ac6d332c68bc3a78bab96e719f05409e9b5764cc4e0b54c47a7923aee43824bc062f0be820c75b5e0b5ea213dfc660c1d499a865b50e538f01711e821733ec641e27bd4b418ba035744fc16788c734b19428865825496878d1e4266ce2e05176c5efb0e90ea2c54bcbcf60d4376e00c088c9c472f5a4e6dda2a30b123e9d1a8344b503b61c1dc4776d03c9205ec79f16a07ea2f092ed821ac92f16189428391d1769c601ffec065e5e0fd9f5f0a160f7b89ed2445cad681ab68ef57c690ab8ab20858cdef6c839495f274823be1d2fc2659f3041a85e737adaccccb1007c5cfe90f0490ab28f4c2894589591ade3b0446d01413d2378b3400b27ed7c96874c4eb79dd5de664b31b0179533868104ab7c36547d976636cb16c6d6c6494874ff9e14b27a4ee6f56364a10f7d7d94997c3ebb95151dcc5e224ae8f77208984678f8858e6e7450b058241c2a9691af847931054d9d589225b345ae62c3dc6a6d1072761e8c0db80631f053078c63e9b88929c7acb7193fa9f8dec634914579760127cc00648ebc6be09b4fa09655a6980a282411b86d5def2fa37948b349f149cc77608353130b97862c43ff9a1fc042f1edbde49f20d454cb589aa3127dcf3c76af6db1fa2d5e5f2ad4c7f2273d91afdb22d5f3855d116083beecfb269b470bfcb0be2fbd0fdd1dfdb52102fda1ec5d2320474b8a206c24202b05f7f3369bcfdc3beffca69f14192dfb29540bef6299984152521b4585310c76b9a81b367462f618ea99704902a0dfd581095c0d769d4127e0f5100bf92e92f08fa81224a1c4ea300877f6c6b584cc1a58940abefe0532b443ba2f8282c656745338356f00b4c573b91a962c31c65d0447c07df52eec956abeac1200929e31c0662ef210bd623197db9e938ac66d44d654e4e5d3cfbeed620276424f53afa9bd77f17f6a2d02000bb4d59ac85bb3315d1a61fee8421af3f1cf8abe7b000a24e37479007dd65eb4cb1917f3d1212d321d5dfd75c65408525fec4b811acd53d38d498b1df7487f236b4bb674b0af76d85c81bc0dc1279a2562bfc954ae3db1fe659dc7a59277845a7a7a3768d7bcca49f09e28ebfa6a8be16710794061d8b4e649fcadd1ca93a2c35d13b4c2ef40b7d6b393b1a37e6dd671bc9dc1158c17eac83e4fceee2f74a19f1664e62fcc03a3d133b479d5539f5c03a68e2ac82acb469723f6200a28d93260acf61c7e8da07bbc99108e59eeb559dd98a74096699e06837ce54ed881427122806daf38c7e07a4af5d2c5582dc881a266880d0bfb7fa21f0701e31434d498242b54b846d91d5a3537d4b1a6be51085054633115fa6a1809014d57d105f5a137cf909a07879fb3a17a01d7b4895fe18f4e36ecad47068d6a136a3a8c043c11b89548e778a072b67111cf2638d1faabe9c325f7ea32ad96b36b2fbfa68024b2de1db5d8f3c9c6cc01e9f83b5ed4fa1e39fec5321bcb3272ec6eae7901958d4af89e0950e889d72445f1a0fb096690185f0b80942b4a3a1377b5d4887ddbbab0f6e9d6bc90f2f22c79fbcf9c7273d402de4d56e5c82bf7ca8321ddb7eb70dbf370c40b1516d7042000117db8ddc82a2e828f4d58fc03a97e0ae5221ca4ab7877141d720e6136481cbfe1e35d8e3d1bffa79119331e1483f2fb5ffcda8484f91fe53336bd5d1305db2365794aae0f27aaab86b4f1ba753f563612f58afcc5544a4ff8f9ef1f47ada7cd05a4dd3230711e68f70973ba74dccf6447cc3bee47a12d419ff6037582465a537ad781dcd124fa7680849de6ce54fdb20f6b588e405adcd05dc1fafc7b8f1d85f9fb0d39840c3e5b5ec9c53917d3384864a3bfdde2a347f8685fd9854542375e7db5ed2aefd3d961ed693e48f3e2696bc8010ac673e6740c2d4bfae7a5a52bdc75425e8cf1ec6d13d5ff4c38f3b40453000a1a883b3ce65801cb1925c7571fca2fb1cb430e880400e353fb06fbd4b76a3e513157ad2dd30306507bb404cd1ac05334781702729ab45b6ead1d1f3bc0765e572313ab112939376f905ca249e4fc15cfa1cadbcaaa45b25a8271fb75a5abec4e03e5979c0c337a0fb547a99972127119874c279fe5aa469d867da66227cf3c0950be8fc42d60ebe7b14e722aee249884c98fe3d6b37abec300a2a0833793c3125a9071c2b78c5f09130d6792f55211cad38fc71d849054ee11fe60fc5792bd6393e0dea041896f9ae7b35401bdb721266a4c988680ecc6c1dbe0bc73e2b0070c35f3681074693210d8146acad0858c33c17574f31757543d995b79e05f8579a1815357e634f0a26861586fe8fcee3814ff74f20b5eda03a6255cf6a9d6b0b9aee353deded4f06d417dd3a21a1adc1ea993f7686b63fd950a5f3d99a4b5cb594d42764290f379286b959c9249479d9551fb8f2285fae12661a10a4c99f2b3815af7901960ce852c20ec1597bba08751bd7a29d4942d0838ffbad9885ab48e56b16bad2e531275d2d3e6978019a5e9d3d55bc528aa6a3d42dac2c9ce2ada29e0aef82de14c1d6daa58aaabbb2bfa49e4675b9d0f724ad65c8f9042bb71a570d23486d80d39fcf6fb05eb0daee3edb14d41399a7b37ca0ab72968d46b1af7fb617ddf3f1c00020e9bfb82d03221e1f83079d340297800fc6db336ce2509d016444c709ddb68c1597c82d7d08150d364355abaa1acde772abe0d6e2a496acee52ed084895c8e80839d3a8de9d1e1206b07a41335f65c6d24f1a1afe43ff816504bb173b440e8c6968bba0b33440e613ce2ab176aa2b19d95618e782341764870e2eeccb53d8bdfe2373ad77b4e35f1ede03c49d7938cf03ea4d3f7d44ca3be02174d550f3ea37158b41065223f03164d67e0b6d5156d4e8916c1eeea20cdd760492b24061c083112c93d745b8714e46bd2af03bfe3da7c377140cfc33ddf0fd538113f565e5f0fed0440b5d6b87d023517b4b89e792866198740e81f10454b58c5f2a498452cb720a7eb770033e11af030677117e1472e9505de70b11c25a585ccc014ca27ece63a3bb97e7b990dfd3984434ea6fca5d95be23a57adcf1ef25e428d482cda0cf8ab980b8af6f50895857747498f7e4abc596ddff48bb0a2b50757c4c16e3392cfdb93dd2d848428e2f02f0f53c366118ecb89e6ba1a3688184d003c22fd867cafe497f7d79ab66b60d2d26bd358c92e1b2974cff3f4e3c6a119107a6acd23aea2472b1a74bae69e0257ede57969ee0de8977414c20ebc87f07f73d41e58233d02f0bd14ed865512a6db4067013e7e9094d0f6aa237fefacda606d4c0f14c599cc6a977c99dbcc7724ec4ed0dba81cc270467c228cbd1e3bc58b86acd5597ea6cb6a79167f3961cf32cd823f4ce8ec86131ee594ac0f848d1050e1851a2c769d57a92d21b3fd6ea622ee043dcd843367339ac4412272993ff32ca1592656d27151e04d8648a84ed4dcefc90c8151ea04a31e2884765e30df532d91c651937dde40907a6ad5578c012ddae75da8d25072654cf2686eaa789ed19737a840d4d23d6db950cf15dc2452250ba7d66c87da8e862df59406769068bcd66a20505bda65f4e5c5bfd5a3b0e4eded5afba7d980a8b959cac36dd768a78bf0af6894d7ee75fb5a6c59a7c671192a08983572c0b22674b687236152ae6fffdcdf931068bd9b5b3c0edb5f18bfc54c0cf30024d8ef797fc70417d89d80a583986b7b939c08cecd6569445ac6eca326759b4576b77090e626be651c23740812f215c6bd6e4d6b0825fa8d4086ca96fa3dea91ebf6fc02f70f2b5362a27a09704e4fbce0252b54ffd898b231d572971aaed03f0f834e0d1cd0c54dd064cdac1fe763fada16e9026a15cc3c072e736cc174e449c2a0baec89664a2083463543468c27d337d5e266907ce5ced350e9afd5ff5bf58fd606647a98bafcc4bc95dbec18a2da131e137befa37f95ea825d0cd77f4435be68ae00212d705eb75f3f08a2aeecd6bc10012fa5b9be60981537acb8f8b00e7f29baca2495ef5b2499bac16ca36c635b9da63aee83729e1909ced1bfb18d9fff41ea15999eabd4faf851a3852044941e291cfd2c8a3042896a5352bd082533ef378195b922c8faaef06598385f043e1c04a0fd8f5169671a1b948030095f30851772ce7ce154c9db6b61de82fee688b21768335214d7d616f785515a8ae379c748f3a1ee4e95d64b451efb56a1d598f8bbf8205b67d9ee7e2c4a8bd6fd688c29180466dcce345bf1eebf205482efa759e361bfe9482919380b7fc7fe858c4dbbd95e18caabe0d21584f2cdccc876fbc7ce04dda5959fcfa4b5bfe139bf3aeb338cb2dd174582c7bd7ac5043b06b2eb3452a207b7024481d2e2bafb1d5a3504b7a389123a1fc3722b824532404ee32fa5e05165301acf9ed93db12646b87d106cb6a1f3f79bdaa662e3f7f68b247ce3890b9412a46c5fed334f6b15c2a622bec70715ed3b4ff7bfe53bf103b0aa4a43d394a4575f4353ca8feb1c185bdeb5247226f0e88e7ce232aac419d3ba0da200d510d426f505c0e8d4360262f596e1e65dfc592cf31e15154ef6fbcdd2d4b92b503ef74bf890b7c372426cc84a30ea3b52b326882e3e8bf1bb4d65c68d47ae77fefe7bc2292f2a58cc8c19502becbd91ecebab47e842626f7017162d308e288a1a6129b03b00ed7682f2eae57582661ab9e87e2a302826852a2f7a8c5338566494778b67e84d9543b60f7856e913744d315360e8078deef509cc89436129da39e788887a86036ec960c7de0dec23fdac60763cc0547ed892f2789e4d1e38993760b4ca35d09df6ec8f3af8646cdf3a7180d93199bc7ce677785b935e88630dd8e9a42e6fb07511c7889baac8c685058c2c72539f8265cb5313cae27357902caff42e4da05a428770e193bba6a8f7ccfb74daa642ef76777d36ea0b8e15994a398187a7cb3189ff8c31ac477ef37c6e0cf08212b6979f3984cf067699d70d45a7f6e980ed0606dee45604994d897511dbc5cb9538b8080632911b9afb63c2b4b39fce28ff1d2b4ad296239d498d8661ab169267f476d1d4cb33ea1bc377e3a42ae67dd7caeeb347f0b5458b6df5a2494e18ae0fb2904687d9ce279cc65889ae3c4275d01252fc1c4a174e33692d42fe35b7ebca6d3c79afd16083da24990ddd8afc6c6f1fb28dd8be0ff01407be0c186da602d2e1a0858a7e79ec79a1f0d4b1bb11b7d4bb26ea040cdf82e42fc97cd5f3caa33debec399824580ccd42719b7955cd1aae63f89e72b493ff1416f54d8ebf9bfbd75bd66d77331d97c5a312feb5abd59488b79dd00e3bda4582cade0ed2bb456abf9091fdada3d36fd251e066079f204f511411f2e1db2fb30d3c271c87f698adc034045966c3a2fd312ec4db410acdc3df22613b82cf989b7d7d39e4de15aa85ca29fbc3e3f3ce31d26cdda681c9515e4245bd64e7e5fd95b503dc1b77a718127ba9be4847a22aa966cae9653569ca7add9aca8289acd12be66226c5a1af90f2523cd18cf5aeb9d66a6ce99b0b7725d0afede0e2dd816e1baf4b93872a24604940eeb539c23b560a25d6cdcfb1164e6fac7c1387fd6e4e1c57f73dbb6fde0e03cbaa88a676183f4a8d673ffb4b45a3f803000679605da2e9c9a8bd9c4895c52d31985591103b5072a25eb36bdabd2ae591b4579afc941d786effdfdf1d10242ba169cf780c6310040b3e65d6eb79b817dde97896a2dac5f6018ed5993aba833c375d2a10439c59b81979facf85708d38845bcc4e7b7d723e9b1b9359b7017223e8b432b36efb65b893b2f991b47bc9ceaa0e3040d307b795ff1b844c2727ee2b034994636bdd51cce129f52cd011c5e80908cc8857bcc2aba1c240aaabde71e87e3c748bea1ffca462b176a61996c26ad19e268b0cee707e84aa75e501a9343df38fdb135466228608d57bf81bbb67a4a6981845e514caa97ce6ed551e658bc1ed0bf66180528c90256435bf4a469fc8893cda39e4dec5b707e7e3adc37c41c5143728562d144cc0ad2c4b5433413d671f584ce0f11397be04537a087dc0b3b89ed7ee86081a24b3dfffdbeeda226b29d77027a8d295717278fe6e406aeb254902cab3d88b87cce711035ff8f62e8da8d1236804dacec5c6ec2fbbf3ea8ec729da45fb6aaa9594bdf80fa5f66ef781c0243238c881a427ea78aa7503e8d122479ae51bef811704e379c2342390cfc02cc7f0dbbaf93cbc5686f0c67089d3d169e0bf2d90e6147ea39caea9dbfa1f1c627b6f503bb1c89c6430e2e3715d42c10e0bb6db02df2f3484b7d5c35ff40325822dca6b1e6da370d74c428def772353aaaa185753aabf48dcde6fa01d903e04cc6541edfce18aae9a170c45e6267797ec57be7b6bbd13f39ec91f3cd7e86f2207aacfc7b10106f771e70c1026f00985e37a7bfd456334d3c3866390e89f0a3ea476fca00299598771faf4f3a77c71807c2986cb8c25d4594b001c63a45fbd8e7954f17ecef6a061a4287738afb619a8d91b0a0d26e9fbe1b4c4233b9dd5b736ea5cbfec4d958648635b095a9f33d3ff402d70bb62f6435cae05dfe5ab8dc79a7854c4a2cc6cc434ed4ba858e518aa7e49d677a165fbc5e2d6dda24aff0bf6ccd0855cfa9dada696b0de2b816d4792b592e7a65774d214b1435fe10138caa54ff8c2fdd2ae5e0875ab9c6bb6e4b25ba91b30332501379e5368dc78fd9d1f6e8e8bcf0c10da3d2524f102e64e6b37e8e2ee7b510a8cdf5abe643c3ac7c10cf73b73d9964e0890b950fa5bd7c54f1c5ea8ad40eff69970e1bb10a691c3f581be2c163519fe3b0746ef09e635d8db32e5e0475ba4881f37a7e9ce92f646f8e677476585035699988e8eef0dac6c323201cdc0e6822e0b4ffdb29ef7d196f0f2b5e2a1bea697f58c0e65417875f6901dc63dc116fc98f6382daf8c1b84cad6a0384f33523cf85cb5be775b66b868765584023d78d77123e7f747d482390cd8d2a93f31bdc6f59f9d4cfeb2567f580b1ef0282b064897e9675d7e4fcf87f35ed21c4d15d25d9a3fbe061ec57406ece386e2066048035df9c95003ca9fd10f20522c124c1afc30294a1f2c254f3f602939baea71305229710a02d2245ddf1129ee57f37081e9a3e292b2451dc67f5d4ad8a48ee8f64f466272e21dc0bbd0e67a6216edda86675d5ec3e9e5579e855af2e163d7a084ef60b1ce32417b0077ed51caa20d372c583ab0a3205550603e200889a092d4895ab54680a2d21465ebda99a98974af066131092f756c982a90342038c7e9661bca47dbb5f93b139ee8cd8d7d9a68a3b48cbd94bf017392631b4c75843b28c4f71f1e9a9b212a3e81ca76fb89bbb348f54abcda26094b92b11d92dbfabc6a134d025ddb774d6ac596a2c5b239ef7d4220bd8fcb777c47c6bc7d740626614d38da95964637003a0c17204753b8ccb3ff0ba0767ec661900ceb57713a384141a88173474bf02d6fb51f971e3800207b0b952aafed87798a9b695de494e31427f995b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"126a08e53e36b703cc95578979034e86"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
