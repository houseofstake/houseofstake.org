<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>House of Stake</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #000000;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">House of Stake</p>
                        <p>This content is protected. Please enter the password to continue.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember for this session
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Access Site" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Incorrect password. Please try again.",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"570b2d0411c2e237455e5e47916ca9d971f9c505761a471e361fae104a4edde498cd0ab7fd21e2ed201485bd8cf7fc04fb11ea9832ae71ef75ae0bbf6c479fcdc2cb857c291c8c68e321d80c3f27d61e9661704231a12b25901cda467d610a915abe4565dc4c8abb55cf11216c02cd8266768fca8d6606eaf50c310219759f540d5b56bacbed7a5340208e1b2d3682712a73758a66f5339cd8631bf71f04bac8462599059cbc3030ca54097c44d25029c4320a3edee455b1f0be7b99820c22be22f05c9d300ff0a8dd21d2239f4403cc48db1b601bfc54fde1cfb989f1f92689b80c95758294a0db633870388dae967f8f61f57938996bf89eb9090b8f41a39628a3677652690abbe4ca744fba7f18f96ca80ba41c15970381da561e82a71eb2cd2ea1fbdc17207b1fd71f95112e253069de935f79e9d1ad38407bdd6b8becaee725cdedfef0e8747ab68d7bc4264c0e04d6e47e57614c4976484b15bb68bd4872435f74b9aa0dab6c7bcc43731843d112acaa08d33697800f7b69872357bf0e021433c14c4dc34f938e4ffdf7cd26d94302467321669b6c7f70e5def37aa6076168a39e601c8f1c98a043fcb01960dde328b1462feb338156fb54537091ab77f27204255ef89cde06dad6f249edaf391298204dd0621f5907c8bb9bdd854f883e0c91fd23abfcc8258a4de1b676f116243fe1f5bc3fda31eb960820ece01812a145babe2a7feadbed191ba39c97362e2a2b67199b8a2aa2ce8ac947d243a2c8a07363bb1b439ee46639b7e0d25978223118ee4aaee5944531fa9e56eedb181b7121a7719a9bedba5194fd12adf18ac39b9e43b6f15fe28f9d786e28cff2d35b7ea877c716d5b80de29e082df32da76d353b74cc9c7f808292d8e2b5dd844015aa061a721c3a3c3e8a1fe07db862082738484fb997be807d40c3818c2b88635bf8fc8b0e4a06fe718f4d162d65aa4367842a06e61ee6ad5d1bc15de7e19e70784efb12c5812df1a3dd55eea36c73d8996fc0d18019094ba76585e8da036a823b6f62c44ea3ee3030596ca0a93beca3cce99fc78eb5a70d5c6cdb10e297b686cf434ad99f67b9525ed6f354c4926039deea57026c2005e3030ba13e26fd07a182a17a703cdc7ab47d66e2e1820a2c35df3cb685d1bd67b81ebe5a69a5833dc2bd897c6cb787079e0b9e1099db52ae2257a0abe8a4b6ead658616ad1543503e22e594e60a3f3bdfd2b06725445d1668623850642c500dc32eafae35c1db65d403d7b835eb2be43d7ea1627967874c814be47b1e7cea691fcd91e99a6aefde187a54a848c51fc5603b90343fe9b344d7e6122a62776f875ec93cfe0718acf9b209243b09fc5f9303949c5a2642824b0d354fb293d0f4d02bf446982efeb53800fa8888197c69434d6b97769aaa4a7d12190559fd6494d6a9aeaff57bbd0b895417ad1089b180a696ad2fb4133004bb1d4df2308d8eb2ec2e7e1963535d4933baae9abe9e6c9d82de77cdee01ad413bfa2f1c362adcd2afa7d3a914c4b9b4bb6e343463a130842b540dfe126e54f0bb8cdb44ffd507ce2ab2ab1420428ea51b3dd0df300263d424cfa6d1e20d690f01674f63f335161c2f0a9b1b79ce493f4cf0671620f38810588617c9fc0a1e8a41fcff5c5e55aad852241c4e80624bf23cc86352545ab0d2ba4eab4d7157800b99e1c6dfbc7db2e06aeec11f2def78649a0d66c8572192a00d403bb603948b7edeba12e88915a8a9bf2eb557695f04c00db14ec165c0785e8bbf0e28bc86df0a3b6c7acc6532769e4be9206bec95b6b4b303e2e78e41fd9ecfa5f4ab4e1d758391bd7fd285f73a74167eae4fcb878d5a140289189dc985693618c3b0b06a708a58e2b44070a4576eb8f9d8ad48dd7a82b5edd5d7028e6c00e34063a9f6f9c2e07c0e713d938e7e6776d02d347b9c08e1ad0c7846cfd62ca40f537119b6f55ac3ddf504fe8c4e529513b91b8db445d31dbe81903fd1792be77b4be05b5fe4289af3cd3267ce4b002d56063081d9ef90c8085577c4e320604f5795efed9e6b893c5ec0f4cb5abc2467d2cf9aab83896362f998e885d7e0dc60b851e3667ac85cfed3565af6107a5c18abc243150a6fe86f4b117f79b35f1b83506b51a21123ce4329d8ab2b6ddffb210eae86257d2facc590604209d7771916dd5ad89b433f9ef5b6fbd74a3450509cbfcbd9c8d8b9549d78f3d42c1507b9729d514b5c5250d7ed08f857b02b1948c5c57c76202c31bac0f9d3cdce76a743acedaaac4e0522f92258e5b71deb37c4b3a6293128156812256a2f4c789395bc531ee8dff9c29813b4df34d09f7666a016ae0651738f6d1723c6a856b838140ab2cbe206a5a5bed1ff9d056c32c3cc26c5915cb658343507ef3f850cf5d797ae9b2db2becce7b335cc80b08d91dd8be1f8919c73936c05e379d5def88e8f16ecdf9debbb6ca4f6b2ca69dc23ffb457ddb6d08898ff8f9286a138d331294231e32de335e2269812e32a235687234a60521f6d36c60534c5b3ec50c071be4b0966390cd605c4d19c2f7e6354ed7b5c7600a1e2ac7890e714ef0715235be44448dec0d79c1434c196f7567bfec4acf7f2c0f01a7803419e886b96a8cc1baf887b855cfea71088b18f5ab31b572d9c0c0afbe82715620f26cbbfef1b73b9ad6a13a68879570d28a94a9d26e49e7df6aac9e8a56b4aaee78d5bb4f9a4cc4ca85defa5852c7a4d1f13c050b2410cde704e8afdc1284c7a909c5962b79c0e64afb434e47ace5372f5c9feeb71dda941206815b54aaee3de9dccf93f551ffeb95ba4c39dd1bbe28b209dbbf2aa1aa56c340aaa19babf990b257058eadf80273fb6504368ad7f695180d7827c56e767277af4a88b22c635ccd7c74e776bb4689318cb63372fb15ab163e8f83c311a6a3687791b8ab54d8cfc6e67ca6c63dabdc31cc87119b50eb51a48077ae51cbd5eea5eb5d4c2c3b11734b3983e19d49cd3eb80bd2c119cb0b2f0fb6101de0f26cc2fcb8d5009f7226f58830de6ab06db208030ee6320de4930fe7ba65510ec2e27a76157117c092e9acb3070d1dfe183f2825489e1d7e1d9c4e3ace333e20fed81a515895e92467e413fb084f0fe7f601957c722ffe47c13d548dc77abb33125deba35e6a638d225169f65c917100fbd7e8611e1dc8664f4e17a27d6a1392bcf1ba545621569dce9555e691ba54fab655a59a785d8a35b766bc2cfb67c8945830f835ab861cdeaf3ef83f55a47024ba35d6a91b36eb8c72c59640b5dde1e9be913382dd8b965a972e4b59c27e072dca4c36336222a103f9e0308bc4bd2b0d273013e2051409e84cd72155f02e657224695f4d4f2cd1667d7f5fc469441cff006dfef9fa2016d917315f4ebdbd5ba90427631c20acbc3d563c84f48395dff58b6caad5e751aac734b1e6c18b72b3a2c75542f61c142a098fc45160604a4c36f4832560b8f96aa70fc1ccadc63a71372fd5ded84610b6384aef54ae13336259f2b5e447b12d34f940dd10597f1978b94f29b698b0d5f6a9481afefcb79061e944102792b9ad8d99489af690727d0302793a88e5716a3850359a47da25981099468f15694739160e50c180777a3f20d20f28442e6b056fb0ba99dd56c58b29e2620c9aba345026363b969426432389abcd541d38349e9e7347c0ac2c33c45a11e871fcf460d56f3def16c21ef8584bc55d2869d2845116183f086805f5dd7bc0cfb58c7ea7adec99b4d918a74f4b9b0c2c114ad1e7048b57aef42e6c465528e0010a889c97c62be4f4e430c57abf03b1f62baeb14a8ba2d8d0ec8bbe336f1d1ad75d2011ea96f50b2f32496cb3b489cd5e1eb18d4a133117064b3e7d0649338ddd095ddf8b4b4c506c0e34558dc8f7519ff4a0b3d5ab5576d34962d4431ded90e6b0738171bbe875bf176c1ec76e2bff6bf3b763429eee5aaf08f89d97a1ed07d44b9b6c5df1ba4fa3d985d9798a52c47e67e181edf23664d6657cefac82dcde3ab1f7f98794fadda9d8f54d9cabdcceb6cfc9f10b282e0668cf7aa320a15a2f2c519ba695e4e316f63cc26ed2b3b3ba19335ea58ff6b3ffde6185ebdbad436633fc15ed1e55a20db3466365e53b1dfe7a86e72d3749389f806d5aa80f585733248dd2bccb01ec4444257e59acd958c4d3a488b264db52fc2badf339bff9335829ce5c1afed9e0e491086f80c77a786200c0b4302d66f525c52fdb729c823fbfe78c40e813080cfe8b9362820b85f84280b6de5853084396b5613ab9d0bbf006016119c3cf93c63882e699adc8af4af456a4b2a489ccb52f27a490db93ad0da0ee28e7a694127fe63c1c66df3b4cc2720625bd2363eab7f81512ae8aa4445312fcb9b2b6a4f58a62df83e90f12035de23bb8d3e3818e3a39718ea02e7ebb75d3c959f08ff763c22837d8a526b26059ab7236b60f2c0fd2831e0a0ca1faa0ab2ab8692768b9dacd0c5325ba6479f0f346f78e0bc294df334c6b82cdd9b5da9841bdcb69cb91066a00d31145242aebf03f3147acbcf2ae32cb3f3655420881e909d2e75fec12cde19b9f68e83782b929c137acaaf7f72defeee17907fae3af3a7910129adae1c29be5b416e0d23276282d27a6a38876ef927617b91a822f59f5fdfb11188e6b4dbe586857b49d1d487d0dead9c6da7766cbdacfe8ddcf343f9d403b04995e2470d7f16e1e60696a5ec6f155afc62a082cb79619597d843d2143aca98be75999a9d534e7ce2208ff220ce624e293eba991fd08f2d4f3be02498d76bc2bb872f5e093c79a596e11f40bfadf16a8921ef1f12cd8806473458a18e288bf397e3529fc835b1182def4749827f7a97a2c72e5a64c084e440401aa1a316abb5274e96c6f76b1aa1dd1366225cf4f1343d0ffab30e62cc614e418a9089207725886a373c41058fa246e177d13be9dfd8851d0eeb75c5561beee30b6c6eecdff9ed4aa0a7857b793d685353da9a490c77a157700cab9292c1b5b499cf6bef21ae278d188ff61eec1de8368a3381d6361ba0930a3a492c2b8d36e214e57673002e48becff655c279161594a255346e72274bcfbbca5954b3c033d87b5d0b74a7a80835607ec72320c8ede566c273607b68b29b7b265b79576ef313734f0d884bc3a1d85183cb3a9509f432b46997043b7cc48be5ae6a3e94f779370e1a47b2b52c21034d8d4cda67834bd2f898fa98a327de99b559ca06527398097f9b265247feeaf00f4a3a3cac651ed9e1fb213e5765c3d8365421cc27d09ff090ab0dbde14c538af97161071e080f7a198ad57dd450bd491d984a0c402c097fc041902373bdb61f06a478672cc721309b6d50d6e29c0d082fa420cc10a0ba54081ab5cab727ec544b4fda905cf31056ffffc3e66fb0334fab82351f2498f8dd7346fa2f4976c180bf7ae274b0fd4dcd6012caff8c1d4566530715b378eec0241bfa40d5529990550c6649d8e366c08a4f2e32ef258986ade6051d6a32824a31970690cab2aa8e5770a2a644159718c59ef4f73653b1fa15f792eaee3311ef293a69435c1683806292788cdc684f9090299eded4b815356cc9347ea36b30e3dfef3e6a0bb080e06b897bd5d4285e35b6835cfc2cc8408ded6a9740f3b3dd5027a8a303ba7a80c1737bf58c3443cec4c6bb7683d09028fc6f52bd05116b0d62b4e4f66a1e79ec9e9cd738c4128cba9659fe4a78462f35e76627839c1e31bab6202c1ad34c206c0072fb62114c0c49a86bb66c9e40fff22317e53945bc71ca8c4966b5941e85a36d23ec1fc4de0e6b11e7ce6305d090a9be4c0106bc9b3a35dbf261852993229d21d083a177bd4dc196504026ab91706eac5da5b622b5a9ad5844b097610c1187297feba16500ce0a8cad0f0de4db05fa02e3e2021cebdc249d88b9e738d24e236bc46f406047d6c42477d372ebbee4c5e7d11804443803f26d4bef859a4d242f28de29f89c132763ec8f1fa410487c96f96151edba9e47d174efbba2b2cf704a06c8937bd6274453dbda74616a61111fc87d3ed270394da1e5989f5c6075f059f369aa29dd38a7796248475b459148a025f37ea3f3df910af09e7059ac5cbc804253e9c3389e203b0b9833e308ed5c5b142a026f4945ceb458919615cecdc98dd4f5abaa5d68c422f4ba58c02e5755e65c13578d3d519bf14273d5fc85a52f4a2571987f3941508fba0295deb3b6468ff29062ba92fd03c867def9b271e7ea22f06d1b5fc17a18bd7f31e590de86eab2b28ed44fb01cb7364317ec8d600039f2fa8eac4980a82689ccf7feee41ed8e0743f36a613d747c036aa5802b2ec66ec54f18451b863c763c5861cded99390a4d785dc5bf374befb3cb0fce5826f917ea684de43a637992e57cf5d88207497016c6926ef25f81a2b888a76b520bb67e95708f5bdf7ac7ab73b4eb820770b06dae5a39a61605f347fb00683345e443935b49839edc3996fe0e891f320c27b401ff1cec26a4336bba760a149fa965aba0dcd29b69d5c7c6bae5de9de9fe4b6d1de5f823323dfb8f05cabbf863caa4806899200cd75d7b31305d57d631993ee3a7e559beb051e7be67f7f2639b4fb04cc3744b62586617e013af8a71bbb6658f0234db4963af75d299aa8b5fa5cc6821877d68c7cba3c34a9c087d84d3defe6fa58b6e3802db7caf9003dac449ceaf04e5bb555584dbf9cc267aa0174c53af46957774f89be685a3734a9be819b1f91c85cb9882903dfa2f7114665636c6b99138389bc43ead24d25d04d5c720448b98f72b612bb340338190251245fa3a33f7361a13102f20fc568e8acc6e52d99b8bae6084a375cf4b65c06fbe2e9ecd4d3bed8f85ce0ec6aad266c09c8a9609e7a1da12f5c13b4a13bb2f1b08d9db1b365fa9ffd086cd26931e2fc13436b128d0d448165692031f73eb3cba28e277fee5464ded8137bb195815422d9b5b58febd3a294a9d1e2982c4c3a13b26012a139789a9edab5980d5449455721551d59f4fc9cf6b20d3caa59748e9aff2c5772fd97f22f0b9be688741a6fc154a6eaf42645930e8a25ba96bdb9f12ccf9e177e4af821241b346395a4a215dd52e6354877863c50a90064c2390229e0da99b9eebd4bccfa0d066f13f9fb7a2ee048c8440e4526cc94b82470b758111e2788c7e93217648cdbe572ff5976738fb58b4ade45fb15f4805673d761275f14f807b43ffdd053b0b03c7d9114ff1b6b26f51828d32316cbefde2e801e68f5994cf4a32374f671f1b6809852556b70ccbd795d5d14a24c94695f5ee7dfff55c4d40ac07b21acbacb829ba36c55580b5a3194a5f0e887001d8fa28cd5b28c9016ecc117a6ef7c4630546040e3f6bdb2662786451fa6b1340edb518e05b80a6b2012c08bb220cd85728d1ed204d801bff918e162d82a14f3bf0d8a21c6682d4f4964f8a4418c7437156241e0df13ab96bff03aae5b329f44412ccd7ad33522a1b6823a5d26d6a29629b59f5e054d0f392d9de216df5f955ba241c3e4e67d56e99b93c19b808fd97edc70962a3c456930730e41a56bc87e0011a2c8aaa47832d70afa1c70e17d84ba4cb931a7d45a04bc36a62a6ecc882452d23f364ddc80a01fc6fe74f707b7c7c9037e643c99fd18982577a472c891d5c33db0cac083d2283b4c6f21c12005d90c00d63d5d730ff3a1a5e3858216539893d92af8d67926efe9380aa436c1c59f9660bc9ee87cb9415131dff5f247acea65df7b7d89b8bfdf850250d7d1d34049a957a16e5bde5000afda601a66a7b8c2ef976db419bc345759e101f094d20f828afac09358b8a06e7a645bf71a699c717daad6522ee160cd0b959c65b5f58532b44b94bfbc409db111eec1972977405c8eb768fa4f623c7e9bb5ed06fc292ee0795c9f191890f52ef54d2ed4c93beba1f6d1f6c045bc92f739b5295141ecb9dbed47c0b5179c522db6ca37539499a26c48c9827b496a2481d2133b2356b23b96a070d35bdc2e6d83da4341d397f44c20d541e0101cd5aaf0f2ac42ca38a298f6c73e48203e2c55d8672e4e8f808cf1f57e3b660a5ce3ab01d7b390a45b5026a4d24a89d6c50db44d0f2ef692321415019a45bdf95d8b05775b7e1b3b8ee9740b1fdc9e5fe6a8d4be2c27a12ef6f32708a890f13e45174cb9107948985e35a9edb2d4ad069e0b027cf570516ca8db0b15c5b835bdfaee32ba7849340cc14375a970bcb7e37ee5897fb3f147bb31b1f82cb36363eb569576e15d977c86e62a4a6a156eba76c1d7dfcc060519bf7373166e63c5a026ad9fbcc5eeebc3d3d8578350aff3b2bb26985e567019f876c75a4dcb8f3d6c2edd54985d681aef7d3357fd20284d6ff6860fdfd214bc6eac12aabc300c0907d0c2b56e45fcbbb5041123bbd28bb250592617f157a3c6bc58f0e66b9cc01b89474d439165071bedc2a835c5520b8ef417509dca681266f753feef68faf6ee06ebec320d1c6c02d6cbe762ff299140ca3132f198aa55d698db49c1ffd7a6fe4bbea34b628fd22adc35073213a675a8b0cb1af47ba0ff2238b1628b517376e2e00c345a5009dcaecd632a9bbc6fafbe36a22f25312fe4823a54b05ccbc2e621d004f69b6ce486aafbce5966eccfe28ded870e03b8850fef8b1f4f6e8ae31df407adb04ad61de6ca1ef059b870560d59c6aa27f74ddf57c25e3bb5eb800d4ff4d0cb1d5c747443ade2172790d9e8d6828ee5737bb1f3b74b5f7f9e121c784dc9d5cf1fe41dd82254605873536edef794434d5ccf69644e76c3ec6b8e5af00e8d7b785d96a86023cd2cf4625a9c19770c5e9d7d1faae4cc8d24ea1cf214050737865ece337a32d2aac32be0ed986ba8c5d0ead34212b4c5c57bb04e37da19c10947fd5805624b27a787ba1ef9971aa1c06a22c524945064a370c0f95052392560db2dfbd0e30f8926f7e917371967ba72b9570d9b1a65d10d7d4020dd24adeb1d5092dc6320aa78b90967c23a0bc31e6a44a83eef1565c2e0d70c1a098cedc3cb55f4dfe416fce8476e1575268700c8170835c7bce93e5a8dcee22a0de7ffead0ec41384626c08a352db94507da9d4dabd6498eceb542134905bd8bc6191e8c5649e1477c67229afc8d4cb7e1faa3e3d359ce515f0c4c4181997ef1985101789e6a0fd6f6dade9219a9f38b88b36880c4eabd7fd986deee4973657f6c047d7f951f9945c1c52dd7b46977636814bf5a666154284978ed8a42e6b27956f54bd46e68d81ab5e2c9be62cb239ac83a2b347cbd065b9d9b769e42277d9546194a04f0a4a4b32b68e3ed405672a12fd368cf1049685916b08d3a68a482f8148929b0ab090501b467d6245e48f88c6ca12c546f3a71c06ec31a748af7414ff3e16c4c9a3e0ad347000bc3ad61196ac14207fcf40d6224f1c8cf3c10c95bde28153f99887d65349df5812bfccd769f6e279ea026f1446b21789b41c6dbb57bebd618389fee105c99cb319c16eb966363dd05f54fb5b5de4d882c6a647a54f21d361f0b9a42bbb6b0e5f75f73309160c2ef27208e4bb42d4e9d5a13d884b657cffd4035e8d05013f65e8ae5008617bd6d89334cac25a5312f3cab55ba8669ee95b666f121b8f040b4f7bf4714fec5f70504b653cc2fd0b4895c18529b8524d6eb91a4afec367de04091884b16656c7f36b097244ffd81716901ab3358f1e2546359f7285441a4dc13e4d3ae0fd447be9ffcef9334d78ba5d815e353727174d4dfe667bc4c05324948be92e982f084d7120e67115a493881524d9f708da8270dc4193fb169aa611d31fec70acf8a8db5b5c53ba38497fd26a495bf5515db2f8adfe40fd6d695ca09573be640366a36e67ba58f5602d5b714d118583c09014dde937d8f085396b28cce958936af561f2765f6e8e2f8a978ad6fa54db63fea8aa0d30ce2d77572197f1332ea0c21ef18745198916ba0afa65afa93a852737c944b1d303325615143568838b868ffa1137e27201b06519bee2f55b954158a1632e071f57d2ac421c1348ddcfc7c9b3b85d218ac871bf34ac27314698ba04ea941571372544f7ba2d8572d5fc6da0981d002e7775c468a43e3c1227904af6acdb387fe0c5991113fb5c7f4bc22b0f17b90919ddeea5fa18b79a7e5f1bcc8da4b4c3ddab14a5f0c86f659c1a3ccef0bb1555197ddebe0949ae4a273460a4e896572ba2bca3b3df252798a15b36829d50f7dbf945d3fd66f0f11a53b122ad515b173da97340e84224e29ed01730a1dc736620990dd06089fde666b59fc72e7b176cd62b729d8781c2580e66b30cf3a6ba7fa5346287d48eb244cce9e4c9917e0f0f77bb26556ea54021d2397a0721f84a201de3c95295a189d2a568eccdf5d2bbc10fe4556fdb6b36c1d4294f888184a2d53e0bc103e22dc112edc8336ad025f097aa887e75235c469dc944250fcd7b6752a347fa171348f3242c83285d69481fe246efdc0f4ab1e2aae8a020e60be8ef0c4a80451a5b2773def6b4b32ccaece799f5665883f21b7466cc3271c5839268a1a61a88cbcbd0c17a47c1b2cf22ce9d8cf2866c8b0ff1d18ffefb99d6206e8a6de485e5e7850865b855634f93dcb1ff0ffe488affb8543c3f98e4647278e26cacb927ad71928f186f64a4896b84c013b1d916f654be0211319bbc3c26382b730b737314d573ced03b3640cacf38e7637d043c5ae96a971cbcecf331a92a047ec593a6a4e00530ac7cddb2d24ee3f260e120e0f2ad7e5c09a4738b4283efbc7ce9d0300fc74ccd3c68b5c774eb3a1a67f6f5cc79bc5ba7ac8ee61763f8bf147fe384b2c2a82efb7bf1be2dc70f9299fc9308b558d4a286fff2a826063e9e55653d0cacdb5f64c571d8c095366ddc19ad747665d4d56129c6a1f496f5e25064b59af6f1d3d1bb2b22ac00e24f1d762c2fb4267884e7323cd922beeb344e121f3ef29392a8ac773596f0e1dbdcbed501851c4a1661f368c4fe68ad468ea300c4aeb728d58ddb627d7bff33b9c12f80d42365ca91a2a78209191b67afdc9e58d2e9c9759339192427371979fcd686534890d28dcf271b59084504a7cefd18aedf5accdb9947aaaa2e896f1021206161e48b071fd262fe2f290822b0a157f3dc182abdda1c1d1327e5f3491fe62492c0dc493ae4468a6c3fd9d6a5bb49d3d3983339a3b42bf84b463a7e410e1f87e3f63d149100e5fe5807a79c61b03af08b588680bfd4cac5f1d6c91e506781e5cfa1dd7870cd68b6c219876fbd70dd52dceece19bd416a9a5daa9a4fe5afb788cc1ea0f0ad80052d8fdd04556871c54e289e21cf87bed1bce4f181e24f2b88a335e54a10ecc41c39bc48055d1b66660a176032e01c0328a0863d2c1ea4cdb70739eb85b848ee5fc9a3363e184d37d66bc4179e4f1d53d4503fa93ec49dff8be27c25fb6beeb2d95089d0c3ab16936ab5b7429ccb95416ec61a565da0076c2a151548d5d4fd8c7ad17eb1ba4a74c85cd7915ec74afeb7e371f9e69ba8425b3021ac7209eb5dde36091367ae1a6bc335933f2c44e4c4e64a2eea6ddba84d334b435e91e8c52dae0c06f6950cd647bcf432e3d3effcafe34041c809a1c7efd060325cab06024dff8ce23798d2d6c84ff7b5e06945f307c65a8538a74b06825fcf2576f4aa20655ca94a522e82ee8699b1ae7a7ef3d415d66b682aa490f06561fed3e4d94bb6fc531ab7edfca0dea9cfad7b823307dad144544021caa5d32f9ce61fb8e99b92428321eeca5865cf4f19b1f8ebfe353d61d935b688cc8707c9fc8b3257de7c01d8d1d9bfef5db2d756b91ceb76f76536e9cad609bc8011a6641eb569dd8577a68a2fcc1c06c8c4f042a24e73d7236d7cede9eeacfc08202a6a0bdd4c25574aa0f9963b0071647f25f9e316a3c951fdc9c034f632e0c7ff8969b18e501af82a0b7ad308fc8bd5c49e20d76a1696c1bbe0dec55334a432026ac4a1ec64e5f073620754dffdae6d4f9fc6576dfcb132c46deb57baf4a74d54247c894b1aa1c69b735e8db7a1651990b731d262c626a940a24b1f4e4352cbce7e3be56bea084f321475b9bc6ca370f448b8e026868ed051d9b25e12786d8ca000e03b4b33171598bb71f3838277387b6c963a58d4c6da85a9fd0a2f241de0bef26f3e8ee4decea8c372a79acb6d7a6f7743c93b712e5c10a5f15f59f50c948a3f24aba4d232e33d0a7e198e2df75ff7976a25e6a0e48811bc82ba1f84a7b59b563188670c8adbe7ec536f838d381537ddca7df5757a39ca3c2f530661c1234c689a8a4d188e686c88a3211fede5bbb919c484d96ef9372e60bad1de6a6760f12c9b1ffb3c1dbc276aee0c0146ed2f60ab6671da814b0508358e0ca2e3fbacaefd3b03a455a5357f9cdb33cedc2b26173996f84607ab36dbdaa498cf7d1b8f067930ff32c3028948690d366281b4aacc31cf793ed5ce2375b89bc1733caa3e88710814183fc7a141c9bfeff50cf1fb47123e35d04d86952be24f9b34fd02c2793e800b8b91ea43549309de25facd4186f7b9ccf48152bff9d4b26abaf88947f284ffbd414b0bef36093c53185cb50112d2e15ac7ebb6c962da31c9bc3e5635702df9fdb282b30f96f72b3991167e6621899c5b2fea4cd26c0e17fdb8e25dfac0d7d11e640c16413caab7a131af66da46e0a3daa3ad48d808b9a73127e629c8b5e2a4726d94dfa46f2dd13bedb9a8d336be5f5df65d9d8c121354e54b35cbe349fdf92a58b84f38b2251c942e5b66c7afc092e9eeb50bcf45ce548b36b265918ed0af74b1b35c122a62cb86fa776671fd4dffc3fec4e395a6e7991aa8420fd5cbc5c359d8b0aabf1ed40832feb8843bb825a6ed999157ff97e9125333e930342f35cf306cf8dad39e246ed36065796376627229f241dfc986825e52cc5cd5bb17325123cff4114b4e1a0447c4b30bccc83275e0e183dc2058e4aaa613d441d79335bb592e2cea65e77792991a2379690af675885728c70230dfe1d860adce7b3b3bd56913ac53f73216d58639d4efe9e2e283d4009ca2a5d4fa7e3e48469fa0467dc8c94ee990e75dd1c858bf1881115e77923c719127ba86d792c2a92e17b25b79dcc866a8460dbfb785212cad09966d0c56e10ab35d59a384ed0dda82907d7328f673b5d97a18f97f75eed384e5df961523ed6894d34db8a24febd9aedac98136be3ee16111b5f79ecbf2a382e9909c89f5962d4c6ef736f70800afb3bea68f8d8ea225435562530a967c19ef0ad4a69c765944405fcddd38e13bf62be5dfba6cedf23c0c4770160159565fa6d5b37655fad7f0bc609e51f2a6d20ac036f67996598ecce69e64d7c398f2e47702752c99c576743c6839169d054cf5fdfad43bf23a541bee24447a51ce310a87c212b092374ecce61f1a3dae347ac047086e4954e643fe5339e18fb8909a78af3e2f611241e271cb63cbc79da4d22ec1be963da400664c46ae1d340fccb7d3090a33cdcea811bef2eaac7c869e34b552dc8469253ecf9fb349a30b28b12af6b1b17e399486d63555b7d2504cbff2d6d59787f391ed49aac375b6745ce7a83296d6a7ad6193e67afef4e35f573b08ab5bffbc09068598426e3a0b645e0f753dfca94a8209bcb599c164beac1e423d96056db0385a6405aaef5062cb5baa13e841e30f039aad175e4ba28eee3a843425d75659ebf1e73e27c02379b2136315b50d6c12b42bc92e789d02700387f33e6a54a48bd2894f406d80befd1b3de7e72311572bad94f692ec291fbf51705ca49d02a99d92ce145f7bfdbbc55c15e467e34af831b20a7b7b36b9db4f8f3d6795272e06ca533cc538446a49eafd0d31fcea802c2959bdbe809c7fda6483c8b2b5cba9a076efa18d4057641a704ec70b15f74db69168943bf61328b796cfa254fa842acbdf965c97db2110c206e691acb5e5a9a401db3b9f7cc52684bf22706af6471a94ea8904fcce3e7af8cb8d51b2fdee50da87c7a5892faba1732f0f451b35cfafbd8a1f12d94c90f742b5563f21e1683a916cf13f72cb50411209b11007a705a4f63bd9d5ac3408016985d404a9b486f74cae414fa7877f2e2193c2789d41298cc32c0ec55b6cff63c4d2d9bff5e40e7c61d7a2d42f0887cc3e3bc066ff364d7619415df7009ab7b32ce914aa63817c501345b520f21b3b7d31fa075674e876c52f1ef4de0e37c8136192c4cd32e1495c7f13ede069d789ae4d395163b51f2d86b0edbb6006e3af92d2ba8c0b7af9a65ce57480a6cdb57bf79082f88ea327e341d5c4df0aa22f632c7a7c3f6111f26f7b371a47a40513140be551688508132acfdf714121cce9738c80f7de01997a1d475c3229e40577ec14a7c15a20887f5676da4708dcfc77db75241f3ce90a6a241748343333d92c74ceea3f47790912dcb0750393f1335ddf9f8dc9c0c221034689b4677d575124dd5c10e121bc537cf74616984b9ad3de8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ec0dc2ebfabbbd2330186b0b36bc3d65"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
